# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-15 07:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/howto/descriptor.rst:3
msgid "Descriptor HowTo Guide"
msgstr "디스크립터 사용법 안내서"

#: ../Doc/howto/descriptor.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/descriptor.rst:5
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../Doc/howto/descriptor.rst
msgid "Contact"
msgstr "연락처"

#: ../Doc/howto/descriptor.rst:6
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../Doc/howto/descriptor.rst:8
msgid "Contents"
msgstr "목차"

#: ../Doc/howto/descriptor.rst:11
msgid "Abstract"
msgstr "요약"

#: ../Doc/howto/descriptor.rst:13
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors "
"are called.  Examines a custom descriptor and several built-in Python "
"descriptors including functions, properties, static methods, and class "
"methods.  Shows how each works by giving a pure Python equivalent and a "
"sample application."
msgstr ""
"디스크립터를 정의하고, 프로토콜을 요약하며 디스크립터를 호출하는 방법을 보여줍니다. 사용자 정의 디스크립터와 함수, 프로퍼티, 정적"
" 메서드 및 클래스 메서드를 포함한 몇 가지 내장 파이썬 디스크립터를 살펴봅니다. 순수 파이썬과 동등 물과 샘플 응용 프로그램을 "
"제공하여 각각이 작동하는 방식을 보여줍니다."

#: ../Doc/howto/descriptor.rst:18
msgid ""
"Learning about descriptors not only provides access to a larger toolset, "
"it creates a deeper understanding of how Python works and an appreciation"
" for the elegance of its design."
msgstr ""
"디스크립터에 대한 학습은 더 큰 도구 집합에 대한 액세스를 제공할 뿐만 아니라, 파이썬의 작동 방식에 대한 심층적인 이해와 설계의 "
"우아함에 대한 감사를 만듭니다."

#: ../Doc/howto/descriptor.rst:24
msgid "Definition and Introduction"
msgstr "정의와 소개"

#: ../Doc/howto/descriptor.rst:26
msgid ""
"In general, a descriptor is an object attribute with \"binding "
"behavior\", one whose attribute access has been overridden by methods in "
"the descriptor protocol.  Those methods are :meth:`__get__`, "
":meth:`__set__`, and :meth:`__delete__`.  If any of those methods are "
"defined for an object, it is said to be a descriptor."
msgstr ""
"일반적으로 디스크립터는 \"바인딩 동작\"이 있는 객체 어트리뷰트로, 디스크립터 프로토콜의 메서드가 어트리뷰트 액세스를 "
"재정의합니다. 이러한 메서드는 :meth:`__get__`, :meth:`__set__` 및 "
":meth:`__delete__`\\입니다. 이러한 메서드 중 어느 하나가 객체에 대해 정의되면, 디스크립터라고 합니다."

#: ../Doc/howto/descriptor.rst:32
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a "
"lookup chain starting with ``a.__dict__['x']``, then "
"``type(a).__dict__['x']``, and continuing through the base classes of "
"``type(a)`` excluding metaclasses. If the looked-up value is an object "
"defining one of the descriptor methods, then Python may override the "
"default behavior and invoke the descriptor method instead. Where this "
"occurs in the precedence chain depends on which descriptor methods were "
"defined."
msgstr ""
"어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 가져오거나(get) 설정하거나(set) 삭제하는(delete) "
"것입니다. 예를 들어, ``a.x``\\는 ``a.__dict__['x']``\\로 시작한 다음 "
"``type(a).__dict__['x']``\\를 거쳐, 메타 클래스를 제외한 ``type(a)``\\의 베이스 클래스로 계속되는"
" 조회 체인을 갖습니다. 조회된 값이 디스크립터 메서드 중 하나를 정의하는 객체이면, 파이썬은 기본 동작을 대체하고 대신 디스크립터"
" 메서드를 호출 할 수 있습니다. 우선순위 체인에서 이것이 어디쯤 등장하는지는 어떤 디스크립터 메서드가 정의되었는지에 따라 "
"다릅니다."

#: ../Doc/howto/descriptor.rst:41
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and "
":func:`super()`. They are used throughout Python itself to implement the "
"new style classes introduced in version 2.2.  Descriptors simplify the "
"underlying C-code and offer a flexible set of new tools for everyday "
"Python programs."
msgstr ""
"디스크립터는 강력한 범용 프로토콜입니다. 이것들이 프로퍼티, 메서드, 정적 메서드, 클래스 메서드 및 "
":func:`super()`\\의 뒤에 있는 메커니즘입니다. 버전 2.2에 도입된 새로운 스타일 클래스를 구현하기 위해 파이썬 "
"자체에서 사용되었습니다. 디스크립터는 하부 C 코드를 단순화하고 일상적인 파이썬 프로그램을 위한 유연한 새 도구 집합을 제공합니다."

#: ../Doc/howto/descriptor.rst:49
msgid "Descriptor Protocol"
msgstr "디스크립터 프로토콜"

#: ../Doc/howto/descriptor.rst:51
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> value``"

#: ../Doc/howto/descriptor.rst:53
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

#: ../Doc/howto/descriptor.rst:55
msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

#: ../Doc/howto/descriptor.rst:57
msgid ""
"That is all there is to it.  Define any of these methods and an object is"
" considered a descriptor and can override default behavior upon being "
"looked up as an attribute."
msgstr ""
"이것이 전부입니다. 이러한 메서드 중 하나를 정의하십시오, 그러면 객체를 디스크립터로 간주하고 어트리뷰트로 조회될 때 기본 동작을 "
"재정의할 수 있습니다."

#: ../Doc/howto/descriptor.rst:61
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is "
"considered a data descriptor.  Descriptors that only define "
":meth:`__get__` are called non-data descriptors (they are typically used "
"for methods but other uses are possible)."
msgstr ""
"객체가 :meth:`__set__`\\이나 :meth:`__delete__`\\를 정의하면, 데이터 디스크립터로 간주합니다. "
":meth:`__get__` 만 정의하는 디스크립터를 비 데이터 디스크립터라고 합니다 (보통 메서드에 사용되지만 다른 용도도 "
"가능합니다)."

#: ../Doc/howto/descriptor.rst:66
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with"
" respect to entries in an instance's dictionary.  If an instance's "
"dictionary has an entry with the same name as a data descriptor, the data"
" descriptor takes precedence.  If an instance's dictionary has an entry "
"with the same name as a non-data descriptor, the dictionary entry takes "
"precedence."
msgstr ""
"데이터와 비 데이터 디스크립터는 인스턴스 딕셔너리의 항목과 관련하여 재정의가 계산되는 방식이 다릅니다. 인스턴스 딕셔너리에 데이터 "
"디스크립터와 이름이 같은 항목이 있으면, 데이터 디스크립터가 우선합니다. 인스턴스의 딕셔너리에 비 데이터 디스크립터와 이름이 같은 "
"항목이 있으면, 딕셔너리 항목이 우선합니다."

#: ../Doc/howto/descriptor.rst:72
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and "
":meth:`__set__` with the :meth:`__set__` raising an :exc:`AttributeError`"
" when called.  Defining the :meth:`__set__` method with an exception "
"raising placeholder is enough to make it a data descriptor."
msgstr ""
"읽기 전용 데이터 디스크립터를 만들려면, :meth:`__get__`\\과 :meth:`__set__`\\을 모두 정의하고, "
":meth:`__set__`\\이 호출될 때 :exc:`AttributeError`\\를 발생시키십시오. 데이터 디스크립터를 만들기"
" 위해 예외를 발생시키는 자리 표시자로 :meth:`__set__` 메서드를 정의하는 것으로 충분합니다."

#: ../Doc/howto/descriptor.rst:79
msgid "Invoking Descriptors"
msgstr "디스크립터 호출하기"

#: ../Doc/howto/descriptor.rst:81
msgid ""
"A descriptor can be called directly by its method name.  For example, "
"``d.__get__(obj)``."
msgstr "디스크립터는 메서드 이름으로 직접 호출 할 수 있습니다. 예를 들어, ``d.__get__(obj)``."

#: ../Doc/howto/descriptor.rst:84
msgid ""
"Alternatively, it is more common for a descriptor to be invoked "
"automatically upon attribute access.  For example, ``obj.d`` looks up "
"``d`` in the dictionary of ``obj``.  If ``d`` defines the method "
":meth:`__get__`, then ``d.__get__(obj)`` is invoked according to the "
"precedence rules listed below."
msgstr ""
"또는, 어트리뷰트 액세스 시 디스크립터가 자동으로 호출되는 것이 더 일반적입니다. 예를 들어, ``obj.d``\\는 ``obj``"
" 딕셔너리에서 ``d``\\를 조회합니다. ``d``\\가 메서드 :meth:`__get__`\\을 정의하면, 아래 나열된 우선순위"
" 규칙에 따라 ``d.__get__(obj)`` 가 호출됩니다."

#: ../Doc/howto/descriptor.rst:89
msgid ""
"The details of invocation depend on whether ``obj`` is an object or a "
"class."
msgstr "호출 세부 사항은 ``obj``\\가 객체인지 클래스인지에 따라 다릅니다."

#: ../Doc/howto/descriptor.rst:91
msgid ""
"For objects, the machinery is in :meth:`object.__getattribute__` which "
"transforms ``b.x`` into ``type(b).__dict__['x'].__get__(b, type(b))``.  "
"The implementation works through a precedence chain that gives data "
"descriptors priority over instance variables, instance variables priority"
" over non-data descriptors, and assigns lowest priority to "
":meth:`__getattr__` if provided. The full C implementation can be found "
"in :c:func:`PyObject_GenericGetAttr()` in :source:`Objects/object.c`."
msgstr ""
"객체의 경우, 절차는 :meth:`object.__getattribute__`\\에 있으며 ``b.x``\\를 "
"``type(b).__dict__['x'].__get__(b, type(b))``\\로 변환합니다. 구현은 우선순위 체인을 통해 "
"작동하며, 데이터 디스크립터는 인스턴스 변수보다 우선하고, 인스턴스 변수는 비 데이터 디스크립터보다 우선하고, 제공된다면 "
":meth:`__getattr__`\\에 가장 낮은 우선순위를 지정합니다. 전체 C 구현은 "
":source:`Objects/object.c`\\의 :c:func:`PyObject_GenericGetAttr()` 에서 찾을 수"
" 있습니다."

#: ../Doc/howto/descriptor.rst:99
msgid ""
"For classes, the machinery is in :meth:`type.__getattribute__` which "
"transforms ``B.x`` into ``B.__dict__['x'].__get__(None, B)``.  In pure "
"Python, it looks like::"
msgstr ""
"클래스의 경우, 절차는 :meth:`type.__getattribute__`\\에 있으며 ``B.x``\\를 "
"``B.__dict__['x'].__get__(None, B)``\\로 변환합니다. 순수한 파이썬으로 표현하면, 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:110
msgid "The important points to remember are:"
msgstr "기억해야 할 중요한 사항은 다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:112
msgid "descriptors are invoked by the :meth:`__getattribute__` method"
msgstr "디스크립터는 :meth:`__getattribute__` 메서드에 의해 호출됩니다"

#: ../Doc/howto/descriptor.rst:113
msgid "overriding :meth:`__getattribute__` prevents automatic descriptor calls"
msgstr ":meth:`__getattribute__`\\를 재정의하면 자동 디스크립터 호출이 방지됩니다"

#: ../Doc/howto/descriptor.rst:114
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`."
msgstr ""
":meth:`object.__getattribute__`\\와 :meth:`type.__getattribute__`\\는 "
":meth:`__get__`\\를 다르게 호출합니다."

#: ../Doc/howto/descriptor.rst:116
msgid "data descriptors always override instance dictionaries."
msgstr "데이터 디스크립터는 항상 인스턴스 딕셔너리를 대체합니다."

#: ../Doc/howto/descriptor.rst:117
msgid "non-data descriptors may be overridden by instance dictionaries."
msgstr "비 데이터 디스크립터는 인스턴스 딕셔너리로 대체될 수 있습니다."

#: ../Doc/howto/descriptor.rst:119
msgid ""
"The object returned by ``super()`` also has a custom "
":meth:`__getattribute__` method for invoking descriptors.  The attribute "
"lookup ``super(B, obj).m`` searches ``obj.__class__.__mro__`` for the "
"base class ``A`` immediately following ``B`` and then returns "
"``A.__dict__['m'].__get__(obj, B)``.  If not a descriptor, ``m`` is "
"returned unchanged.  If not in the dictionary, ``m`` reverts to a search "
"using :meth:`object.__getattribute__`."
msgstr ""
"``super()``\\가 반환한 객체에도 디스크립터 호출을 위한 사용자 정의 :meth:`__getattribute__` 메서드가"
" 있습니다. 어트리뷰트 조회 ``super(B, obj).m``\\은 ``obj.__class__.__mro__``\\에서 "
"``B`` 바로 다음에 오는 베이스 클래스 ``A``\\를 검색한 다음 ``A.__dict__['m'].__get__(obj, "
"B)``\\를 반환합니다. 디스크립터가 아니면, ``m``\\이 변경되지 않은 상태로 반환됩니다. 딕셔너리에 없으면, "
"``m``\\은 :meth:`object.__getattribute__`\\를 사용한 검색으로 되돌아갑니다."

#: ../Doc/howto/descriptor.rst:126
msgid ""
"The implementation details are in :c:func:`super_getattro()` in "
":source:`Objects/typeobject.c`.  and a pure Python equivalent can be "
"found in `Guido's Tutorial`_."
msgstr ""
"구현 세부 사항은 :source:`Objects/typeobject.c`\\의 :c:func:`super_getattro()`\\에"
" 있습니다. `Guido's Tutorial`_\\에서 순수한 파이썬 동등 물을 찾을 수 있습니다."

#: ../Doc/howto/descriptor.rst:132
msgid ""
"The details above show that the mechanism for descriptors is embedded in "
"the :meth:`__getattribute__()` methods for :class:`object`, "
":class:`type`, and :func:`super`.  Classes inherit this machinery when "
"they derive from :class:`object` or if they have a meta-class providing "
"similar functionality. Likewise, classes can turn-off descriptor "
"invocation by overriding :meth:`__getattribute__()`."
msgstr ""
"위의 세부 사항은 디스크립터 메커니즘이 :class:`object`, :class:`type` 및 :func:`super`\\의 "
":meth:`__getattribute__()` 메서드에 내장되어 있음을 보여줍니다. 클래스는 :class:`object`\\에서 "
"파생되거나 유사한 기능을 제공하는 메타 클래스가 있을 때 이 절차를 상속합니다. 마찬가지로, 클래스는 "
":meth:`__getattribute__()`\\를 재정의하여 디스크립터 호출을 끌 수 있습니다."

#: ../Doc/howto/descriptor.rst:141
msgid "Descriptor Example"
msgstr "디스크립터 예제"

#: ../Doc/howto/descriptor.rst:143
msgid ""
"The following code creates a class whose objects are data descriptors "
"which print a message for each get or set.  Overriding "
":meth:`__getattribute__` is alternate approach that could do this for "
"every attribute.  However, this descriptor is useful for monitoring just "
"a few chosen attributes::"
msgstr ""
"다음 코드는 객체가 데이터 디스크립터인 클래스를 만들어 각 get이나 set에 대해 메시지를 인쇄합니다. "
":meth:`__getattribute__`\\를 재정의하는 것은 모든 어트리뷰트에 대해 이를 수행 할 수 있는 대안 방법입니다. "
"하지만, 이 디스크립터는 선택한 몇 가지 어트리뷰트만 모니터링하는 데 유용합니다::"

#: ../Doc/howto/descriptor.rst:181
msgid ""
"The protocol is simple and offers exciting possibilities.  Several use "
"cases are so common that they have been packaged into individual function"
" calls. Properties, bound methods, static methods, and class methods are "
"all based on the descriptor protocol."
msgstr ""
"이 프로토콜은 간단하고 흥미로운 가능성을 제공합니다. 몇 가지 유스 케이스는 아주 흔해서 개별 함수 호출로 패키징되었습니다. "
"프로퍼티, 연결된 메서드, 정적 메서드 및 클래스 메서드는 모두 디스크립터 프로토콜을 기반으로 합니다."

#: ../Doc/howto/descriptor.rst:188
msgid "Properties"
msgstr "프로퍼티"

#: ../Doc/howto/descriptor.rst:190
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers function calls upon access to an attribute.  Its signature "
"is::"
msgstr ""
":func:`property` 호출은 어트리뷰트에 액세스할 때 함수 호출을 트리거 하는 데이터 디스크립터를 작성하는 간결한 "
"방법입니다. 서명은 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:195
msgid ""
"The documentation shows a typical use to define a managed attribute "
"``x``::"
msgstr "설명(doc)은 관리되는 어트리뷰트 ``x``\\를 정의하는 일반적인 사용법을 보여줍니다::"

#: ../Doc/howto/descriptor.rst:203
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent::"
msgstr ""
"디스크립터 프로토콜 측면에서 :func:`property`\\가 어떻게 구현되는지 확인하려면, 여기 순수한 파이썬 동등 물이 "
"있습니다::"

#: ../Doc/howto/descriptor.rst:243
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of "
"a method."
msgstr ""
":func:`property` 내장은 사용자 인터페이스가 어트리뷰트 액세스를 허가한 후 후속 변경이 메서드의 개입을 요구할 때 "
"도움을 줍니다."

#: ../Doc/howto/descriptor.rst:247
msgid ""
"For instance, a spreadsheet class may grant access to a cell value "
"through ``Cell('b10').value``. Subsequent improvements to the program "
"require the cell to be recalculated on every access; however, the "
"programmer does not want to affect existing client code accessing the "
"attribute directly.  The solution is to wrap access to the value "
"attribute in a property data descriptor::"
msgstr ""
"예를 들어, 스프레드시트 클래스는 ``Cell('b10').value``\\를 통해 셀 값에 대한 액세스를 허가할 수 있습니다. "
"프로그램에 대한 후속 개선은 액세스할 때마다 셀이 재계산될 것을 요구합니다; 하지만, 프로그래머는 어트리뷰트에 직접 액세스하는 기존"
" 클라이언트 코드에 영향을 미치고 싶지 않습니다. 해결책은 프로퍼티 데이터 디스크립터로 value 어트리뷰트에 대한 액세스를 감싸는"
" 것입니다::"

#: ../Doc/howto/descriptor.rst:263
msgid "Functions and Methods"
msgstr "함수와 메서드"

#: ../Doc/howto/descriptor.rst:265
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr "파이썬의 객체 지향 기능은 함수 기반 환경을 기반으로 합니다. 비 데이터 디스크립터를 사용하면, 두 개가 매끄럽게 병합됩니다."

#: ../Doc/howto/descriptor.rst:268
msgid ""
"Class dictionaries store methods as functions.  In a class definition, "
"methods are written using :keyword:`def` or :keyword:`lambda`, the usual "
"tools for creating functions.  Methods only differ from regular functions"
" in that the first argument is reserved for the object instance.  By "
"Python convention, the instance reference is called *self* but may be "
"called *this* or any other variable name."
msgstr ""
"클래스 딕셔너리는 메서드를 함수로 저장합니다. 클래스 정의에서, 메서드는 함수 작성을 위한 일반적인 도구인 "
":keyword:`def`\\나 :keyword:`lambda`\\를 사용하여 작성됩니다. 첫 번째 인자가 객체 인스턴스에 예약되어"
" 있다는 점에서만 메서드가 일반 함수와 다릅니다. 파이썬 규칙에 따라, 인스턴스 참조는 *self*\\라고 하지만 *this*\\나"
" 다른 어떤 변수 이름도 될 수 있습니다."

#: ../Doc/howto/descriptor.rst:275
msgid ""
"To support method calls, functions include the :meth:`__get__` method for"
" binding methods during attribute access.  This means that all functions "
"are non-data descriptors which return bound methods when they are invoked"
" from an object.  In pure Python, it works like this::"
msgstr ""
"메서드 호출을 지원하기 위해, 함수는 어트리뷰트 액세스 중에 메서드를 연결하기 위한 :meth:`__get__` 메서드를 "
"포함합니다. 즉, 모든 함수는 객체에서 호출될 때 연결된 메서드를 반환하는 비 데이터 디스크립터입니다. 순수한 파이썬으로 표현하면,"
" 이것은 다음과 같이 작동합니다::"

#: ../Doc/howto/descriptor.rst:288
msgid ""
"Running the interpreter shows how the function descriptor works in "
"practice::"
msgstr "인터프리터를 실행하면 실제로 함수 디스크립터가 작동하는 방식을 보여줍니다::"

#: ../Doc/howto/descriptor.rst:326
msgid "Static Methods and Class Methods"
msgstr "정적 메서드와 클래스 메서드"

#: ../Doc/howto/descriptor.rst:328
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the "
"usual patterns of binding functions into methods."
msgstr "비 데이터 디스크립터는 함수에 메서드를 바인딩하는 일반적인 패턴을 변형하는 간단한 메커니즘을 제공합니다."

#: ../Doc/howto/descriptor.rst:331
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data "
"descriptor transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  "
"Calling ``klass.f(*args)`` becomes ``f(*args)``."
msgstr ""
"요약하면, 함수에는 :meth:`__get__` 메서드가 있어서 어트리뷰트로 액세스할 때 메서드로 변환될 수 있습니다. 비 데이터 "
"디스크립터는 ``obj.f(*args)`` 호출을 ``f(obj, *args)``\\로 변환합니다. "
"``klass.f(*args)`` 호출은 ``f(*args)``\\가 됩니다."

#: ../Doc/howto/descriptor.rst:336
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "이 표는 연결과 가장 유용한 두 가지 변형을 요약합니다:"

#: ../Doc/howto/descriptor.rst:339
msgid "Transformation"
msgstr "변환"

#: ../Doc/howto/descriptor.rst:339
msgid "Called from an Object"
msgstr "객체에서 호출"

#: ../Doc/howto/descriptor.rst:339
msgid "Called from a Class"
msgstr "클래스에서 호출"

#: ../Doc/howto/descriptor.rst:342
msgid "function"
msgstr "함수"

#: ../Doc/howto/descriptor.rst:342
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../Doc/howto/descriptor.rst:342 ../Doc/howto/descriptor.rst:344
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../Doc/howto/descriptor.rst:344
msgid "staticmethod"
msgstr "staticmethod"

#: ../Doc/howto/descriptor.rst:346
msgid "classmethod"
msgstr "classmethod"

#: ../Doc/howto/descriptor.rst:346
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../Doc/howto/descriptor.rst:346
msgid "f(klass, \\*args)"
msgstr "f(klass, \\*args)"

#: ../Doc/howto/descriptor.rst:349
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into "
"``object.__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, "
"\"f\")``. As a result, the function becomes identically accessible from "
"either an object or a class."
msgstr ""
"정적 메서드는 변경 없이 하부 함수를 반환합니다. ``c.f``\\나 ``C.f`` 호출은 "
"``object.__getattribute__(c, \"f\")``\\나 ``object.__getattribute__(C, "
"\"f\")``\\를 직접 조회하는 것과 동등합니다. 결과적으로, 함수는 객체나 클래스에서 동일하게 액세스 할 수 있습니다."

#: ../Doc/howto/descriptor.rst:355
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "정적 메서드에 적합한 후보는 ``self`` 변수를 참조하지 않는 메서드입니다."

#: ../Doc/howto/descriptor.rst:358
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on "
"the data. However, there may be useful functions which are conceptually "
"related but do not depend on the data.  For instance, ``erf(x)`` is handy"
" conversion routine that comes up in statistical work but does not "
"directly depend on a particular dataset. It can be called either from an "
"object or the class:  ``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> "
".9332``."
msgstr ""
"예를 들어, 통계 패키지는 실험 데이터를 위한 컨테이너 클래스를 포함 할 수 있습니다. 이 클래스는 데이터에 의존하는 산술 평균, "
"평균, 중앙값 및 기타 기술 통계량을 계산하는 일반 메서드를 제공합니다. 그러나, 개념적으로 관련되어 있지만, 데이터에 의존하지 "
"않는 유용한 함수가 있을 수 있습니다. 예를 들어, ``erf(x)``\\는 통계 작업에서 등장하지만, 특정 데이터 집합에 직접 "
"의존하지 않는 편리한 변환 루틴입니다. 객체나 클래스에서 호출 할 수 있습니다: ``s.erf(1.5) --> .9332`` 또는 "
"``Sample.erf(1.5) --> .9332``"

#: ../Doc/howto/descriptor.rst:367
msgid ""
"Since staticmethods return the underlying function with no changes, the "
"example calls are unexciting::"
msgstr "정적 메서드는 변경 없이 하부 함수를 반환하므로, 예제 호출은 흥미롭지 않습니다::"

#: ../Doc/howto/descriptor.rst:380
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`staticmethod` would look like this::"
msgstr "비 데이터 디스크립터 프로토콜을 사용하면, 순수 파이썬 버전의 :func:`staticmethod`\\는 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:392
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class::"
msgstr ""
"정적 메서드와 달리, 클래스 메서드는 함수를 호출하기 전에 클래스 참조를 인자 목록 앞에 추가합니다. 이 형식은 호출자가 객체나 "
"클래스일 때 같습니다::"

#: ../Doc/howto/descriptor.rst:407
msgid ""
"This behavior is useful whenever the function only needs to have a class "
"reference and does not care about any underlying data.  One use for "
"classmethods is to create alternate class constructors.  In Python 2.3, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a "
"list of keys.  The pure Python equivalent is::"
msgstr ""
"이 동작은 함수가 클래스 참조 만 필요하고 하부 데이터를 신경 쓰지 않을 때 유용합니다. 클래스 메서드의 한 가지 용도는 대체 "
"클래스 생성자를 만드는 것입니다. 파이썬 2.3에서, 클래스 메서드 :func:`dict.fromkeys`\\는 키 리스트에서 새 "
"딕셔너리를 만듭니다. 순수한 파이썬 동등 물은 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:423
msgid "Now a new dictionary of unique keys can be constructed like this::"
msgstr "이제 고유 키의 새로운 딕셔너리를 다음과 같이 구성 할 수 있습니다::"

#: ../Doc/howto/descriptor.rst:428
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`classmethod` would look like this::"
msgstr "비 데이터 디스크립터 프로토콜을 사용하면, 순수 파이썬 버전의 :func:`classmethod`\\는 다음과 같습니다::"

