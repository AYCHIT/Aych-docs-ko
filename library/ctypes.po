# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- 파이썬용 외부 함수 라이브러리"

#: ../Doc/library/ctypes.rst:11
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ":mod:`ctypes`\\는 파이썬용 외부 함수(foreign function) 라이브러리입니다. C 호환 데이터형을 제공하며, DLL 또는 공유 라이브러리에 있는 함수를 호출할 수 있습니다. 이 라이브러리들을 순수 파이썬으로 감싸는 데 사용할 수 있습니다."

#: ../Doc/library/ctypes.rst:19
msgid "ctypes tutorial"
msgstr "ctypes 자습서"

#: ../Doc/library/ctypes.rst:21
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure "
"that they actually work.  Since some code samples behave differently "
"under Linux, Windows, or Mac OS X, they contain doctest directives in "
"comments."
msgstr "참고: 이 자습서의 코드 샘플은 :mod:`doctest`\\를 사용하여 실제로 작동하는지 확인합니다. 일부 코드 샘플은 리눅스, 윈도우 또는 맥 OS X에서 다르게 동작하므로, 주석에 doctest 지시문이 포함되어 있습니다."

#: ../Doc/library/ctypes.rst:25
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to "
":class:`c_long`. So, you should not be confused if :class:`c_long` is "
"printed if you would expect :class:`c_int` --- they are actually the same"
" type."
msgstr "참고: 일부 코드 샘플은 ctypes :class:`c_int` 형을 참조합니다. ``sizeof(long) == sizeof(int)``\\인 플랫폼에서, 이는 :class:`c_long`\\의 별칭입니다. 따라서 :class:`c_int`\\를 기대할 때 :class:`c_long`\\가 인쇄되더라도 혼란스러워 하지 않아도됩니다 --- 이 것들은 실제로 같은 형입니다."

#: ../Doc/library/ctypes.rst:33
msgid "Loading dynamic link libraries"
msgstr "동적 링크 라이브러리 로드하기"

#: ../Doc/library/ctypes.rst:35
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ":mod:`ctypes`\\는 동적 링크 라이브러리 로드를 위해 *cdll*\\을, 그리고 윈도우에서는 *windll* 및 *oledll* 객체를, 노출합니다."

#: ../Doc/library/ctypes.rst:38
#, fuzzy
msgid ""
"You load libraries by accessing them as attributes of these objects. "
"*cdll* loads libraries which export functions using the standard "
"``cdecl`` calling convention, while *windll* libraries call functions "
"using the ``stdcall`` calling convention. *oledll* also uses the "
"``stdcall`` calling convention, and assumes the functions return a "
"Windows :c:type:`HRESULT` error code. The error code is used to "
"automatically raise an :class:`OSError` exception when the function call "
"fails."
msgstr "이러한 객체의 속성으로 액세스하여 라이브러리를로드합니다. *cdll* 라이브러리는 표준 ``cdecl`` 호출 규칙을 사용하여 함수를 내보내는 라이브러리를로드하고 *windll* 라이브러리는 ``stdcall`` 호출 규칙을 사용하여 함수를 호출합니다. 또한 *oledll*\\는 ``stdcall`` 호출 규칙을 사용하고 함수가 윈도우 :c:type:`HRESULT` 오류 코드를 반환한다고 가정합니다. 오류 코드는 함수 호출이 실패 할 때 :class:`OSError` 예외를 자동으로 발생시키는 데 사용됩니다."

#: ../Doc/library/ctypes.rst:46
#, fuzzy
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias "
"of :exc:`OSError`."
msgstr "이제는 :exc:`OSError`\\의 별칭 인 :exc:`WindowsError`\\를 올리는 데 사용 된 윈도우 오류입니다."

#: ../Doc/library/ctypes.rst:51
#, fuzzy
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS "
"standard C library containing most standard C functions, and uses the "
"cdecl calling convention::"
msgstr "다음은 윈도우 용 예제입니다. ``msvcrt``\\는 대부분의 표준 C 함수가 포함 된 MS 표준 C 라이브러리이며 cdecl 호출 규칙을 사용합니다.::"

#: ../Doc/library/ctypes.rst:63
#, fuzzy
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "윈도우는 일반적인 ``.dll`` 파일 접미사를 자동으로 추가합니다."

#: ../Doc/library/ctypes.rst:66
#, fuzzy
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one "
"being used by Python. Where possible, use native Python functionality, or"
" else import and use the ``msvcrt`` module."
msgstr "``cdll.msvcrt``\\를 통해 표준 C 라이브러리에 액세스하면 파이썬에서 사용되는 라이브러리와 호환되지 않는 오래된 라이브러리 버전이 사용됩니다. 가능한 경우 원시 파이썬 기능을 사용하거나 ``msvcrt`` 모듈을 가져 와서 사용하십시오."

#: ../Doc/library/ctypes.rst:71
#, fuzzy
msgid ""
"On Linux, it is required to specify the filename *including* the "
"extension to load a library, so attribute access can not be used to load "
"libraries. Either the :meth:`LoadLibrary` method of the dll loaders "
"should be used, or you should load the library by creating an instance of"
" CDLL by calling the constructor::"
msgstr "리눅스에서는 라이브러리를로드하기위한 확장자 인 *including* 파일 이름을 지정해야하므로 속성 액세스를 사용하여 라이브러리를로드 할 수 없습니다. dll 로더의 :meth:`LoadLibrary` 메서드를 사용하거나 생성자를 호출하여 CDLL의 인스턴스를 만들어 라이브러리를로드해야합니다 ::"

#: ../Doc/library/ctypes.rst:89
#, fuzzy
msgid "Accessing functions from loaded dlls"
msgstr "로드 된 dll에서 함수에 액세스"

#: ../Doc/library/ctypes.rst:91
#, fuzzy
msgid "Functions are accessed as attributes of dll objects::"
msgstr "함수는 DLL 객체의 속성으로 액세스됩니다.::"

#: ../Doc/library/ctypes.rst:106
#, fuzzy
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export"
" ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 "
"``GetModuleHandle`` function, which returns a *module handle* for a given"
" module name, has the following C prototype, and a macro is used to "
"expose one of them as ``GetModuleHandle`` depending on whether UNICODE is"
" defined or not::"
msgstr "``kernel32`` 및 ``user32``\\와 같은 win32 시스템 dll은 종종 ANSI뿐만 아니라 UNICODE 버전의 함수를 내 보냅니다. UNICODE 버전은 이름에 ``W``\\가 추가 된 상태로 내보내지며 ANSI 버전은 이름에 ``A``\\가 추가되어 내보내집니다. 지정된 모듈 이름에 대해 *module handle*\\를 반환하는 win32 ``GetModuleHandle`` 함수는 다음과 같은 C 프로토 타입을 가지며 UNICODE가 정의되어 있는지 여부에 따라 매크로 중 하나를 ``GetModuleHandle``\\로 노출하는 데 사용됩니다.::"

#: ../Doc/library/ctypes.rst:119
#, fuzzy
msgid ""
"*windll* does not try to select one of them by magic, you must access the"
" version you need by specifying ``GetModuleHandleA`` or "
"``GetModuleHandleW`` explicitly, and then call it with bytes or string "
"objects respectively."
msgstr "*windll*\\는 마술에 의해 그 중 하나를 선택하려고하지 않으므로 ``GetModuleHandleA`` 또는 ``GetModuleHandleW``\\를 명시 적으로 지정하여 필요한 버전에 액세스 한 다음 각각 바이트 또는 문자열 객체로 호출해야합니다."

#: ../Doc/library/ctypes.rst:123
#, fuzzy
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use "
":func:`getattr` to retrieve the function::"
msgstr "때때로, dll은 ``\"??2@YAPAXI@Z\"``\\와 같은 유효한 파이썬 식별자가 아닌 이름으로 함수를 내 보냅니다. 이 경우 :func:`getattr`\\를 사용하여 함수를 검색해야합니다.::"

#: ../Doc/library/ctypes.rst:131
#, fuzzy
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr "윈도우에서 일부 dll은 이름이 아니라 서수로 함수를 내 보냅니다. 이 함수는 서수로 dll 객체를 인덱싱하여 액세스 할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:148
#, fuzzy
msgid "Calling functions"
msgstr "함수 호출하기"

#: ../Doc/library/ctypes.rst:150
#, fuzzy
msgid ""
"You can call these functions like any other Python callable. This example"
" uses the ``time()`` function, which returns system time in seconds since"
" the Unix epoch, and the ``GetModuleHandleA()`` function, which returns a"
" win32 module handle."
msgstr "다른 파이썬 호출 가능 함수와 마찬가지로이 함수를 호출 할 수 있습니다. 이 예제에서는 Unix 에포크 이후 시스템 시간을 초 단위로 반환하는 ``time()`` 함수와 win32 모듈 핸들을 반환하는 ``GetModuleHandleA()`` 함수를 사용합니다."

#: ../Doc/library/ctypes.rst:155
#, fuzzy
msgid ""
"This example calls both functions with a NULL pointer (``None`` should be"
" used as the NULL pointer)::"
msgstr "이 예는 NULL 포인터로 두 함수를 호출합니다 (``None``\\가 NULL 포인터로 사용되어야 함).::"

#: ../Doc/library/ctypes.rst:166
#, fuzzy
msgid ""
":mod:`ctypes` may raise a :exc:`ValueError` after calling the function, "
"if it detects that an invalid number of arguments were passed.  This "
"behavior should not be relied upon.  It is deprecated in 3.6.2, and will "
"be removed in 3.7."
msgstr "유효하지 않은 수의 인수가 전달 된 것을 감지하면 :mod:`ctypes`\\는 함수를 호출 한 후 :exc:`ValueError`\\를 발생시킵니다. 이 동작은 신뢰할 수 없습니다. 3.6.2에서는 더 이상 사용되지 않으며 3.7에서 제거 될 것입니다."

#: ../Doc/library/ctypes.rst:171
#, fuzzy
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with "
"the ``cdecl`` calling convention, or vice versa::"
msgstr "``cdecl`` 호출 규칙을 사용하여 ``stdcall`` 함수를 호출하면 :exc:`ValueError`\\가 발생하거나 그 반대의 경우도 발생합니다.::"

#: ../Doc/library/ctypes.rst:186
#, fuzzy
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr "올바른 호출 규칙을 찾으려면 C 헤더 파일이나 호출 할 함수에 대한 설명서를 살펴 봐야합니다."

#: ../Doc/library/ctypes.rst:189
#, fuzzy
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr "윈도우에서 :mod:`ctypes`\\는 함수가 유효하지 않은 인수 값을 사용하여 호출 될 때 일반적인 보호 오류로 인한 충돌을 방지하기 위해 win32 구조적 예외 처리를 사용합니다.::"

#: ../Doc/library/ctypes.rst:199
#, fuzzy
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so "
"you should be careful anyway.  The :mod:`faulthandler` module can be "
"helpful in debugging crashes (e.g. from segmentation faults produced by "
"erroneous C library calls)."
msgstr "그러나 :mod:`ctypes`\\로 파이썬을 충돌시킬 수있는 충분한 방법이 있으므로 어쨌든주의해야합니다. :mod:`faulthandler` 모듈은 오류를 디버깅하는 데 도움이 될 수 있습니다 (예 : 오류가있는 C 라이브러리 호출로 인해 생성 된 세그먼트 화 오류)."

#: ../Doc/library/ctypes.rst:204
#, fuzzy
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only "
"native Python objects that can directly be used as parameters in these "
"function calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects"
" and strings are passed as pointer to the memory block that contains "
"their data (:c:type:`char *` or :c:type:`wchar_t *`).  Python integers "
"are passed as the platforms default C :c:type:`int` type, their value is "
"masked to fit into the C type."
msgstr "``None``, 정수, 바이트 객체 및 (유니 코드) 문자열은 이러한 함수 호출에서 매개 변수로 직접 사용할 수있는 유일한 원시 파이썬 객체입니다. ``None``\\는 C ``NULL`` 포인터로 전달되고, bytes 객체와 문자열은 데이터 (:c:type:`char *` 또는 :c:type:`wchar_t *`)가 포함 된 메모리 블록에 대한 포인터로 전달됩니다. 파이썬 정수는 플랫폼의 기본값 인 C :c:type:`int` 유형으로 전달되며, 그 값은 C 유형에 맞게 마스크됩니다."

#: ../Doc/library/ctypes.rst:211
#, fuzzy
msgid ""
"Before we move on calling functions with other parameter types, we have "
"to learn more about :mod:`ctypes` data types."
msgstr "다른 매개 변수 유형으로 함수를 호출하기 전에 :mod:`ctypes` 데이터 유형에 대해 자세히 알아야합니다."

#: ../Doc/library/ctypes.rst:218 ../Doc/library/ctypes.rst:2066
#, fuzzy
msgid "Fundamental data types"
msgstr "기본 데이터 유형"

#: ../Doc/library/ctypes.rst:220
#, fuzzy
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes`\\는 많은 원시적 인 C 호환 데이터 유형을 정의합니다.:"

#: ../Doc/library/ctypes.rst:223
#, fuzzy
msgid "ctypes type"
msgstr "ctypes 유형"

#: ../Doc/library/ctypes.rst:223
#, fuzzy
msgid "C type"
msgstr "C 타입"

#: ../Doc/library/ctypes.rst:223
#, fuzzy
msgid "Python type"
msgstr "파이썬 유형"

#: ../Doc/library/ctypes.rst:225
#, fuzzy
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../Doc/library/ctypes.rst:225
#, fuzzy
msgid ":c:type:`_Bool`"
msgstr ":c:type:`_Bool`"

#: ../Doc/library/ctypes.rst:225
#, fuzzy
msgid "bool (1)"
msgstr "bool (1)"

#: ../Doc/library/ctypes.rst:227
#, fuzzy
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../Doc/library/ctypes.rst:227 ../Doc/library/ctypes.rst:231
#, fuzzy
msgid ":c:type:`char`"
msgstr ":c:type:`char`"

#: ../Doc/library/ctypes.rst:227
#, fuzzy
msgid "1-character bytes object"
msgstr "1 문자 바이트 객체"

#: ../Doc/library/ctypes.rst:229
#, fuzzy
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../Doc/library/ctypes.rst:229
#, fuzzy
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: ../Doc/library/ctypes.rst:229
#, fuzzy
msgid "1-character string"
msgstr "1 자 문자열"

#: ../Doc/library/ctypes.rst:231
#, fuzzy
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../Doc/library/ctypes.rst:231 ../Doc/library/ctypes.rst:233
#: ../Doc/library/ctypes.rst:235 ../Doc/library/ctypes.rst:237
#: ../Doc/library/ctypes.rst:239 ../Doc/library/ctypes.rst:241
#: ../Doc/library/ctypes.rst:243 ../Doc/library/ctypes.rst:245
#: ../Doc/library/ctypes.rst:247 ../Doc/library/ctypes.rst:249
#: ../Doc/library/ctypes.rst:252 ../Doc/library/ctypes.rst:254
#, fuzzy
msgid "int"
msgstr "int"

#: ../Doc/library/ctypes.rst:233
#, fuzzy
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../Doc/library/ctypes.rst:233
#, fuzzy
msgid ":c:type:`unsigned char`"
msgstr ":c:type:`unsigned char`"

#: ../Doc/library/ctypes.rst:235
#, fuzzy
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../Doc/library/ctypes.rst:235
#, fuzzy
msgid ":c:type:`short`"
msgstr ":c:type:`short`"

#: ../Doc/library/ctypes.rst:237
#, fuzzy
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../Doc/library/ctypes.rst:237
#, fuzzy
msgid ":c:type:`unsigned short`"
msgstr ":c:type:`unsigned short`"

#: ../Doc/library/ctypes.rst:239
#, fuzzy
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../Doc/library/ctypes.rst:239
#, fuzzy
msgid ":c:type:`int`"
msgstr ":c:type:`int`"

#: ../Doc/library/ctypes.rst:241
#, fuzzy
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../Doc/library/ctypes.rst:241
#, fuzzy
msgid ":c:type:`unsigned int`"
msgstr ":c:type:`unsigned int`"

#: ../Doc/library/ctypes.rst:243
#, fuzzy
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../Doc/library/ctypes.rst:243
#, fuzzy
msgid ":c:type:`long`"
msgstr ":c:type:`long`"

#: ../Doc/library/ctypes.rst:245
#, fuzzy
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../Doc/library/ctypes.rst:245
#, fuzzy
msgid ":c:type:`unsigned long`"
msgstr ":c:type:`unsigned long`"

#: ../Doc/library/ctypes.rst:247
#, fuzzy
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../Doc/library/ctypes.rst:247
#, fuzzy
msgid ":c:type:`__int64` or :c:type:`long long`"
msgstr ":c:type:`__int64` 또는 :c:type:`long long`"

#: ../Doc/library/ctypes.rst:249
#, fuzzy
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../Doc/library/ctypes.rst:249
#, fuzzy
msgid ":c:type:`unsigned __int64` or :c:type:`unsigned long long`"
msgstr ":c:type:`unsigned __int64` 또는 :c:type:`unsigned long long`"

#: ../Doc/library/ctypes.rst:252
#, fuzzy
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../Doc/library/ctypes.rst:252
#, fuzzy
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../Doc/library/ctypes.rst:254
#, fuzzy
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../Doc/library/ctypes.rst:254
#, fuzzy
msgid ":c:type:`ssize_t` or :c:type:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` 또는 :c:type:`Py_ssize_t`"

#: ../Doc/library/ctypes.rst:257
#, fuzzy
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../Doc/library/ctypes.rst:257
#, fuzzy
msgid ":c:type:`float`"
msgstr ":c:type:`float`"

#: ../Doc/library/ctypes.rst:257 ../Doc/library/ctypes.rst:259
#: ../Doc/library/ctypes.rst:261
#, fuzzy
msgid "float"
msgstr "흙손"

#: ../Doc/library/ctypes.rst:259
#, fuzzy
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../Doc/library/ctypes.rst:259
#, fuzzy
msgid ":c:type:`double`"
msgstr ":c:type:`double`"

#: ../Doc/library/ctypes.rst:261
#, fuzzy
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../Doc/library/ctypes.rst:261
#, fuzzy
msgid ":c:type:`long double`"
msgstr ":c:type:`long double`"

#: ../Doc/library/ctypes.rst:263
#, fuzzy
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../Doc/library/ctypes.rst:263
#, fuzzy
msgid ":c:type:`char *` (NUL terminated)"
msgstr ":c:type:`char *` (NUL 종료 됨)"

#: ../Doc/library/ctypes.rst:263
#, fuzzy
msgid "bytes object or ``None``"
msgstr "바이트 객체 또는 ``None``"

#: ../Doc/library/ctypes.rst:265
#, fuzzy
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../Doc/library/ctypes.rst:265
#, fuzzy
msgid ":c:type:`wchar_t *` (NUL terminated)"
msgstr ":c:type:`wchar_t *` (NUL 종료 됨)"

#: ../Doc/library/ctypes.rst:265
#, fuzzy
msgid "string or ``None``"
msgstr "문자열 또는 ``None``"

#: ../Doc/library/ctypes.rst:267
#, fuzzy
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../Doc/library/ctypes.rst:267
#, fuzzy
msgid ":c:type:`void *`"
msgstr ":c:type:`void *`"

#: ../Doc/library/ctypes.rst:267
#, fuzzy
msgid "int or ``None``"
msgstr "int 또는 ``None``"

#: ../Doc/library/ctypes.rst:271
#, fuzzy
msgid "The constructor accepts any object with a truth value."
msgstr "생성자는 진리 값을 가진 객체를받습니다."

#: ../Doc/library/ctypes.rst:273
#, fuzzy
msgid ""
"All these types can be created by calling them with an optional "
"initializer of the correct type and value::"
msgstr "이 모든 유형은 올바른 유형 및 값의 선택적 초기화자를 사용하여 호출 할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:284
#, fuzzy
msgid ""
"Since these types are mutable, their value can also be changed "
"afterwards::"
msgstr "이러한 유형은 변경 가능하므로 나중에 그 값을 변경할 수도 있습니다.::"

#: ../Doc/library/ctypes.rst:296
#, fuzzy
msgid ""
"Assigning a new value to instances of the pointer types "
":class:`c_char_p`, :class:`c_wchar_p`, and :class:`c_void_p` changes the "
"*memory location* they point to, *not the contents* of the memory block "
"(of course not, because Python bytes objects are immutable)::"
msgstr ":class:`c_char_p`, :class:`c_wchar_p` 및 :class:`c_void_p` 포인터 유형의 인스턴스에 새 값을 할당하면 포인터가 가리키는 *memory location* (메모리 블록의 *not the contents*)가 변경됩니다 (물론 파이썬 바이트 객체가 변경 불가능하기 때문에).::"

#: ../Doc/library/ctypes.rst:316
#, fuzzy
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has"
" a :func:`create_string_buffer` function which creates these in various "
"ways.  The current memory block contents can be accessed (or changed) "
"with the ``raw`` property; if you want to access it as NUL terminated "
"string, use the ``value`` property::"
msgstr "그러나 변경 가능한 메모리에 대한 포인터를 예상하는 함수에 전달하지 않도록주의해야합니다. 가변 메모리 블록이 필요하다면, ctypes는 다양한 방법으로 이들을 생성하는 :func:`create_string_buffer` 함수를 가지고있다. 현재 메모리 블록 내용은 ``raw`` 속성을 사용하여 액세스하거나 변경할 수 있습니다. NUL 종료 문자열로 액세스하려면 ``value`` 속성을 사용하십시오.::"

#: ../Doc/library/ctypes.rst:340
#, fuzzy
msgid ""
"The :func:`create_string_buffer` function replaces the :func:`c_buffer` "
"function (which is still available as an alias), as well as the "
":func:`c_string` function from earlier ctypes releases.  To create a "
"mutable memory block containing unicode characters of the C type "
":c:type:`wchar_t` use the :func:`create_unicode_buffer` function."
msgstr ":func:`create_string_buffer` 함수는 이전 ctypes 릴리스의 :func:`c_string` 함수뿐만 아니라 :func:`c_buffer` 함수 (별칭으로 계속 사용할 수 있음)를 대체합니다. C 타입 :c:type:`wchar_t`\\의 유니 코드 문자를 포함하는 가변 메모리 블록을 생성하려면 :func:`create_unicode_buffer` 함수를 사용하십시오."

#: ../Doc/library/ctypes.rst:350
#, fuzzy
msgid "Calling functions, continued"
msgstr "함수 호출, 계속"

#: ../Doc/library/ctypes.rst:352
#, fuzzy
msgid ""
"Note that printf prints to the real standard output channel, *not* to "
":data:`sys.stdout`, so these examples will only work at the console "
"prompt, not from within *IDLE* or *PythonWin*::"
msgstr "printf는 실제 표준 출력 채널 인 *not*\\에서 :data:`sys.stdout`\\로 출력하므로이 예제는 *IDLE* 또는 *PythonWin* ::가 아닌 콘솔 프롬프트에서만 작동합니다::"

#: ../Doc/library/ctypes.rst:372
#, fuzzy
msgid ""
"As has been mentioned before, all Python types except integers, strings, "
"and bytes objects have to be wrapped in their corresponding :mod:`ctypes`"
" type, so that they can be converted to the required C data type::"
msgstr "이전에 언급했듯이, 정수, 문자열 및 바이트 객체를 제외한 모든 파이썬 유형은 해당하는 :mod:`ctypes` 유형으로 래핑되어야하므로 필요한 C 데이터 유형으로 변환 될 수 있습니다.::"

#: ../Doc/library/ctypes.rst:385
#, fuzzy
msgid "Calling functions with your own custom data types"
msgstr "사용자 지정 데이터 형식을 사용하여 함수 호출"

#: ../Doc/library/ctypes.rst:387
#, fuzzy
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow "
"instances of your own classes be used as function arguments.  "
":mod:`ctypes` looks for an :attr:`_as_parameter_` attribute and uses this"
" as the function argument.  Of course, it must be one of integer, string,"
" or bytes::"
msgstr "또한 :mod:`ctypes` 인수 변환을 사용자 정의하여 사용자 고유 클래스의 인스턴스를 함수 인수로 사용할 수 있습니다. :mod:`ctypes`\\는 :attr:`_as_parameter_` 속성을 찾고이를 함수 인수로 사용합니다. 물론 정수, 문자열 또는 바이트 중 하나 여야합니다.::"

#: ../Doc/library/ctypes.rst:402
#, fuzzy
msgid ""
"If you don't want to store the instance's data in the "
":attr:`_as_parameter_` instance variable, you could define a "
":class:`property` which makes the attribute available on request."
msgstr ":attr:`_as_parameter_` 인스턴스 변수에 인스턴스의 데이터를 저장하지 않으려면 :class:`property`\\를 정의하여 요청시 속성을 사용할 수있게 할 수 있습니다."

#: ../Doc/library/ctypes.rst:410
#, fuzzy
msgid "Specifying the required argument types (function prototypes)"
msgstr "필수 인수 유형 지정 (함수 프로토 타입)"

#: ../Doc/library/ctypes.rst:412
#, fuzzy
msgid ""
"It is possible to specify the required argument types of functions "
"exported from DLLs by setting the :attr:`argtypes` attribute."
msgstr ":attr:`argtypes` 특성을 설정하여 DLL에서 내 보낸 함수의 필수 인수 유형을 지정할 수 있습니다."

#: ../Doc/library/ctypes.rst:415
#, fuzzy
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` "
"function is probably not a good example here, because it takes a variable"
" number and different types of parameters depending on the format string,"
" on the other hand this is quite handy to experiment with this feature)::"
msgstr ":attr:`argtypes`\\는 C 데이터 유형의 시퀀스 여야합니다 (``printf`` 함수는 형식 문자열에 따라 변수 번호와 매개 변수 유형이 필요하기 때문에 여기서는 좋은 예가 아닐 수 있습니다. 반면에 이것은 이것을 실험하기에 매우 편리합니다. 특색)::"

#: ../Doc/library/ctypes.rst:426
#, fuzzy
msgid ""
"Specifying a format protects against incompatible argument types (just as"
" a prototype for a C function), and tries to convert the arguments to "
"valid types::"
msgstr "형식을 지정하면 호환되지 않는 인수 유형 (C 함수의 프로토 타입)을 보호하고 유효한 형식으로 인수를 변환하려고 시도합니다.::"

#: ../Doc/library/ctypes.rst:438
#, fuzzy
msgid ""
"If you have defined your own classes which you pass to function calls, "
"you have to implement a :meth:`from_param` class method for them to be "
"able to use them in the :attr:`argtypes` sequence. The :meth:`from_param`"
" class method receives the Python object passed to the function call, it "
"should do a typecheck or whatever is needed to make sure this object is "
"acceptable, and then return the object itself, its :attr:`_as_parameter_`"
" attribute, or whatever you want to pass as the C function argument in "
"this case. Again, the result should be an integer, string, bytes, a "
":mod:`ctypes` instance, or an object with an :attr:`_as_parameter_` "
"attribute."
msgstr "함수 호출에 전달하는 클래스를 정의한 경우 :attr:`argtypes` 시퀀스에서 해당 클래스를 사용할 수 있도록 :meth:`from_param` 클래스 메서드를 구현해야합니다. :meth:`from_param` 클래스 메서드는 함수 호출에 전달 된 파이썬 객체를받습니다. 형식 검사 또는이 객체가 수용 가능한지 확인하는 데 필요한 모든 작업을 수행 한 다음 객체 자체, :attr:`_as_parameter_` 특성 또는 원하는 객체를 반환해야합니다. 이 경우 C 함수 인수. 다시 말하지만 결과는 정수, 문자열, 바이트, :mod:`ctypes` 인스턴스 또는 :attr:`_as_parameter_` 속성이있는 객체 여야합니다."

#: ../Doc/library/ctypes.rst:452
#, fuzzy
msgid "Return types"
msgstr "반환 유형"

#: ../Doc/library/ctypes.rst:454
#, fuzzy
msgid ""
"By default functions are assumed to return the C :c:type:`int` type.  "
"Other return types can be specified by setting the :attr:`restype` "
"attribute of the function object."
msgstr "기본적으로 함수는 C :c:type:`int` 유형을 반환한다고 가정합니다. 다른 리턴 유형은 함수 오브젝트의 :attr:`restype` 속성을 설정하여 지정할 수 있습니다."

#: ../Doc/library/ctypes.rst:458
#, fuzzy
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr "다음은보다 고급 예제입니다. ``strchr`` 함수는 문자열 포인터와 char을 필요로하며 문자열에 대한 포인터를 반환합니다 ::"

#: ../Doc/library/ctypes.rst:471
#, fuzzy
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the "
":attr:`argtypes` attribute, and the second argument will be converted "
"from a single character Python bytes object into a C char::"
msgstr "위의 ``ord(\"x\")`` 호출을 피하려면 :attr:`argtypes` 특성을 설정할 수 있으며 두 번째 인수는 단일 문자 파이썬 바이트 객체에서 C char ::로 변환됩니다.::"

#: ../Doc/library/ctypes.rst:489
#, fuzzy
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function "
"returns an integer.  The callable will be called with the *integer* the C"
" function returns, and the result of this call will be used as the result"
" of your function call. This is useful to check for error return values "
"and automatically raise an exception::"
msgstr "외부 함수가 정수를 반환하면 호출 가능한 파이썬 객체 (예 : 함수 또는 클래스)를 :attr:`restype` 속성으로 사용할 수도 있습니다. 호출 가능 함수는 C 함수가 리턴하는 *integer*\\로 호출되며이 호출의 결과는 함수 호출의 결과로 사용됩니다. 이것은 에러 반환 값을 검사하고 자동으로 예외를 발생시키는 데 유용합니다 ::"

#: ../Doc/library/ctypes.rst:512
#, fuzzy
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` "
"api to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one"
" is used, it calls :func:`GetLastError` to retrieve it."
msgstr "``WinError``\\는 윈도우 ``FormatMessage()`` API를 호출하여 오류 코드의 문자열 표현을 가져오고 *returns*\\는 예외를 호출하는 함수입니다. ``WinError``\\는 선택적 오류 코드 매개 변수를 취합니다. 아무 것도 사용되지 않으면 :func:`GetLastError`\\를 호출하여 오류 코드를 검색합니다."

#: ../Doc/library/ctypes.rst:517
#, fuzzy
msgid ""
"Please note that a much more powerful error checking mechanism is "
"available through the :attr:`errcheck` attribute; see the reference "
"manual for details."
msgstr "훨씬 더 강력한 오류 검사 메커니즘은 :attr:`errcheck` 속성을 통해 사용할 수 있습니다. 자세한 내용은 참조 설명서를 참조하십시오."

#: ../Doc/library/ctypes.rst:524
#, fuzzy
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "전달 포인터 (또는 참조로 매개 변수 전달)"

#: ../Doc/library/ctypes.rst:526
#, fuzzy
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as "
"parameter, probably to write into the corresponding location, or if the "
"data is too large to be passed by value. This is also known as *passing "
"parameters by reference*."
msgstr "때때로 C API 함수는 *pointer*\\를 데이터 유형으로 매개 변수로 예상합니다. 아마도 해당 위치에 쓰거나 데이터가 너무 커서 값으로 전달할 수 없습니다. 이것은 *passing parameters by reference*\\라고도합니다."

#: ../Doc/library/ctypes.rst:530
#, fuzzy
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the "
":func:`pointer` function, although :func:`pointer` does a lot more work "
"since it constructs a real pointer object, so it is faster to use "
":func:`byref` if you don't need the pointer object in Python itself::"
msgstr ":mod:`ctypes`\\는 매개 변수를 참조로 전달하는 데 사용되는 :func:`byref` 함수를 내 보냅니다. :func:`pointer`\\는 실제 포인터 객체를 생성 한 이후로 :func:`pointer`\\가 더 많은 작업을 수행하기 때문에 동일한 효과를 얻을 수 있습니다. 따라서 파이썬 자체에서 포인터 객체가 필요하지 않으면 :func:`byref`\\를 사용하는 것이 더 빠릅니다.::"

#: ../Doc/library/ctypes.rst:552
#, fuzzy
msgid "Structures and unions"
msgstr "구조와 노동 조합"

#: ../Doc/library/ctypes.rst:554
#, fuzzy
msgid ""
"Structures and unions must derive from the :class:`Structure` and "
":class:`Union` base classes which are defined in the :mod:`ctypes` "
"module. Each subclass must define a :attr:`_fields_` attribute.  "
":attr:`_fields_` must be a list of *2-tuples*, containing a *field name* "
"and a *field type*."
msgstr "구조체와 공용체는 :mod:`ctypes` 모듈에 정의 된 :class:`Structure` 및 :class:`Union` 기본 클래스에서 파생되어야합니다. 각 서브 클래스는 :attr:`_fields_` 속성을 정의해야합니다. :attr:`_fields_`\\는 *field name* 및 *field type*\\를 포함하는 *2-tuples* 목록이어야합니다."

#: ../Doc/library/ctypes.rst:559
#, fuzzy
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr "필드 유형은 :class:`c_int`\\와 같은 :mod:`ctypes` 유형 또는 다른 파생 된 :mod:`ctypes` 유형 (구조, 공용체, 배열, 포인터)이어야합니다."

#: ../Doc/library/ctypes.rst:562
#, fuzzy
msgid ""
"Here is a simple example of a POINT structure, which contains two "
"integers named *x* and *y*, and also shows how to initialize a structure "
"in the constructor::"
msgstr "다음은 *x* 및 *y*\\라는 두 개의 정수가 포함 된 POINT 구조의 간단한 예제이며 생성자에서 구조를 초기화하는 방법도 보여줍니다.::"

#: ../Doc/library/ctypes.rst:582
#, fuzzy
msgid ""
"You can, however, build much more complicated structures.  A structure "
"can itself contain other structures by using a structure as a field type."
msgstr "그러나 훨씬 복잡한 구조를 만들 수 있습니다. 구조체는 필드 형식으로 구조체를 사용하여 다른 구조체를 포함 할 수 있습니다."

#: ../Doc/library/ctypes.rst:585
#, fuzzy
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr "다음은 *upperleft* 및 *lowerright*\\라는 두 개의 POINT를 포함하는 RECT 구조체입니다.::"

#: ../Doc/library/ctypes.rst:599
#, fuzzy
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr "중첩 된 구조체는 여러 가지 방법으로 생성자에서 초기화 할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:604
#, fuzzy
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr "필드 :term:`descriptor` \\ s는 *class*\\에서 검색 할 수 있습니다. 유용한 정보를 제공 할 수 있기 때문에 디버깅에 유용합니다.::"

#: ../Doc/library/ctypes.rst:618
#, fuzzy
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-"
"fields to functions by value.  While this may work on 32-bit x86, it's "
"not guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by "
"pointer."
msgstr ":mod:`ctypes`\\는 비트 필드가있는 공용체 또는 구조체를 값별로 함수에 전달할 수 없습니다. 이 기능은 32 비트 x86에서 작동하지만 일반적으로 라이브러리가 작동하는 것은 아닙니다. 비트 필드가있는 공용체와 구조체는 항상 포인터에 의해 함수에 전달되어야합니다."

#: ../Doc/library/ctypes.rst:624
#, fuzzy
msgid "Structure/union alignment and byte order"
msgstr "구조체 / 공용체 정렬 및 바이트 순서"

#: ../Doc/library/ctypes.rst:626
#, fuzzy
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior be specifying "
"a :attr:`_pack_` class attribute in the subclass definition. This must be"
" set to a positive integer and specifies the maximum alignment for the "
"fields. This is what ``#pragma pack(n)`` also does in MSVC."
msgstr "기본적으로 Structure와 Union 필드는 C 컴파일러와 동일한 방식으로 정렬됩니다. 서브 클래스 정의에서 :attr:`_pack_` 클래스 속성을 지정하면이 작동을 대체 할 수 있습니다. 이 값을 양의 정수로 설정하고 필드의 최대 정렬을 지정해야합니다. 이것은 MSVC에서 ``#pragma pack(n)``\\가 수행하는 것입니다."

#: ../Doc/library/ctypes.rst:632
#, fuzzy
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the "
":class:`BigEndianStructure`, :class:`LittleEndianStructure`, "
":class:`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  "
"These classes cannot contain pointer fields."
msgstr ":mod:`ctypes`\\는 구조체 및 공용체의 기본 바이트 순서를 사용합니다. 기본이 아닌 바이트 순서로 구조를 작성하려면 :class:`BigEndianStructure`, :class:`LittleEndianStructure`, :class:`BigEndianUnion` 및 :class:`LittleEndianUnion` 기본 클래스 중 하나를 사용할 수 있습니다. 이러한 클래스는 포인터 필드를 포함 할 수 없습니다."

#: ../Doc/library/ctypes.rst:642
#, fuzzy
msgid "Bit fields in structures and unions"
msgstr "구조체와 공용체의 비트 필드"

#: ../Doc/library/ctypes.rst:644
#, fuzzy
msgid ""
"It is possible to create structures and unions containing bit fields. Bit"
" fields are only possible for integer fields, the bit width is specified "
"as the third item in the :attr:`_fields_` tuples::"
msgstr "비트 필드를 포함하는 구조체와 공용체를 생성하는 것이 가능합니다. 비트 필드는 정수 필드에만 가능하며 비트 폭은 :attr:`_fields_` 튜플의 세 번째 항목으로 지정됩니다.::"

#: ../Doc/library/ctypes.rst:662
#, fuzzy
msgid "Arrays"
msgstr "배열"

#: ../Doc/library/ctypes.rst:664
#, fuzzy
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr "배열은 동일한 유형의 고정 된 수의 인스턴스를 포함하는 시퀀스입니다."

#: ../Doc/library/ctypes.rst:666
#, fuzzy
msgid ""
"The recommended way to create array types is by multiplying a data type "
"with a positive integer::"
msgstr "배열 유형을 만드는 데 권장되는 방법은 데이터 유형에 양의 정수를 곱하는 것입니다.::"

#: ../Doc/library/ctypes.rst:671
#, fuzzy
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr "다음은 다소 인공적인 데이터 유형의 예입니다. 다른 항목들 중에서 4 개의 POINT를 포함하는 구조체입니다.::"

#: ../Doc/library/ctypes.rst:687
#, fuzzy
msgid "Instances are created in the usual way, by calling the class::"
msgstr "인스턴스는 클래스를 호출하여 일반적인 방법으로 생성됩니다 ::"

#: ../Doc/library/ctypes.rst:693
#, fuzzy
msgid ""
"The above code print a series of ``0 0`` lines, because the array "
"contents is initialized to zeros."
msgstr "위 코드는 배열 내용이 0으로 초기화되기 때문에 일련의 ``0 0`` 행을 인쇄합니다."

#: ../Doc/library/ctypes.rst:696
#, fuzzy
msgid "Initializers of the correct type can also be specified::"
msgstr "올바른 유형의 초기화 프로그램을 지정할 수도 있습니다.::"

#: ../Doc/library/ctypes.rst:712
#, fuzzy
msgid "Pointers"
msgstr "포인터"

#: ../Doc/library/ctypes.rst:714
#, fuzzy
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on "
"a :mod:`ctypes` type::"
msgstr "포인터 인스턴스는 :mod:`ctypes` 유형의 :func:`pointer` 함수를 호출하여 생성됩니다.::"

#: ../Doc/library/ctypes.rst:722
#, fuzzy
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which "
"returns the object to which the pointer points, the ``i`` object above::"
msgstr "포인터 인스턴스는 포인터가 가리키는 객체, 즉 위에있는 ``i`` 객체를 반환하는 :attr:`~_Pointer.contents` 속성을가집니다.::"

#: ../Doc/library/ctypes.rst:729
#, fuzzy
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ":mod:`ctypes`\\에는 OOR (원래 객체 반환)이 없으므로 속성을 가져올 때마다 새 객체를 생성합니다.::"

#: ../Doc/library/ctypes.rst:738
#, fuzzy
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where "
"this is stored::"
msgstr "다른 :class:`c_int` 인스턴스를 포인터의 contents 속성에 할당하면 포인터가이 포인터가 저장되어있는 메모리 위치를 가리 킵니다.::"

#: ../Doc/library/ctypes.rst:750
#, fuzzy
msgid "Pointer instances can also be indexed with integers::"
msgstr "포인터 인스턴스는 정수로도 인덱싱 할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:756
#, fuzzy
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "정수 인덱스에 할당하면 값이 다음과 같이 변경됩니다.::"

#: ../Doc/library/ctypes.rst:765
#, fuzzy
msgid ""
"It is also possible to use indexes different from 0, but you must know "
"what you're doing, just as in C: You can access or change arbitrary "
"memory locations. Generally you only use this feature if you receive a "
"pointer from a C function, and you *know* that the pointer actually "
"points to an array instead of a single item."
msgstr "0과 다른 인덱스를 사용할 수도 있지만 C와 마찬가지로 자신이하고있는 일을 알아야합니다. 임의의 메모리 위치를 액세스하거나 변경할 수 있습니다. 일반적으로 C 함수에서 포인터를 받고 포인터가 실제로 단일 항목 대신 배열을 가리키는 경우에만이 기능을 사용합니다. *know*"

#: ../Doc/library/ctypes.rst:771
#, fuzzy
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply "
"create pointer instances, it has to create pointer *types* first. This is"
" done with the :func:`POINTER` function, which accepts any :mod:`ctypes` "
"type, and returns a new type::"
msgstr "뒤에서 :func:`pointer` 함수는 단순히 포인터 인스턴스를 만드는 것 이상을 수행합니다. 먼저 포인터 *types*\\를 만들어야합니다. 이것은 :mod:`ctypes` 타입을 받아들이고, 새로운 타입을 반환하는 :func:`POINTER` 함수로 수행됩니다 ::"

#: ../Doc/library/ctypes.rst:787
#, fuzzy
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr "인수없이 포인터 유형을 호출하면 ``NULL`` 포인터가 작성됩니다. ``NULL`` 포인터에는 ``False`` 부울 값이 있습니다 ::"

#: ../Doc/library/ctypes.rst:795
#, fuzzy
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ":mod:`ctypes`\\는 포인터를 참조 해제 할 때 ``NULL``\\를 확인합니다 (그러나 잘못된 \\ ``NULL`` 포인터를 역 참조하는 것은 파이썬을 충돌시킵니다).::"

#: ../Doc/library/ctypes.rst:814
#, fuzzy
msgid "Type conversions"
msgstr "유형 변환"

#: ../Doc/library/ctypes.rst:816
#, fuzzy
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the "
"type of a member field in a structure definition, only instances of "
"exactly the same type are accepted.  There are some exceptions to this "
"rule, where ctypes accepts other objects.  For example, you can pass "
"compatible array instances instead of pointer types.  So, for "
"``POINTER(c_int)``, ctypes accepts an array of c_int::"
msgstr "일반적으로 ctypes는 엄격한 유형 검사를 수행합니다. 즉, 함수의 :attr:`argtypes` 목록에 ``POINTER(c_int)``\\가 있거나 구조 정의의 멤버 필드 유형으로 정확히 동일한 유형의 인스턴스 만 허용됩니다. 이 규칙에는 ctypes가 다른 객체를 허용하는 몇 가지 예외가 있습니다. 예를 들어, 포인터 유형 대신 호환 가능한 배열 인스턴스를 전달할 수 있습니다. 따라서 ``POINTER(c_int)``\\의 경우 ctype은 c_int 배열을 허용합니다 ::"

#: ../Doc/library/ctypes.rst:837
#, fuzzy
msgid ""
"In addition, if a function argument is explicitly declared to be a "
"pointer type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object "
"of the pointed type (``c_int`` in this case) can be passed to the "
"function.  ctypes will apply the required :func:`byref` conversion in "
"this case automatically."
msgstr "또한 함수 인수가 :attr:`argtypes`\\에 포인터 유형 (예 : ``POINTER(c_int)``)으로 명시 적으로 선언 된 경우, 지적 유형 (이 경우 ``c_int``)의 오브젝트를 함수에 전달할 수 있습니다. 이 경우 ctypes는 필요한 :func:`byref` 변환을 자동으로 적용합니다."

#: ../Doc/library/ctypes.rst:842
#, fuzzy
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr "POINTER 유형 필드를 ``NULL``\\로 설정하려면 ``None`` ::"

#: ../Doc/library/ctypes.rst:849
#, fuzzy
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast "
"one type into another type.  :mod:`ctypes` provides a :func:`cast` "
"function which can be used in the same way.  The ``Bar`` structure "
"defined above accepts ``POINTER(c_int)`` pointers or :class:`c_int` "
"arrays for its ``values`` field, but not instances of other types::"
msgstr "경우에 따라 호환되지 않는 유형의 인스턴스가있을 수 있습니다. C에서는 한 유형을 다른 유형으로 변환 할 수 있습니다. :mod:`ctypes`\\는 동일한 방식으로 사용할 수있는 :func:`cast` 기능을 제공합니다. 위에 정의 된 ``Bar`` 구조체는 해당 ``values`` 필드에 대해 ``POINTER(c_int)`` 포인터 또는 :class:`c_int` 배열을 사용할 수 있지만 다른 유형의 인스턴스는 사용할 수 없습니다.::"

#: ../Doc/library/ctypes.rst:861
#, fuzzy
msgid "For these cases, the :func:`cast` function is handy."
msgstr "이 경우 :func:`cast` 기능이 편리합니다."

#: ../Doc/library/ctypes.rst:863
#, fuzzy
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two "
"parameters, a ctypes object that is or can be converted to a pointer of "
"some kind, and a ctypes pointer type.  It returns an instance of the "
"second argument, which references the same memory block as the first "
"argument::"
msgstr ":func:`cast` 함수는 ctypes 인스턴스를 다른 ctypes 데이터 유형에 대한 포인터로 변환하는 데 사용할 수 있습니다. :func:`cast`\\는 두 가지 매개 변수, 어떤 종류의 포인터로 변환 될 수있는 ctypes 객체 및 ctypes 포인터 유형을 사용합니다. 첫 번째 인수와 동일한 메모리 블록을 참조하는 두 번째 인수의 인스턴스를 반환합니다.::"

#: ../Doc/library/ctypes.rst:874
#, fuzzy
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar``"
" the structure::"
msgstr "따라서 :func:`cast`\\는 ``Bar``\\의 ``values`` 필드에 구조체를 할당하는 데 사용할 수 있습니다 ::"

#: ../Doc/library/ctypes.rst:887
#, fuzzy
msgid "Incomplete Types"
msgstr "불완전한 유형"

#: ../Doc/library/ctypes.rst:889
#, fuzzy
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not"
" yet specified. In C, they are specified by forward declarations, which "
"are defined later::"
msgstr "*Incomplete Types*\\는 멤버가 아직 지정되지 않은 구조체, 공용체 또는 배열입니다. C에서, 그들은 다음에 정의 된 forward 선언에 의해 지정됩니다 ::"

#: ../Doc/library/ctypes.rst:900
#, fuzzy
msgid ""
"The straightforward translation into ctypes code would be this, but it "
"does not work::"
msgstr "ctypes 코드로의 직접 변환은 가능하지만 작동하지 않습니다.::"

#: ../Doc/library/ctypes.rst:913
#, fuzzy
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the "
":attr:`_fields_` attribute later, after the class statement::"
msgstr "새 ``class cell``\\는 클래스 문 자체에서 사용할 수 없으므로 :mod:`ctypes`\\에서 우리는 ``cell`` 클래스를 정의하고 나중에 class 문 다음에 :attr:`_fields_` 속성을 설정할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:925
#, fuzzy
msgid ""
"Lets try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr "해 보자. 우리는 두 개의 ``cell`` 인스턴스를 만들고 서로 가리 키도록하고 마지막으로 포인터 체인을 몇 번 따라 간다.::"

#: ../Doc/library/ctypes.rst:946
#, fuzzy
msgid "Callback functions"
msgstr "콜백 함수"

#: ../Doc/library/ctypes.rst:948
#, fuzzy
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ":mod:`ctypes`\\는 파이썬 호출 가능 함수에서 C 호출 가능 함수 포인터를 생성 할 수 있습니다. 이들은 *callback functions*\\라고도합니다."

#: ../Doc/library/ctypes.rst:951
#, fuzzy
msgid ""
"First, you must create a class for the callback function. The class knows"
" the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr "먼저, 콜백 함수를위한 클래스를 생성해야한다. 클래스는 호출 규칙, 반환 유형 및이 함수가받는 인수의 수와 유형을 알고 있습니다."

#: ../Doc/library/ctypes.rst:955
#, fuzzy
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback "
"functions using the ``cdecl`` calling convention. On Windows, the "
":func:`WINFUNCTYPE` factory function creates types for callback functions"
" using the ``stdcall`` calling convention."
msgstr ":func:`CFUNCTYPE` 팩토리 함수는 ``cdecl`` 호출 규칙을 사용하여 콜백 함수의 유형을 작성합니다. 윈도우에서 :func:`WINFUNCTYPE` 팩토리 함수는 ``stdcall`` 호출 규칙을 사용하여 콜백 함수 유형을 만듭니다."

#: ../Doc/library/ctypes.rst:960
#, fuzzy
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr "이러한 팩토리 함수는 모두 첫 번째 인수로 결과 유형을 사용하여 호출되며 나머지 인수는 콜백 함수에서 예상 인수 유형을 사용합니다."

#: ../Doc/library/ctypes.rst:964
#, fuzzy
msgid ""
"I will present an example here which uses the standard C library's "
":c:func:`qsort` function, that is used to sort items with the help of a "
"callback function.  :c:func:`qsort` will be used to sort an array of "
"integers::"
msgstr "콜백 함수를 사용하여 항목을 정렬하는 데 사용되는 표준 C 라이브러리의 :c:func:`qsort` 함수를 사용하는 예제를 제시합니다. :c:func:`qsort`\\는 정수 배열을 정렬하는 데 사용됩니다.::"

#: ../Doc/library/ctypes.rst:974
#, fuzzy
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the "
"number of items in the data array, the size of one item, and a pointer to"
" the comparison function, the callback. The callback will then be called "
"with two pointers to items, and it must return a negative integer if the "
"first item is smaller than the second, a zero if they are equal, and a "
"positive integer otherwise."
msgstr ":func:`qsort`\\는 정렬 할 데이터에 대한 포인터, 데이터 배열의 항목 수, 항목 하나의 크기 및 비교 함수 인 콜백에 대한 포인터로 호출해야합니다. 콜백은 항목에 대한 두 개의 포인터를 사용하여 호출되며 첫 번째 항목이 두 번째 항목보다 작 으면 음의 정수를, 그렇지 않으면 0을, 그렇지 않으면 양수 정수를 반환해야합니다."

#: ../Doc/library/ctypes.rst:980
#, fuzzy
msgid ""
"So our callback function receives pointers to integers, and must return "
"an integer. First we create the ``type`` for the callback function::"
msgstr "따라서 콜백 함수는 정수에 대한 포인터를 받고 정수를 반환해야합니다. 먼저 콜백 함수를위한 ``type``\\를 생성합니다 ::"

#: ../Doc/library/ctypes.rst:986
#, fuzzy
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr "시작하기 위해 전달 된 값을 보여주는 간단한 콜백이 있습니다.::"

#: ../Doc/library/ctypes.rst:996
#, fuzzy
msgid "The result::"
msgstr "결과::"

#: ../Doc/library/ctypes.rst:1006
#, fuzzy
msgid "Now we can actually compare the two items and return a useful result::"
msgstr "이제 실제로 두 항목을 비교하여 유용한 결과를 반환 할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:1021
#, fuzzy
msgid "As we can easily check, our array is sorted now::"
msgstr "우리가 쉽게 확인할 수 있기 때문에, 배열은 지금 정렬됩니다 ::"

#: ../Doc/library/ctypes.rst:1028
#, fuzzy
msgid ""
"The function factories can be used as decorator factories, so we may as "
"well write::"
msgstr "함수 팩토리는 데코레이터 팩토리로 사용할 수 있으므로 다음과 같이 작성할 수 있습니다 ::"

#: ../Doc/library/ctypes.rst:1046
#, fuzzy
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as "
"they are used from C code. :mod:`ctypes` doesn't, and if you don't, they "
"may be garbage collected, crashing your program when a callback is made."
msgstr "C 코드에서 사용되는 한 :func:`CFUNCTYPE` 오브젝트에 대한 참조를 유지해야합니다. :mod:`ctypes`\\는 그렇지 않으며 콜백이 발생하면 프로그램이 충돌하여 가비지 수집 될 수 있습니다."

#: ../Doc/library/ctypes.rst:1050
#, fuzzy
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values "
"stored with :class:`threading.local` will *not* survive across different "
"callbacks, even when those calls are made from the same C thread."
msgstr "또한 콜백 함수가 파이썬 컨트롤 외부에서 생성 된 스레드 (예 : 콜백을 호출하는 외부 코드)에서 호출되는 경우 ctypes는 모든 호출에서 새로운 더미 파이썬 스레드를 만듭니다. 이 동작은 대부분의 경우에 적합하지만 :class:`threading.local`\\와 함께 저장된 값은 동일한 C 스레드에서 호출 한 경우에도 *not*\\가 다른 콜백에서 살아남을 수 있음을 의미합니다."

#: ../Doc/library/ctypes.rst:1060
#, fuzzy
msgid "Accessing values exported from dlls"
msgstr "dll에서 내 보낸 값 액세스"

#: ../Doc/library/ctypes.rst:1062
#, fuzzy
msgid ""
"Some shared libraries not only export functions, they also export "
"variables. An example in the Python library itself is the "
":c:data:`Py_OptimizeFlag`, an integer set to 0, 1, or 2, depending on the"
" :option:`-O` or :option:`-OO` flag given on startup."
msgstr "일부 공유 라이브러리는 함수를 내보낼뿐만 아니라 변수를 내 보냅니다. 파이썬 라이브러리 자체의 예제는 시작시 주어진 :option:`-O` 또는 :option:`-OO` 플래그에 따라 :c:data:`Py_OptimizeFlag`, 0, 1 또는 2로 설정된 정수입니다."

#: ../Doc/library/ctypes.rst:1067
#, fuzzy
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to"
" the Python C api::"
msgstr ":mod:`ctypes`\\는 유형의 :meth:`in_dll` 클래스 메소드를 사용하여 이와 같은 값에 액세스 할 수 있습니다. *pythonapi*\\는 파이썬 C API에 대한 액세스를 제공하는 미리 정의 된 심볼입니다.::"

#: ../Doc/library/ctypes.rst:1076
#, fuzzy
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would"
" have been specified."
msgstr "해석기가 :option:`-O`\\로 시작된 경우 샘플에는 ``c_long(1)``\\가 인쇄되거나 :option:`-OO`\\가 지정된 경우 ``c_long(2)``\\가 인쇄됩니다."

#: ../Doc/library/ctypes.rst:1080
#, fuzzy
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr "포인터의 사용법을 보여주는 확장 예제는 파이썬이 내 보낸 :c:data:`PyImport_FrozenModules` 포인터에 접근합니다."

#: ../Doc/library/ctypes.rst:1083
#, fuzzy
msgid "Quoting the docs for that value:"
msgstr "해당 값에 대한 문서 인용 :"

#: ../Doc/library/ctypes.rst:1085
#, fuzzy
msgid ""
"This pointer is initialized to point to an array of :c:type:`struct "
"_frozen` records, terminated by one whose members are all *NULL* or zero."
"  When a frozen module is imported, it is searched in this table.  Third-"
"party code could play tricks with this to provide a dynamically created "
"collection of frozen modules."
msgstr "이 포인터는 멤버가 모두 *NULL* 또는 0 인 :c:type:`struct _frozen` 레코드 배열을 가리 키도록 초기화됩니다. 고정 된 모듈을 가져 오면이 테이블에서 검색됩니다. 써드 파티 코드는 동결 된 모듈의 컬렉션을 동적으로 생성하기 위해 이와 함께 트릭을 실행할 수 있습니다."

#: ../Doc/library/ctypes.rst:1090
#, fuzzy
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with "
":mod:`ctypes`::"
msgstr "따라서이 포인터를 조작하는 것이 유용 할 수도 있습니다. 예제 크기를 제한하기 위해 :mod:`ctypes` ::로이 테이블을 읽는 방법 만 보여줍니다.::"

#: ../Doc/library/ctypes.rst:1102
#, fuzzy
msgid ""
"We have defined the :c:type:`struct _frozen` data type, so we can get the"
" pointer to the table::"
msgstr ":c:type:`struct _frozen` 데이터 유형을 정의 했으므로 테이블에 대한 포인터를 얻을 수 있습니다.::"

#: ../Doc/library/ctypes.rst:1109
#, fuzzy
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` "
"records, we can iterate over it, but we just have to make sure that our "
"loop terminates, because pointers have no size. Sooner or later it would "
"probably crash with an access violation or whatever, so it's better to "
"break out of the loop when we hit the NULL entry::"
msgstr "``table``\\는 ``struct_frozen`` 레코드의 배열에 대한 ``pointer``\\이므로 포인터를 크기가 없기 때문에 루프를 종료해야합니다. 조만간 액세스 위반 등으로 인해 충돌이 발생할 수 있으므로 NULL 입력시 루프에서 벗어나는 것이 좋습니다.::"

#: ../Doc/library/ctypes.rst:1127
#, fuzzy
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative size member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr "표준 파이썬이 고정 된 모듈과 고정 된 패키지 (음수 크기 멤버로 표시됨)를 가지고 있다는 사실은 잘 알려져 있지 않으며 테스트 용으로 만 사용됩니다. 예를 들어 ``import __hello__``\\로 시도해보십시오."

#: ../Doc/library/ctypes.rst:1135
#, fuzzy
msgid "Surprises"
msgstr "놀라움"

#: ../Doc/library/ctypes.rst:1137
#, fuzzy
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something "
"other than what actually happens."
msgstr ":mod:`ctypes`\\에는 실제로 발생하는 것 이외의 다른 것을 기대할 수있는 가장자리가 있습니다."

#: ../Doc/library/ctypes.rst:1140
#, fuzzy
msgid "Consider the following example::"
msgstr "다음 예제를 고려하십시오.::"

#: ../Doc/library/ctypes.rst:1160
#, fuzzy
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line "
"above::"
msgstr "흠. 우리는 마지막 문장이 ``3 4 1 2``\\를 인쇄 할 것을 기대했습니다. 어떻게 된 거예요? 위의 ``rc.a, rc.b = rc.b, rc.a`` 라인의 단계는 다음과 같습니다 ::"

#: ../Doc/library/ctypes.rst:1168
#, fuzzy
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies "
"the buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, "
"changes the contents of ``temp1``. So, the last assignment ``rc.b = "
"temp1``, doesn't have the expected effect."
msgstr "``temp0`` 및 ``temp1``\\는 여전히 위의 ``rc`` 객체의 내부 버퍼를 사용하는 객체입니다. 따라서 ``rc.a = temp0``\\를 실행하면 ``temp0``\\의 버퍼 내용이 ``rc``\\의 버퍼로 복사됩니다. 이것은 차례로 ``temp1``\\의 내용을 변경합니다. 따라서 마지막 과제 인 ``rc.b = temp1``\\에는 예상되는 효과가 없습니다."

#: ../Doc/library/ctypes.rst:1174
#, fuzzy
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and "
"Arrays doesn't *copy* the sub-object, instead it retrieves a wrapper "
"object accessing the root-object's underlying buffer."
msgstr "Structure, Unions 및 Arrays에서 하위 객체를 가져 오는 것은 하위 객체를 *copy*\\하지 않고 대신 루트 객체의 기본 버퍼에 액세스하는 래퍼 객체를 검색한다는 점에 유의하십시오."

#: ../Doc/library/ctypes.rst:1178
#, fuzzy
msgid ""
"Another example that may behave different from what one would expect is "
"this::"
msgstr "예상과 다른 행동을하는 또 다른 예는 다음과 같습니다 ::"

#: ../Doc/library/ctypes.rst:1188
#, fuzzy
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of "
"the memory. Storing a Python object in the memory block does not store "
"the object itself, instead the ``contents`` of the object is stored.  "
"Accessing the contents again constructs a new Python object each time!"
msgstr "``False``\\로 인쇄하는 이유는 무엇입니까? ctypes 인스턴스는 메모리 블록과 메모리 내용에 액세스하는 일부 :term:`descriptor`\\를 포함하는 객체입니다. 메모리 블록에 파이썬 객체를 저장하면 객체 자체를 저장하지 않고 대신 객체의 ``contents``\\를 저장합니다. 내용에 다시 액세스하면 매번 새로운 파이썬 객체가 생성됩니다!"

#: ../Doc/library/ctypes.rst:1198
#, fuzzy
msgid "Variable-sized data types"
msgstr "가변 크기 데이터 유형"

#: ../Doc/library/ctypes.rst:1200
#, fuzzy
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and "
"structures."
msgstr ":mod:`ctypes`\\는 가변 크기 배열 및 구조에 대한 일부 지원을 제공합니다."

#: ../Doc/library/ctypes.rst:1202
#, fuzzy
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an"
" existing ctypes object.  The function takes the object as first "
"argument, and the requested size in bytes as the second argument.  The "
"memory block cannot be made smaller than the natural memory block "
"specified by the objects type, a :exc:`ValueError` is raised if this is "
"tried::"
msgstr ":func:`resize` 함수는 기존 ctypes 객체의 메모리 버퍼 크기를 조정하는 데 사용할 수 있습니다. 이 함수는 객체를 첫 번째 인수로 가져오고 요청 된 크기를 두 번째 인수로 바이트 단위로 가져옵니다. 메모리 블록을 객체 유형으로 지정된 자연 메모리 블록보다 작게 만들 수 없습니다. 시도하면 :exc:`ValueError`\\가 발생합니다.::"

#: ../Doc/library/ctypes.rst:1222
#, fuzzy
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 "
"elements, we get errors accessing other elements::"
msgstr "괜찮 으면 좋겠지 만이 배열에 포함 된 추가 요소에 어떻게 액세스 할 수 있습니까? 유형은 여전히 약 4 개의 요소 만 알고 있으므로 다른 요소에 액세스하는 데 오류가 발생합니다.::"

#: ../Doc/library/ctypes.rst:1234
#, fuzzy
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use"
" the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ":mod:`ctypes`\\에서 가변 크기 데이터 유형을 사용하는 또 다른 방법은 파이썬의 동적 특성을 사용하고 필요한 크기가 이미 알려진 후 (경우에 따라) 데이터 유형을 (다시) 정의하는 것입니다."

#: ../Doc/library/ctypes.rst:1242
#, fuzzy
msgid "ctypes reference"
msgstr "ctypes 참조"

#: ../Doc/library/ctypes.rst:1248
#, fuzzy
msgid "Finding shared libraries"
msgstr "공유 라이브러리 찾기"

#: ../Doc/library/ctypes.rst:1250
#, fuzzy
msgid ""
"When programming in a compiled language, shared libraries are accessed "
"when compiling/linking a program, and when the program is run."
msgstr "컴파일 된 언어로 프로그래밍 할 때 공유 라이브러리는 프로그램을 컴파일 / 링크 할 때 및 프로그램이 실행될 때 액세스됩니다."

#: ../Doc/library/ctypes.rst:1253
#, fuzzy
msgid ""
"The purpose of the :func:`find_library` function is to locate a library "
"in a way similar to what the compiler or runtime loader does (on "
"platforms with several versions of a shared library the most recent "
"should be loaded), while the ctypes library loaders act like when a "
"program is run, and call the runtime loader directly."
msgstr ":func:`find_library` 함수의 목적은 컴파일러 또는 런타임 로더가 수행하는 것과 비슷한 방식으로 라이브러리를 찾는 것입니다 (여러 버전의 공유 라이브러리가있는 플랫폼에서 가장 최근의 것을로드해야 함). ctypes 라이브러리 로더는 프로그램이 실행되고 런타임 로더를 직접 호출합니다."

#: ../Doc/library/ctypes.rst:1259
#, fuzzy
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ":mod:`ctypes.util` 모듈은로드 할 라이브러리를 판별하는 데 도움이되는 기능을 제공합니다."

#: ../Doc/library/ctypes.rst:1267
#, fuzzy
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version"
" number (this is the form used for the posix linker option "
":option:`!-l`).  If no library can be found, returns ``None``."
msgstr "라이브러리를 찾고 경로명을 반환하십시오. *name*\\는 *lib*, ``.so``, ``.dylib`` 또는 버전 번호와 같은 접미사가없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 :option:`!-l`\\에 사용되는 양식입니다). 라이브러리를 찾을 수 없으면 ``None``\\를 반환합니다."

#: ../Doc/library/ctypes.rst:1272 ../Doc/library/ctypes.rst:1860
#, fuzzy
msgid "The exact functionality is system dependent."
msgstr "정확한 기능은 시스템에 따라 다릅니다."

#: ../Doc/library/ctypes.rst:1274
#, fuzzy
msgid ""
"On Linux, :func:`find_library` tries to run external programs "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library"
" file. It returns the filename of the library file."
msgstr "리눅스에서 :func:`find_library`\\는 외부 프로그램 (``/sbin/ldconfig``, ``gcc``, ``objdump`` 및 ``ld``)을 실행하여 라이브러리 파일을 찾습니다. 라이브러리 파일의 파일 이름을 반환합니다."

#: ../Doc/library/ctypes.rst:1278
#, fuzzy
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is "
"used when searching for libraries, if a library cannot be found by any "
"other means."
msgstr "리눅스에서는 다른 수단으로 라이브러리를 찾을 수없는 경우 라이브러리 검색시 환경 변수 ``LD_LIBRARY_PATH``\\의 값이 사용됩니다."

#: ../Doc/library/ctypes.rst:1282
#, fuzzy
msgid "Here are some examples::"
msgstr "여기 예시들이 있습니다::"

#: ../Doc/library/ctypes.rst:1293
#, fuzzy
msgid ""
"On OS X, :func:`find_library` tries several predefined naming schemes and"
" paths to locate the library, and returns a full pathname if successful::"
msgstr "OS X에서 :func:`find_library`\\는 미리 정의 된 몇 가지 명명 체계와 경로를 시도하여 라이브러리를 찾은 다음 성공하면 전체 경로 이름을 반환합니다.::"

#: ../Doc/library/ctypes.rst:1307
#, fuzzy
msgid ""
"On Windows, :func:`find_library` searches along the system search path, "
"and returns the full pathname, but since there is no predefined naming "
"scheme a call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr "윈도우에서 :func:`find_library`\\는 시스템 검색 경로를 따라 검색하고 전체 경로 이름을 반환하지만 미리 정의 된 명명 체계가 없으므로 ``find_library(\"c\")``\\와 같은 호출이 실패하고 ``None``\\를 반환합니다."

#: ../Doc/library/ctypes.rst:1311
#, fuzzy
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate "
"the library at runtime."
msgstr "공유 라이브러리를 :mod:`ctypes`\\로 래핑하는 경우 개발시 공유 라이브러리 이름을 확인하고 런타임시 라이브러리를 찾기 위해 :func:`find_library`\\를 사용하는 대신 래퍼 모듈에 하드 코딩해야합니다. *may*"

#: ../Doc/library/ctypes.rst:1319
#, fuzzy
msgid "Loading shared libraries"
msgstr "공유 라이브러리로드 중"

#: ../Doc/library/ctypes.rst:1321
#, fuzzy
msgid ""
"There are several ways to load shared libraries into the Python process."
"  One way is to instantiate one of the following classes:"
msgstr "공유 라이브러리를 파이썬 프로세스에로드하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 다음 클래스 중 하나를 인스턴스화하는 것입니다.:"

#: ../Doc/library/ctypes.rst:1327
#, fuzzy
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to"
" return :c:type:`int`."
msgstr "이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타냅니다. 이 라이브러리의 함수는 표준 C 호출 규칙을 사용하며 :c:type:`int`\\를 반환한다고 가정합니다."

#: ../Doc/library/ctypes.rst:1334
#, fuzzy
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and "
"are assumed to return the windows specific :class:`HRESULT` code.  "
":class:`HRESULT` values contain information specifying whether the "
"function call failed or succeeded, together with additional error code.  "
"If the return value signals a failure, an :class:`OSError` is "
"automatically raised."
msgstr "윈도우 전용 :이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타내며이 라이브러리의 함수는 ``stdcall`` 호출 규칙을 사용하며 윈도우 특정 :class:`HRESULT` 코드를 반환한다고 가정합니다. :class:`HRESULT` 값에는 함수 호출이 실패했는지 또는 성공했는지 여부와 추가 오류 코드를 지정하는 정보가 들어 있습니다. 반환 값이 실패를 알리는 경우 :class:`OSError`\\가 자동으로 발생합니다."

#: ../Doc/library/ctypes.rst:1341
#, fuzzy
msgid ":exc:`WindowsError` used to be raised."
msgstr ":exc:`WindowsError`\\를 올렸어."

#: ../Doc/library/ctypes.rst:1347
#, fuzzy
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and "
"are assumed to return :c:type:`int` by default."
msgstr "윈도우 전용 :이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타내며이 라이브러리의 함수는 ``stdcall`` 호출 규칙을 사용하며 기본적으로 :c:type:`int`\\를 반환한다고 가정합니다."

#: ../Doc/library/ctypes.rst:1351
#, fuzzy
msgid ""
"On Windows CE only the standard calling convention is used, for "
"convenience the :class:`WinDLL` and :class:`OleDLL` use the standard "
"calling convention on this platform."
msgstr "윈도우 CE에서는 편의상 :class:`WinDLL` 및 :class:`OleDLL`\\가이 플랫폼에서 표준 호출 규칙을 사용하기 때문에 표준 호출 규칙 만 사용됩니다."

#: ../Doc/library/ctypes.rst:1355
#, fuzzy
msgid ""
"The Python :term:`global interpreter lock` is released before calling any"
" function exported by these libraries, and reacquired afterwards."
msgstr "파이썬 :term:`global interpreter lock`\\는이 라이브러리들에 의해 익스포트 된 함수를 호출하기 전에 해제되고 나중에 재 획득됩니다."

#: ../Doc/library/ctypes.rst:1361
#, fuzzy
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that "
"the Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is"
" set, a Python exception is raised."
msgstr "이 클래스의 인스턴스는 :class:`CDLL` 인스턴스처럼 동작합니다. 단, 파이썬 GIL이 함수 호출 중에 릴리스 된 *not*\\이고 함수 실행 후 파이썬 오류 플래그가 확인된다는 점만 다릅니다. 오류 플래그가 설정되면 파이썬 예외가 발생합니다."

#: ../Doc/library/ctypes.rst:1366
#, fuzzy
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr "따라서, 이것은 파이썬 C API 함수를 직접 호출하는 경우에만 유용합니다."

#: ../Doc/library/ctypes.rst:1368
#, fuzzy
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen``"
" or ``LoadLibrary`` function is used to load the library into the "
"process, and to get a handle to it."
msgstr "이러한 모든 클래스는 공유 라이브러리의 경로 이름 인 적어도 하나의 인수를 사용하여 인스턴스화 할 수 있습니다. 이미로드 된 공유 라이브러리에 대한 기존 핸들이있는 경우,이를 ``handle`` 명명 된 매개 변수로 전달할 수 있습니다. 그렇지 않으면 기본 플랫폼 ``dlopen`` 또는 ``LoadLibrary`` 함수를 사용하여 라이브러리를 프로세스에로드하고 이에 대한 핸들을 확보합니다."

#: ../Doc/library/ctypes.rst:1375
#, fuzzy
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  "
"For details, consult the :manpage:`dlopen(3)` manpage.  On Windows, "
"*mode* is ignored.  On posix systems, RTLD_NOW is always added, and is "
"not configurable."
msgstr "*mode* 매개 변수는 라이브러리가로드되는 방법을 지정하는 데 사용될 수 있습니다. 자세한 내용은 :manpage:`dlopen(3)` 맨 페이지를 참조하십시오. 윈도우에서는 *mode*\\가 무시됩니다. posix 시스템에서 RTLD_NOW는 항상 추가되며 구성 할 수 없습니다."

#: ../Doc/library/ctypes.rst:1380
#, fuzzy
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism "
"that allows accessing the system :data:`errno` error number in a safe "
"way. :mod:`ctypes` maintains a thread-local copy of the systems "
":data:`errno` variable; if you call foreign functions created with "
"``use_errno=True`` then the :data:`errno` value before the function call "
"is swapped with the ctypes private copy, the same happens immediately "
"after the function call."
msgstr "*use_errno* 매개 변수를 true로 설정하면 시스템 :data:`errno` 오류 번호에 안전하게 액세스 할 수있는 ctypes 메커니즘을 사용할 수 있습니다. :mod:`ctypes`\\는 시스템 :data:`errno` 변수의 스레드 로컬 사본을 유지 보수합니다. ``use_errno=True``\\로 만든 외부 함수를 호출하면 함수 호출 전에 :data:`errno` 값이 ctypes 개인 복사본으로 스왑되며 함수 호출 직후에도 마찬가지입니다."

#: ../Doc/library/ctypes.rst:1387
#, fuzzy
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the "
"ctypes private copy to a new value and returns the former value."
msgstr ":func:`ctypes.get_errno` 함수는 ctypes 개인용 사본의 값을 리턴하고 :func:`ctypes.set_errno` 함수는 ctypes 개인용 사본을 새 값으로 변경하고 이전 값을 리턴합니다."

#: ../Doc/library/ctypes.rst:1391
#, fuzzy
msgid ""
"The *use_last_error* parameter, when set to true, enables the same "
"mechanism for the Windows error code which is managed by the "
":func:`GetLastError` and :func:`SetLastError` Windows API functions; "
":func:`ctypes.get_last_error` and :func:`ctypes.set_last_error` are used "
"to request and change the ctypes private copy of the windows error code."
msgstr "*use_last_error* 매개 변수를 true로 설정하면 :func:`GetLastError` 및 :func:`SetLastError` 윈도우 API 함수에서 관리하는 윈도우 오류 코드와 동일한 메커니즘을 사용할 수 있습니다. :func:`ctypes.get_last_error` 및 :func:`ctypes.set_last_error`\\는 windows 오류 코드의 ctypes 개인용 사본을 요청하고 변경하는 데 사용됩니다."

#: ../Doc/library/ctypes.rst:1400
#, fuzzy
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr "*mode* 매개 변수로 사용할 플래그. 이 플래그를 사용할 수없는 플랫폼에서는 정수 0으로 정의됩니다."

#: ../Doc/library/ctypes.rst:1407
#, fuzzy
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not "
"available, it is the same as *RTLD_GLOBAL*."
msgstr "*mode* 매개 변수로 사용할 플래그. 이 플랫폼을 사용할 수없는 플랫폼에서는 *RTLD_GLOBAL*\\와 동일합니다."

#: ../Doc/library/ctypes.rst:1414
#, fuzzy
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, "
"this is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr "공유 라이브러리를로드하는 데 사용되는 기본 모드. OSX 10.3에서는 *RTLD_GLOBAL*\\이고, 그렇지 않으면 *RTLD_LOCAL*\\와 같습니다."

#: ../Doc/library/ctypes.rst:1417
#, fuzzy
msgid ""
"Instances of these classes have no public methods.  Functions exported by"
" the shared library can be accessed as attributes or by index.  Please "
"note that accessing the function through an attribute caches the result "
"and therefore accessing it repeatedly returns the same object each time."
"  On the other hand, accessing it through an index returns a new object "
"each time::"
msgstr "이러한 클래스의 인스턴스에는 public 메서드가 없습니다. 공유 라이브러리가 반출 한 함수는 속성 또는 색인으로 액세스 할 수 있습니다. 속성을 통해 함수에 액세스하면 결과가 캐시되므로 반복적으로 액세스하면 매번 같은 객체가 반환됩니다. 반면에 인덱스를 통해 액세스하면 매번 새로운 객체가 반환됩니다.::"

#: ../Doc/library/ctypes.rst:1430
#, fuzzy
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr "다음 공용 속성을 사용할 수 있습니다. 이름은 밑줄로 시작하여 내 보낸 함수 이름과 충돌하지 않습니다.:"

#: ../Doc/library/ctypes.rst:1436
#, fuzzy
msgid "The system handle used to access the library."
msgstr "라이브러리에 액세스하는 데 사용되는 시스템 핸들."

#: ../Doc/library/ctypes.rst:1441
#, fuzzy
msgid "The name of the library passed in the constructor."
msgstr "생성자에서 전달 된 라이브러리의 이름입니다."

#: ../Doc/library/ctypes.rst:1443
#, fuzzy
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either "
"by calling the :meth:`LoadLibrary` method, or by retrieving the library "
"as attribute of the loader instance."
msgstr "공유 라이브러리는 :meth:`LoadLibrary` 메소드를 호출하거나 로더 인스턴스의 속성으로 라이브러리를 검색하여 :class:`LibraryLoader` 클래스의 인스턴스 인 사전 작성된 오브젝트 중 하나를 사용하여로드 할 수도 있습니다."

#: ../Doc/library/ctypes.rst:1451
#, fuzzy
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the "
":class:`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr "공유 라이브러리를로드하는 클래스. *dlltype*\\는 :class:`CDLL`, :class:`PyDLL`, :class:`WinDLL` 또는 :class:`OleDLL` 유형 중 하나 여야합니다."

#: ../Doc/library/ctypes.rst:1454
#, fuzzy
msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared "
"library by accessing it as attribute of a library loader instance.  The "
"result is cached, so repeated attribute accesses return the same library "
"each time."
msgstr ":meth:`__getattr__`\\에는 특수한 동작이 있습니다. 라이브러리 로더 인스턴스의 속성으로 액세스하여 공유 라이브러리를로드 할 수 있습니다. 결과는 캐시되므로 반복되는 속성 액세스는 매번 같은 라이브러리를 반환합니다."

#: ../Doc/library/ctypes.rst:1460
#, fuzzy
msgid ""
"Load a shared library into the process and return it.  This method always"
" returns a new instance of the library."
msgstr "공유 라이브러리를 프로세스에로드하고 리턴하십시오. 이 메서드는 항상 라이브러리의 새 인스턴스를 반환합니다."

#: ../Doc/library/ctypes.rst:1464
#, fuzzy
msgid "These prefabricated library loaders are available:"
msgstr "다음과 같은 조립식 라이브러리 로더를 사용할 수 있습니다.:"

#: ../Doc/library/ctypes.rst:1469
#, fuzzy
msgid "Creates :class:`CDLL` instances."
msgstr ":class:`CDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1475
#, fuzzy
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "윈도우 전용 : :class:`WinDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1481
#, fuzzy
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "윈도우 전용 : :class:`OleDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1487
#, fuzzy
msgid "Creates :class:`PyDLL` instances."
msgstr ":class:`PyDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1490
#, fuzzy
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr "C 파이썬 API에 직접 액세스하기 위해 바로 사용할 수있는 파이썬 공유 라이브러리 객체를 사용할 수 있습니다 :"

#: ../Doc/library/ctypes.rst:1496
#, fuzzy
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C "
":c:type:`int`, which is of course not always the truth, so you have to "
"assign the correct :attr:`restype` attribute to use these functions."
msgstr "파이썬 C API 함수를 속성으로 노출시키는 :class:`PyDLL`\\의 인스턴스. 이 모든 함수는 C :c:type:`int`\\를 반환한다고 가정합니다. 물론 항상 진리는 아니므로이 함수를 사용하려면 올바른 :attr:`restype` 특성을 할당해야합니다."

#: ../Doc/library/ctypes.rst:1505
#, fuzzy
msgid "Foreign functions"
msgstr "외국 기능"

#: ../Doc/library/ctypes.rst:1507
#, fuzzy
msgid ""
"As explained in the previous section, foreign functions can be accessed "
"as attributes of loaded shared libraries.  The function objects created "
"in this way by default accept any number of arguments, accept any ctypes "
"data instances as arguments, and return the default result type specified"
" by the library loader. They are instances of a private class:"
msgstr "이전 섹션에서 설명한 것처럼 외부 함수는로드 된 공유 라이브러리의 특성으로 액세스 할 수 있습니다. 기본적으로 이런 방식으로 작성된 함수 오브젝트는 인수의 수를 허용하고, ctypes 데이터 인스턴스를 인수로 허용하고, 라이브러리 로더에 의해 지정된 디폴트 결과 유형을 리턴합니다. 그것들은 private 클래스의 인스턴스입니다.:"

#: ../Doc/library/ctypes.rst:1516
#, fuzzy
msgid "Base class for C callable foreign functions."
msgstr "C 호출 가능한 외부 함수의 기본 클래스입니다."

#: ../Doc/library/ctypes.rst:1518
#, fuzzy
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr "외부 함수의 인스턴스는 C 호환 데이터 유형입니다. 그들은 C 함수 포인터를 나타냅니다."

#: ../Doc/library/ctypes.rst:1521
#, fuzzy
msgid ""
"This behavior can be customized by assigning to special attributes of the"
" foreign function object."
msgstr "이 동작은 외부 함수 객체의 특수 특성에 할당하여 사용자 정의 할 수 있습니다."

#: ../Doc/library/ctypes.rst:1526
#, fuzzy
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. "
"Use ``None`` for :c:type:`void`, a function not returning anything."
msgstr "ctypes 유형을 지정하여 외부 함수의 결과 유형을 지정하십시오. :c:type:`void`\\에 대해 ``None``\\를 사용하면 아무 것도 반환하지 않는 함수입니다."

#: ../Doc/library/ctypes.rst:1529
#, fuzzy
msgid ""
"It is possible to assign a callable Python object that is not a ctypes "
"type, in this case the function is assumed to return a C :c:type:`int`, "
"and the callable will be called with this integer, allowing further "
"processing or error checking.  Using this is deprecated, for more "
"flexible post processing or error checking use a ctypes data type as "
":attr:`restype` and assign a callable to the :attr:`errcheck` attribute."
msgstr "ctypes 유형이 아닌 호출 가능한 파이썬 객체를 할당 할 수 있습니다.이 경우 함수는 C :c:type:`int`\\를 반환한다고 가정하고이 호출 가능 객체는이 정수로 호출되어 이후 처리 또는 오류 검사를 허용합니다. 더 유연한 사후 처리 또는 오류 검사를 위해 ctypes 데이터 유형을 :attr:`restype`\\로 사용하고 호출 가능 객체를 :attr:`errcheck` 속성에 할당하려면이 메소드를 사용하지 마십시오."

#: ../Doc/library/ctypes.rst:1538
#, fuzzy
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can"
" only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr "ctypes 형식의 튜플을 할당하여 함수가 수락하는 인수 형식을 지정합니다. ``stdcall`` 호출 규칙을 사용하는 함수는이 튜플의 길이와 같은 수의 인수로만 호출 할 수 있습니다. C 호출 규칙을 사용하는 함수는 추가로 지정되지 않은 인수도 허용합니다."

#: ../Doc/library/ctypes.rst:1544
#, fuzzy
msgid ""
"When a foreign function is called, each actual argument is passed to the "
":meth:`from_param` class method of the items in the :attr:`argtypes` "
"tuple, this method allows adapting the actual argument to an object that "
"the foreign function accepts.  For example, a :class:`c_char_p` item in "
"the :attr:`argtypes` tuple will convert a string passed as argument into "
"a bytes object using ctypes conversion rules."
msgstr "외부 함수가 호출 될 때 각 실제 인수는 :attr:`argtypes` 튜플의 항목에 대한 :meth:`from_param` 클래스 메서드에 전달됩니다.이 메서드를 사용하면 외부 함수가 받아들이는 객체에 실제 인수를 적용 할 수 있습니다. 예를 들어, :attr:`argtypes` 튜플의 :class:`c_char_p` 항목은 ctypes 변환 규칙을 사용하여 인수로 전달 된 문자열을 바이트 객체로 변환합니다."

#: ../Doc/library/ctypes.rst:1551
#, fuzzy
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes "
"types, but each item must have a :meth:`from_param` method which returns "
"a value usable as argument (integer, string, ctypes instance).  This "
"allows defining adapters that can adapt custom objects as function "
"parameters."
msgstr "새로운 기능 : 이제 ctypes 유형이 아닌 argtypes에 항목을 넣을 수 있지만 각 항목에는 인수로 사용할 수있는 값 (integer, string, ctypes 인스턴스)을 반환하는 :meth:`from_param` 메서드가 있어야합니다. 이를 통해 사용자 정의 객체를 함수 매개 변수로 적용 할 수있는 어댑터를 정의 할 수 있습니다."

#: ../Doc/library/ctypes.rst:1558
#, fuzzy
msgid ""
"Assign a Python function or another callable to this attribute. The "
"callable will be called with three or more arguments:"
msgstr "이 속성에 파이썬 함수 또는 다른 호출 가능 함수를 할당하십시오. 3 개 이상의 인수로 호출 가능 객체가 호출됩니다.:"

#: ../Doc/library/ctypes.rst:1565
#, fuzzy
msgid ""
"*result* is what the foreign function returns, as specified by the "
":attr:`restype` attribute."
msgstr "*result*\\는 :attr:`restype` 속성에 지정된대로 외부 함수가 반환하는 것입니다."

#: ../Doc/library/ctypes.rst:1568
#, fuzzy
msgid ""
"*func* is the foreign function object itself, this allows reusing the "
"same callable object to check or post process the results of several "
"functions."
msgstr "*func*\\는 외부 함수 객체 자체이며, 동일한 호출 객체를 재사용하여 여러 함수의 결과를 확인하거나 처리 할 수 있습니다."

#: ../Doc/library/ctypes.rst:1572
#, fuzzy
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the"
" function call, this allows specializing the behavior on the arguments "
"used."
msgstr "*arguments*\\는 원래 함수 호출에 전달 된 매개 변수를 포함하는 튜플이므로 사용 된 인수에 대한 동작을 특수화 할 수 있습니다."

#: ../Doc/library/ctypes.rst:1576
#, fuzzy
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an "
"exception if the foreign function call failed."
msgstr "이 함수가 반환하는 객체는 외부 함수 호출에서 반환되지만 외부 값 호출이 실패하면 결과 값을 확인하고 예외를 발생시킬 수도 있습니다."

#: ../Doc/library/ctypes.rst:1583
#, fuzzy
msgid ""
"This exception is raised when a foreign function call cannot convert one "
"of the passed arguments."
msgstr "이 예외는 외부 함수 호출이 전달 된 인수 중 하나를 변환 할 수 없을 때 발생합니다."

#: ../Doc/library/ctypes.rst:1590
#, fuzzy
msgid "Function prototypes"
msgstr "함수 프로토 타입"

#: ../Doc/library/ctypes.rst:1592
#, fuzzy
msgid ""
"Foreign functions can also be created by instantiating function "
"prototypes. Function prototypes are similar to function prototypes in C; "
"they describe a function (return type, argument types, calling "
"convention) without defining an implementation.  The factory functions "
"must be called with the desired result type and the argument types of the"
" function, and can be used as decorator factories, and as such, be "
"applied to functions through the ``@wrapper`` syntax. See :ref:`ctypes-"
"callback-functions` for examples."
msgstr "함수 프로토 타입을 인스턴스화하여 외부 함수를 만들 수도 있습니다. 함수 프로토 타입은 C의 함수 프로토 타입과 유사합니다. 구현을 정의하지 않고 함수 (반환 유형, 인수 유형, 호출 규칙)를 설명합니다. 팩토리 함수는 원하는 결과 유형과 함수의 인수 유형으로 호출되어야하며 데코레이터 팩토리로 사용할 수 있으며 ``@wrapper`` 구문을 통해 함수에 적용될 수 있습니다. 예제는 :ref:`ctypes-callback-functions`\\를 참조하십시오."

#: ../Doc/library/ctypes.rst:1603
#, fuzzy
msgid ""
"The returned function prototype creates functions that use the standard C"
" calling convention.  The function will release the GIL during the call."
"  If *use_errno* is set to true, the ctypes private copy of the system "
":data:`errno` variable is exchanged with the real :data:`errno` value "
"before and after the call; *use_last_error* does the same for the Windows"
" error code."
msgstr "반환 된 함수 프로토 타입은 표준 C 호출 규칙을 사용하는 함수를 만듭니다. 이 기능은 통화 중에 GIL을 해제합니다. *use_errno*\\를 true로 설정하면 시스템 :data:`errno` 변수의 ctypes 개인 복사본이 호출 전후의 실제 :data:`errno` 값과 교환됩니다. *use_last_error*\\는 윈도우 오류 코드와 동일합니다."

#: ../Doc/library/ctypes.rst:1613
#, fuzzy
msgid ""
"Windows only: The returned function prototype creates functions that use "
"the ``stdcall`` calling convention, except on Windows CE where "
":func:`WINFUNCTYPE` is the same as :func:`CFUNCTYPE`.  The function will "
"release the GIL during the call.  *use_errno* and *use_last_error* have "
"the same meaning as above."
msgstr "윈도우 전용 : 반환 된 함수 프로토 타입은 ``stdcall`` 호출 규칙을 사용하는 함수를 만듭니다 (:func:`WINFUNCTYPE`\\는 :func:`CFUNCTYPE`\\와 동일한 윈도우 CE 제외). 이 기능은 통화 중에 GIL을 해제합니다. *use_errno* 및 *use_last_error*\\는 상기와 동일한 의미를 갖는다."

#: ../Doc/library/ctypes.rst:1622
#, fuzzy
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the "
"call."
msgstr "반환 된 함수 프로토 타입은 파이썬 호출 규칙을 사용하는 함수를 만듭니다. 이 기능은 통화 도중 GIL을 해제합니다. *not*"

#: ../Doc/library/ctypes.rst:1625
#, fuzzy
msgid ""
"Function prototypes created by these factory functions can be "
"instantiated in different ways, depending on the type and number of the "
"parameters in the call:"
msgstr "이러한 팩토리 함수로 작성된 함수 프로토 타입은 호출의 매개 변수 유형 및 수에 따라 다른 방법으로 인스턴스화 할 수 있습니다.:"

#: ../Doc/library/ctypes.rst:1633
#, fuzzy
msgid ""
"Returns a foreign function at the specified address which must be an "
"integer."
msgstr "지정된 주소에서 정수 여야하는 외부 함수를 반환합니다."

#: ../Doc/library/ctypes.rst:1640
#, fuzzy
msgid ""
"Create a C callable function (a callback function) from a Python "
"*callable*."
msgstr "파이썬 *callable*\\에서 C 호출 가능 함수 (콜백 함수)를 생성하십시오."

#: ../Doc/library/ctypes.rst:1647
#, fuzzy
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must"
" be a 2-tuple ``(name_or_ordinal, library)``. The first item is the name "
"of the exported function as string, or the ordinal of the exported "
"function as small integer.  The second item is the shared library "
"instance."
msgstr "공유 라이브러리가 익스포트 한 외부 함수를 리턴합니다. *func_spec*\\는 2- 튜플 ``(name_or_ordinal, library)`` 여야합니다. 첫 번째 항목은 내 보낸 함수의 이름을 문자열로, 내 보낸 함수의 서수를 작은 정수로 사용합니다. 두 번째 항목은 공유 라이브러리 인스턴스입니다."

#: ../Doc/library/ctypes.rst:1657
#, fuzzy
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is "
"the index into the virtual function table, a small non-negative integer. "
"*name* is name of the COM method. *iid* is an optional pointer to the "
"interface identifier which is used in extended error reporting."
msgstr "COM 메서드를 호출 할 외부 함수를 반환합니다. *vtbl_index*\\는 가상 함수 테이블에 대한 인덱스이며 작은 음이 아닌 정수입니다. *name*\\는 COM 메소드의 이름입니다. *iid*\\는 확장 오류보고에 사용되는 인터페이스 ID에 대한 선택적 포인터입니다."

#: ../Doc/library/ctypes.rst:1662
#, fuzzy
msgid ""
"COM methods use a special calling convention: They require a pointer to "
"the COM interface as first argument, in addition to those parameters that"
" are specified in the :attr:`argtypes` tuple."
msgstr "COM 메서드는 특별한 호출 규칙을 사용합니다. :attr:`argtypes` 튜플에 지정된 매개 변수 외에 첫 번째 인수로 COM 인터페이스에 대한 포인터가 필요합니다."

#: ../Doc/library/ctypes.rst:1666
#, fuzzy
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers "
"with much more functionality than the features described above."
msgstr "선택적 *paramflags* 매개 변수는 위에 설명 된 기능보다 훨씬 많은 기능으로 외부 함수 랩퍼를 작성합니다."

#: ../Doc/library/ctypes.rst:1669
#, fuzzy
msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr "*paramflags*\\는 :attr:`argtypes`\\와 같은 길이의 튜플이어야합니다."

#: ../Doc/library/ctypes.rst:1671
#, fuzzy
msgid ""
"Each item in this tuple contains further information about a parameter, "
"it must be a tuple containing one, two, or three items."
msgstr "이 튜플의 각 항목에는 매개 변수에 대한 추가 정보가 들어 있으며 한 개, 두 개 또는 세 개의 항목이 들어있는 튜플이어야합니다."

#: ../Doc/library/ctypes.rst:1674
#, fuzzy
msgid ""
"The first item is an integer containing a combination of direction flags "
"for the parameter:"
msgstr "첫 번째 항목은 매개 변수의 방향 플래그 조합을 포함하는 정수입니다.:"

#: ../Doc/library/ctypes.rst:1678
#, fuzzy
msgid "1"
msgstr "1"

#: ../Doc/library/ctypes.rst:1678
#, fuzzy
msgid "Specifies an input parameter to the function."
msgstr "함수에 대한 입력 매개 변수를 지정합니다."

#: ../Doc/library/ctypes.rst:1681
#, fuzzy
msgid "2"
msgstr "2"

#: ../Doc/library/ctypes.rst:1681
#, fuzzy
msgid "Output parameter.  The foreign function fills in a value."
msgstr "출력 매개 변수. 외국 함수는 값을 채 웁니다."

#: ../Doc/library/ctypes.rst:1684
#, fuzzy
msgid "4"
msgstr "4"

#: ../Doc/library/ctypes.rst:1684
#, fuzzy
msgid "Input parameter which defaults to the integer zero."
msgstr "디폴트로 정수 0이되는 입력 매개 변수."

#: ../Doc/library/ctypes.rst:1686
#, fuzzy
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr "선택 사항 인 두 번째 항목은 문자열의 매개 변수 이름입니다. 이것이 지정되면 명명 된 매개 변수로 외부 함수를 호출 할 수 있습니다."

#: ../Doc/library/ctypes.rst:1689
#, fuzzy
msgid "The optional third item is the default value for this parameter."
msgstr "선택적 세 번째 항목은이 매개 변수의 기본값입니다."

#: ../Doc/library/ctypes.rst:1691
#, fuzzy
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxW`` "
"function so that it supports default parameters and named arguments. The "
"C declaration from the windows header file is this::"
msgstr "이 예제는 기본 매개 변수와 명명 된 인수를 지원하도록 윈도우 ``MessageBoxW`` 함수를 래핑하는 방법을 보여줍니다. 윈도우 헤더 파일의 C 선언은 다음과 같습니다.::"

#: ../Doc/library/ctypes.rst:1702 ../Doc/library/ctypes.rst:1725
#, fuzzy
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "다음은 :mod:`ctypes`\\로 래핑하는 방법입니다 ::"

#: ../Doc/library/ctypes.rst:1710
#, fuzzy
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr "이제 ``MessageBox`` 외부 함수를 다음과 같이 호출 할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:1716
#, fuzzy
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window"
" by copying them into ``RECT`` structure that the caller has to supply.  "
"Here is the C declaration::"
msgstr "두 번째 예제는 출력 매개 변수를 보여줍니다. win32 ``GetWindowRect`` 함수는 호출자가 제공해야하는 ``RECT`` 구조로 복사하여 지정된 창의 크기를 검색합니다. 다음은 C 선언입니다.::"

#: ../Doc/library/ctypes.rst:1734
#, fuzzy
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the "
"output parameter values when there are more than one, so the "
"GetWindowRect function now returns a RECT instance, when called."
msgstr "출력 매개 변수가있는 함수는 출력 매개 변수 값이 하나 인 경우 자동으로 출력 매개 변수 값을 반환하고 출력 매개 변수 값이 둘 이상인 경우에는 출력 매개 변수 값을 포함하는 튜플을 반환하므로 GetWindowRect 함수는 호출 될 때 RECT 인스턴스를 반환합니다."

#: ../Doc/library/ctypes.rst:1739
#, fuzzy
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to "
"do further output processing and error checking.  The win32 "
"``GetWindowRect`` api function returns a ``BOOL`` to signal success or "
"failure, so this function could do the error checking, and raises an "
"exception when the api call failed::"
msgstr "출력 매개 변수는 :attr:`errcheck` 프로토콜과 결합하여 더 많은 출력 처리 및 오류 검사를 수행 할 수 있습니다. win32 ``GetWindowRect`` api 함수는 성공 또는 실패를 알리기 위해 ``BOOL``\\를 반환하므로이 함수는 오류 검사를 수행하고 API 호출이 실패했을 때 예외를 발생시킵니다.::"

#: ../Doc/library/ctypes.rst:1752
#, fuzzy
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the "
"function and return them instead, the normal processing will no longer "
"take place::"
msgstr ":attr:`errcheck` 함수가 인수 튜플을 반환하면이 인수는 변경되지 않고 수신되고 :mod:`ctypes`\\는 출력 매개 변수에서 수행하는 일반 처리를 계속합니다. ``RECT`` 인스턴스 대신 창 좌표의 튜플을 반환하려면 함수의 필드를 검색하여 반환하면 정상 처리가 더 이상 수행되지 않습니다.::"

#: ../Doc/library/ctypes.rst:1771
#, fuzzy
msgid "Utility functions"
msgstr "유틸리티 함수"

#: ../Doc/library/ctypes.rst:1775
#, fuzzy
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr "메모리 버퍼의 주소를 정수로 리턴합니다. *obj*\\는 ctypes 유형의 인스턴스 여야합니다."

#: ../Doc/library/ctypes.rst:1781
#, fuzzy
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must "
"be a ctypes type or instance."
msgstr "ctypes 형식의 정렬 요구 사항을 반환합니다. *obj_or_type*\\는 ctypes 유형 또는 인스턴스 여야합니다."

#: ../Doc/library/ctypes.rst:1787
#, fuzzy
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will"
" be added to the internal pointer value."
msgstr "*obj*\\에 대한 경량 포인터를 리턴합니다.이 포인터는 ctypes 유형의 인스턴스 여야합니다. *offset*\\의 기본값은 0이며, 내부 포인터 값에 더해질 정수 여야합니다."

#: ../Doc/library/ctypes.rst:1791
#, fuzzy
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)``\\는이 C 코드에 해당합니다.::"

#: ../Doc/library/ctypes.rst:1795
#, fuzzy
msgid ""
"The returned object can only be used as a foreign function call "
"parameter. It behaves similar to ``pointer(obj)``, but the construction "
"is a lot faster."
msgstr "반환 된 객체는 외부 함수 호출 매개 변수로만 사용할 수 있습니다. ``pointer(obj)``\\와 비슷하게 동작하지만 구성이 훨씬 빠릅니다."

#: ../Doc/library/ctypes.rst:1801
#, fuzzy
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  "
"*type* must be a pointer type, and *obj* must be an object that can be "
"interpreted as a pointer."
msgstr "이 함수는 C의 형변환 연산자와 유사합니다. *obj*\\와 동일한 메모리 블록을 가리키는 *type*\\의 새 인스턴스를 반환합니다. *type*\\는 포인터 유형이어야하며 *obj*\\는 포인터로 해석 될 수있는 객체 여야합니다."

#: ../Doc/library/ctypes.rst:1809
#, fuzzy
msgid ""
"This function creates a mutable character buffer. The returned object is "
"a ctypes array of :class:`c_char`."
msgstr "이 함수는 변경 가능한 문자 버퍼를 만듭니다. 반환 된 객체는 :class:`c_char`\\의 ctypes 배열입니다."

#: ../Doc/library/ctypes.rst:1812
#, fuzzy
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, "
"or a bytes object which will be used to initialize the array items."
msgstr "*init_or_size*\\는 배열의 크기를 지정하는 정수 여야하거나 배열 항목을 초기화하는 데 사용될 바이트 객체 여야합니다."

#: ../Doc/library/ctypes.rst:1815
#, fuzzy
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a "
"NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the bytes "
"should not be used."
msgstr "바이트 객체가 첫 번째 인수로 지정된 경우 버퍼의 길이가 한 항목보다 커져서 배열의 마지막 요소가 NUL 종료 문자가됩니다. 바이트의 길이를 사용하지 않을 경우 배열의 크기를 지정할 수있는 두 번째 인수로 정수를 전달할 수 있습니다."

#: ../Doc/library/ctypes.rst:1824
#, fuzzy
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr "이 함수는 변경할 수있는 유니 코드 문자 버퍼를 만듭니다. 반환 된 객체는 :class:`c_wchar`\\의 ctypes 배열입니다."

#: ../Doc/library/ctypes.rst:1827
#, fuzzy
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, "
"or a string which will be used to initialize the array items."
msgstr "*init_or_size*\\는 배열의 크기를 지정하는 정수이거나 배열 항목을 초기화하는 데 사용되는 문자열이어야합니다."

#: ../Doc/library/ctypes.rst:1830
#, fuzzy
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the "
"array is a NUL termination character. An integer can be passed as second "
"argument which allows specifying the size of the array if the length of "
"the string should not be used."
msgstr "문자열이 첫 번째 인수로 지정된 경우 버퍼의 길이는 문자열의 길이보다 하나 크게 만들어 어레이의 마지막 요소가 NUL 종료 문자가되도록합니다. 문자열의 길이를 사용하지 않을 경우 배열의 크기를 지정할 수있는 두 번째 인수로 정수를 전달할 수 있습니다."

#: ../Doc/library/ctypes.rst:1840
#, fuzzy
msgid ""
"Windows only: This function is a hook which allows implementing in-"
"process COM servers with ctypes.  It is called from the DllCanUnloadNow "
"function that the _ctypes extension dll exports."
msgstr "윈도우 전용 :이 함수는 ctypes가있는 in-process COM 서버를 구현할 수있는 후크입니다. _ctypes 확장 dll이 내보내는 DllCanUnloadNow 함수에서 호출됩니다."

#: ../Doc/library/ctypes.rst:1847
#, fuzzy
msgid ""
"Windows only: This function is a hook which allows implementing in-"
"process COM servers with ctypes.  It is called from the DllGetClassObject"
" function that the ``_ctypes`` extension dll exports."
msgstr "윈도우 전용 :이 함수는 ctypes가있는 in-process COM 서버를 구현할 수있는 후크입니다. ``_ctypes`` 확장 dll이 내보내는 DllGetClassObject 함수에서 호출됩니다."

#: ../Doc/library/ctypes.rst:1855
#, fuzzy
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or "
"version number (this is the form used for the posix linker option "
":option:`!-l`).  If no library can be found, returns ``None``."
msgstr "라이브러리를 찾고 경로명을 반환하십시오. *name*\\는 ``lib``, ``.so``, ``.dylib`` 또는 버전 번호와 같은 접미사가없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 :option:`!-l`\\에 사용되는 양식입니다). 라이브러리를 찾을 수 없으면 ``None``\\를 리턴합니다."

#: ../Doc/library/ctypes.rst:1866
#, fuzzy
msgid ""
"Windows only: return the filename of the VC runtime library used by "
"Python, and by the extension modules.  If the name of the library cannot "
"be determined, ``None`` is returned."
msgstr "윈도우 전용 : 파이썬과 확장 모듈이 사용하는 VC 런타임 라이브러리의 파일 이름을 반환합니다. 라이브러리의 이름을 판별 할 수 없으면 ``None``\\가 리턴됩니다."

#: ../Doc/library/ctypes.rst:1870
#, fuzzy
msgid ""
"If you need to free memory, for example, allocated by an extension module"
" with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr "예를 들어, ``free(void *)``\\에 대한 호출로 확장 모듈에 의해 할당 된 메모리를 비워야하는 경우 메모리를 할당 한 동일한 라이브러리에서 함수를 사용하는 것이 중요합니다."

#: ../Doc/library/ctypes.rst:1877
#, fuzzy
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If"
" no error code is specified, the last error code is used by calling the "
"Windows api function GetLastError."
msgstr "윈도우 만 해당 : 오류 코드 *code*\\에 대한 텍스트 설명을 반환합니다. 오류 코드를 지정하지 않으면 윈도우 API 함수 GetLastError를 호출하여 마지막 오류 코드가 사용됩니다."

#: ../Doc/library/ctypes.rst:1884
#, fuzzy
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows `GetLastError()` function "
"directly, it does not return the ctypes-private copy of the error code."
msgstr "윈도우 전용 : 호출 스레드에서 윈도우가 설정 한 마지막 오류 코드를 반환합니다. 이 함수는 윈도우 `GetLastError()` 함수를 직접 호출합니다. 오류 코드의 ctypes-private 복사본을 반환하지 않습니다."

#: ../Doc/library/ctypes.rst:1890
#, fuzzy
msgid ""
"Returns the current value of the ctypes-private copy of the system "
":data:`errno` variable in the calling thread."
msgstr "호출하는 스레드에서 시스템 :data:`errno` 변수의 ctypes-private 복사본의 현재 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1895
#, fuzzy
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the"
" system :data:`LastError` variable in the calling thread."
msgstr "윈도우 전용 : 호출중인 스레드에서 시스템 :data:`LastError` 변수의 ctypes- 개인 복사본의 현재 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1900
#, fuzzy
msgid ""
"Same as the standard C memmove library function: copies *count* bytes "
"from *src* to *dst*. *dst* and *src* must be integers or ctypes instances"
" that can be converted to pointers."
msgstr "표준 C memmove 라이브러리 함수와 동일 : *count* 바이트를 *src*\\에서 *dst*\\로 복사합니다. *dst* 및 *src*\\는 포인터로 변환 할 수있는 정수 또는 ctypes 인스턴스 여야합니다."

#: ../Doc/library/ctypes.rst:1907
#, fuzzy
msgid ""
"Same as the standard C memset library function: fills the memory block at"
" address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr "표준 C memset 라이브러리 함수와 동일 : 주소 *dst*\\의 메모리 블록을 값 *c*\\의 *count* 바이트로 채 웁니다. *dst*\\는 주소 또는 ctypes 인스턴스를 지정하는 정수 여야합니다."

#: ../Doc/library/ctypes.rst:1914
#, fuzzy
msgid ""
"This factory function creates and returns a new ctypes pointer type. "
"Pointer types are cached and reused internally, so calling this function "
"repeatedly is cheap. *type* must be a ctypes type."
msgstr "이 팩토리 함수는 새로운 ctypes 포인터 유형을 생성하고 반환합니다. 포인터 유형은 캐시되고 내부적으로 재사용되므로이 함수를 반복적으로 호출하는 것은 저렴합니다. *type*\\는 ctypes 유형이어야합니다."

#: ../Doc/library/ctypes.rst:1921
#, fuzzy
msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr "이 함수는 *obj*\\를 가리키는 새 포인터 인스턴스를 만듭니다. 리턴 된 오브젝트는 유형 ``POINTER(type(obj))``\\입니다."

#: ../Doc/library/ctypes.rst:1924
#, fuzzy
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign "
"function call, you should use ``byref(obj)`` which is much faster."
msgstr "참고 : 객체에 대한 포인터를 외부 함수 호출로 전달하려는 경우 훨씬 빠른 ``byref(obj)``\\를 사용해야합니다."

#: ../Doc/library/ctypes.rst:1930
#, fuzzy
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be "
"an instance of a ctypes type.  It is not possible to make the buffer "
"smaller than the native size of the objects type, as given by "
"``sizeof(type(obj))``, but it is possible to enlarge the buffer."
msgstr "이 함수는 *obj*\\의 내부 메모리 버퍼의 크기를 조정합니다.이 버퍼는 ctypes 유형의 인스턴스 여야합니다. ``sizeof(type(obj))``\\에 지정된 것처럼 객체 유형의 기본 크기보다 버퍼를 작게 만들 수는 없지만 버퍼를 확대 할 수 있습니다."

#: ../Doc/library/ctypes.rst:1938
#, fuzzy
msgid ""
"Set the current value of the ctypes-private copy of the system "
":data:`errno` variable in the calling thread to *value* and return the "
"previous value."
msgstr "ctypes의 현재 값 - 호출하는 스레드의 시스템 :data:`errno` 변수의 개인 복사본을 *value*\\로 설정하고 이전 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1945
#, fuzzy
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr "윈도우 전용 : 호출중인 스레드의 시스템 :data:`LastError` 변수의 ctypes- 개인 복사본의 현재 값을 *value*\\로 설정하고 이전 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1953
#, fuzzy
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. "
"Does the same as the C ``sizeof`` operator."
msgstr "ctypes 유형 또는 인스턴스 메모리 버퍼의 크기 (바이트)를 반환합니다. C ``sizeof`` 연산자와 동일합니다."

#: ../Doc/library/ctypes.rst:1959
#, fuzzy
msgid ""
"This function returns the C string starting at memory address *address* "
"as a bytes object. If size is specified, it is used as size, otherwise "
"the string is assumed to be zero-terminated."
msgstr "이 함수는 메모리 주소 *address*\\에서 시작하는 C 문자열을 바이트 객체로 반환합니다. 크기가 지정되면 크기로 사용되며, 그렇지 않으면 문자열은 0으로 종료됩니다."

#: ../Doc/library/ctypes.rst:1966
#, fuzzy
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. "
"It creates an instance of OSError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not"
" specified, :func:`FormatError` is called to get a textual description of"
" the error."
msgstr "윈도우 만 해당 :이 함수는 아마도 ctypes에서 최악의 이름입니다. OSError의 인스턴스를 만듭니다. *code*\\를 지정하지 않으면 오류 코드를 판별하기 위해 ``GetLastError``\\가 호출됩니다. *descr*\\가 지정되지 않으면 오류에 대한 텍스트 설명을 얻기 위해 :func:`FormatError`\\가 호출됩니다."

#: ../Doc/library/ctypes.rst:1972
#, fuzzy
msgid "An instance of :exc:`WindowsError` used to be created."
msgstr ":exc:`WindowsError`\\의 인스턴스를 생성하는 데 사용되었습니다."

#: ../Doc/library/ctypes.rst:1978
#, fuzzy
msgid ""
"This function returns the wide character string starting at memory "
"address *address* as a string.  If *size* is specified, it is used as the"
" number of characters of the string, otherwise the string is assumed to "
"be zero-terminated."
msgstr "이 함수는 메모리 주소 *address*\\에서 시작하는 넓은 문자열을 문자열로 반환합니다. *size*\\가 지정되면 문자열의 문자 수로 사용되며, 그렇지 않으면 문자열은 0으로 종료됩니다."

#: ../Doc/library/ctypes.rst:1987
#, fuzzy
msgid "Data types"
msgstr "데이터 유형"

#: ../Doc/library/ctypes.rst:1992
#, fuzzy
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that"
" hold C compatible data; the address of the memory block is returned by "
"the :func:`addressof` helper function. Another instance variable is "
"exposed as :attr:`_objects`; this contains other Python objects that need"
" to be kept alive in case the memory block contains pointers."
msgstr "이 비공개 클래스는 모든 ctypes 데이터 유형의 공통 기본 클래스입니다. 무엇보다도 모든 ctypes 유형 인스턴스에는 C 호환 데이터를 보유하는 메모리 블록이 포함됩니다. 메모리 블록의 주소는 :func:`addressof` 도우미 함수에 의해 리턴됩니다. 다른 인스턴스 변수는 :attr:`_objects`\\로 표시됩니다. 여기에는 메모리 블록에 포인터가 포함되어있는 경우에 활성 상태로 유지되어야하는 다른 파이썬 객체가 포함되어 있습니다."

#: ../Doc/library/ctypes.rst:1999
#, fuzzy
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr "ctypes 데이터 유형의 일반적인 메소드는 모두 클래스 메소드입니다 (정확히 말하면 :term:`metaclass`\\의 메소드입니다).:"

#: ../Doc/library/ctypes.rst:2004
#, fuzzy
msgid ""
"This method returns a ctypes instance that shares the buffer of the "
"*source* object.  The *source* object must support the writeable buffer "
"interface.  The optional *offset* parameter specifies an offset into the "
"source buffer in bytes; the default is zero.  If the source buffer is not"
" large enough a :exc:`ValueError` is raised."
msgstr "이 메서드는 *source* 객체의 버퍼를 공유하는 ctypes 인스턴스를 반환합니다. *source* 객체는 쓰기 가능한 버퍼 인터페이스를 지원해야합니다. 선택적 *offset* 매개 변수는 원본 버퍼의 오프셋을 바이트 단위로 지정합니다. 기본값은 0입니다. 소스 버퍼가 충분히 크지 않으면 :exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/ctypes.rst:2013
#, fuzzy
msgid ""
"This method creates a ctypes instance, copying the buffer from the "
"*source* object buffer which must be readable.  The optional *offset* "
"parameter specifies an offset into the source buffer in bytes; the "
"default is zero.  If the source buffer is not large enough a "
":exc:`ValueError` is raised."
msgstr "이 메서드는 읽을 수 있어야하는 *source* 객체 버퍼에서 버퍼를 복사하여 ctypes 인스턴스를 만듭니다. 선택적 *offset* 매개 변수는 원본 버퍼의 오프셋을 바이트 단위로 지정합니다. 기본값은 0입니다. 소스 버퍼가 충분히 크지 않으면 :exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/ctypes.rst:2021
#, fuzzy
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr "이 메소드는 정수 여야하는 *address*\\로 지정된 메모리를 사용하여 ctypes 유형 인스턴스를 리턴합니다."

#: ../Doc/library/ctypes.rst:2026
#, fuzzy
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that "
"can be used as a function call parameter."
msgstr "이 방법은 *obj*\\를 ctypes 유형에 맞게 조정합니다. 타입이 외부 함수의 :attr:`argtypes` 튜플에 존재할 때 외부 함수 호출에 사용 된 실제 객체로 호출됩니다. 함수 호출 매개 변수로 사용할 수있는 객체를 반환해야합니다."

#: ../Doc/library/ctypes.rst:2031
#, fuzzy
msgid ""
"All ctypes data types have a default implementation of this classmethod "
"that normally returns *obj* if that is an instance of the type.  Some "
"types accept other objects as well."
msgstr "모든 ctypes 데이터 형식은이 클래스 형식의 기본 구현을 가지며,이 형식이 해당 형식의 인스턴스 인 경우 일반적으로 *obj*\\를 반환합니다. 일부 유형은 다른 오브젝트도 허용합니다."

#: ../Doc/library/ctypes.rst:2037
#, fuzzy
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr "이 메소드는 공유 라이브러리가 내 보낸 ctypes 유형 인스턴스를 리턴합니다. *name*\\는 데이터를 내보내는 심볼의 이름이고, *library*\\는로드 된 공유 라이브러리입니다."

#: ../Doc/library/ctypes.rst:2041
#, fuzzy
msgid "Common instance variables of ctypes data types:"
msgstr "ctypes 데이터 유형의 일반적인 인스턴스 변수 :"

#: ../Doc/library/ctypes.rst:2045
#, fuzzy
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain,"
" instead they share part of the memory block of a base object.  The "
":attr:`_b_base_` read-only member is the root ctypes object that owns the"
" memory block."
msgstr "때때로 ctypes 데이터 인스턴스는 포함하는 메모리 블록을 소유하지 않고 기본 객체의 메모리 블록의 일부를 공유합니다. :attr:`_b_base_` 읽기 전용 멤버는 메모리 블록을 소유 한 루트 ctypes 객체입니다."

#: ../Doc/library/ctypes.rst:2052
#, fuzzy
msgid ""
"This read-only variable is true when the ctypes data instance has "
"allocated the memory block itself, false otherwise."
msgstr "이 읽기 전용 변수는 ctypes 데이터 인스턴스가 메모리 블록 자체를 할당 한 경우에는 true이고, 그렇지 않으면 false입니다."

#: ../Doc/library/ctypes.rst:2057
#, fuzzy
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept "
"valid.  This object is only exposed for debugging; never modify the "
"contents of this dictionary."
msgstr "이 멤버는 ``None`` 또는 메모리 블록 내용이 유효하도록 유지되어야하는 파이썬 객체를 포함하는 사전입니다. 이 객체는 디버깅을 위해서만 노출됩니다. 이 사전의 내용을 수정하지 마십시오."

#: ../Doc/library/ctypes.rst:2070
#, fuzzy
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of "
"the fundamental ctypes data types.  :class:`_SimpleCData` is a subclass "
"of :class:`_CData`, so it inherits their methods and attributes. ctypes "
"data types that are not and do not contain pointers can now be pickled."
msgstr "이 비공개 클래스는 모든 기본 ctypes 데이터 유형의 기본 클래스입니다. 여기에는 기본 ctypes 데이터 유형의 공통 속성이 들어 있으므로 여기에서 언급합니다. :class:`_SimpleCData`\\는 :class:`_CData`\\의 서브 클래스이므로 메소드와 속성을 상속받습니다. 포인터가 없거나 포인터를 포함하지 않는 ctypes 데이터 유형을 이제 절이 수 있습니다."

#: ../Doc/library/ctypes.rst:2076
#, fuzzy
msgid "Instances have a single attribute:"
msgstr "인스턴스에는 단일 속성이 있습니다.:"

#: ../Doc/library/ctypes.rst:2080
#, fuzzy
msgid ""
"This attribute contains the actual value of the instance. For integer and"
" pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a "
"Python bytes object or string."
msgstr "이 속성은 인스턴스의 실제 값을 포함합니다. 정수형과 포인터 형의 경우에는 정수형이며, 문자형의 경우에는 단일 문자 바이트 객체 또는 문자열이고, 문자 포인터 유형의 경우에는 파이썬 바이트 객체 또는 문자열입니다."

#: ../Doc/library/ctypes.rst:2085
#, fuzzy
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually"
" a new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr "ctypes 인스턴스에서 ``value`` 특성을 검색하면 대개 새 객체가 반환됩니다. :mod:`ctypes`\\는 *not*\\가 원래의 객체 반환을 구현하지만 항상 새로운 객체가 생성됩니다. 다른 모든 ctypes 객체 인스턴스에서도 마찬가지입니다."

#: ../Doc/library/ctypes.rst:2091
#, fuzzy
msgid ""
"Fundamental data types, when returned as foreign function call results, "
"or, for example, by retrieving structure field members or array items, "
"are transparently converted to native Python types.  In other words, if a"
" foreign function has a :attr:`restype` of :class:`c_char_p`, you will "
"always receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr "기본 데이터 유형은 외부 함수 호출 결과로 반환되거나 구조 필드 멤버 또는 배열 항목을 검색하는 것과 같이 원시 파이썬 유형으로 투명하게 변환됩니다. 즉, 외부 함수가 :class:`c_char_p`\\의 :attr:`restype`\\를 가지면 항상 파이썬 바이트 객체를 받고 *not*\\는 :class:`c_char_p` 인스턴스를받습니다."

#: ../Doc/library/ctypes.rst:2099
#, fuzzy
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, "
"if a foreign functions :attr:`restype` is a subclass of "
":class:`c_void_p`, you will receive an instance of this subclass from the"
" function call. Of course, you can get the value of the pointer by "
"accessing the ``value`` attribute."
msgstr "기본적인 데이터 타입의 서브 클래스는 *not*\\가이 동작을 상속받습니다. 따라서 외부 함수 :attr:`restype`\\가 :class:`c_void_p`\\의 서브 클래스 인 경우 함수 호출에서이 서브 클래스의 인스턴스를 수신하게됩니다. 물론 ``value`` 속성에 액세스하여 포인터 값을 가져올 수 있습니다."

#: ../Doc/library/ctypes.rst:2104
#, fuzzy
msgid "These are the fundamental ctypes data types:"
msgstr "다음은 기본적인 ctypes 데이터 유형입니다.:"

#: ../Doc/library/ctypes.rst:2108
#, fuzzy
msgid ""
"Represents the C :c:type:`signed char` datatype, and interprets the value"
" as small integer.  The constructor accepts an optional integer "
"initializer; no overflow checking is done."
msgstr "C :c:type:`signed char` 데이터 유형을 나타내고 값을 작은 정수로 해석합니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2115
#, fuzzy
msgid ""
"Represents the C :c:type:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr "C :c:type:`char` 데이터 유형을 나타내며이 값을 단일 문자로 해석합니다. 생성자는 선택적 문자열 초기화자를 허용하며 문자열의 길이는 정확히 한 문자 여야합니다."

#: ../Doc/library/ctypes.rst:2122
#, fuzzy
msgid ""
"Represents the C :c:type:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point "
"to binary data, ``POINTER(c_char)`` must be used.  The constructor "
"accepts an integer address, or a bytes object."
msgstr "0으로 끝나는 문자열을 가리킬 때 C :c:type:`char *` 데이터 유형을 나타냅니다. 이진 데이터를 가리킬 수도있는 일반 문자 포인터의 경우 ``POINTER(c_char)``\\를 사용해야합니다. 생성자는 정수 주소 또는 바이트 객체를 허용합니다."

#: ../Doc/library/ctypes.rst:2130
#, fuzzy
msgid ""
"Represents the C :c:type:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`double` 데이터 유형을 나타냅니다. 생성자는 선택적 float 초기화자를 허용합니다."

#: ../Doc/library/ctypes.rst:2136
#, fuzzy
msgid ""
"Represents the C :c:type:`long double` datatype.  The constructor accepts"
" an optional float initializer.  On platforms where ``sizeof(long double)"
" == sizeof(double)`` it is an alias to :class:`c_double`."
msgstr "C :c:type:`long double` 데이터 유형을 나타냅니다. 생성자는 선택적 float 초기화자를 허용합니다. 플랫폼에서 ``sizeof(long double) == sizeof(double)``\\는 :class:`c_double`\\의 별명입니다."

#: ../Doc/library/ctypes.rst:2142
#, fuzzy
msgid ""
"Represents the C :c:type:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`float` 데이터 유형을 나타냅니다. 생성자는 선택적 float 초기화자를 허용합니다."

#: ../Doc/library/ctypes.rst:2148
#, fuzzy
msgid ""
"Represents the C :c:type:`signed int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On "
"platforms where ``sizeof(int) == sizeof(long)`` it is an alias to "
":class:`c_long`."
msgstr "C :c:type:`signed int` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다. 플랫폼에서 ``sizeof(int) == sizeof(long)``\\는 :class:`c_long`\\의 별명입니다."

#: ../Doc/library/ctypes.rst:2155
#, fuzzy
msgid ""
"Represents the C 8-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_byte`."
msgstr "C 8 비트 :c:type:`signed int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_byte`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2161
#, fuzzy
msgid ""
"Represents the C 16-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr "C 16 비트 :c:type:`signed int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_short`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2167
#, fuzzy
msgid ""
"Represents the C 32-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr "C 32 비트 :c:type:`signed int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_int`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2173
#, fuzzy
msgid ""
"Represents the C 64-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr "C 64 비트 :c:type:`signed int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_longlong`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2179
#, fuzzy
msgid ""
"Represents the C :c:type:`signed long` datatype.  The constructor accepts"
" an optional integer initializer; no overflow checking is done."
msgstr "C :c:type:`signed long` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2185
#, fuzzy
msgid ""
"Represents the C :c:type:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr "C :c:type:`signed long long` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2191
#, fuzzy
msgid ""
"Represents the C :c:type:`signed short` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr "C :c:type:`signed short` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2197
#, fuzzy
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "C :c:type:`size_t` 데이터 유형을 나타냅니다."

#: ../Doc/library/ctypes.rst:2202
#, fuzzy
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "C :c:type:`ssize_t` 데이터 유형을 나타냅니다."

#: ../Doc/library/ctypes.rst:2209
#, fuzzy
msgid ""
"Represents the C :c:type:`unsigned char` datatype, it interprets the "
"value as small integer.  The constructor accepts an optional integer "
"initializer; no overflow checking is done."
msgstr "C :c:type:`unsigned char` 데이터 유형을 나타내며 값을 작은 정수로 해석합니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2216
#, fuzzy
msgid ""
"Represents the C :c:type:`unsigned int` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done.  "
"On platforms where ``sizeof(int) == sizeof(long)`` it is an alias for "
":class:`c_ulong`."
msgstr "C :c:type:`unsigned int` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다. 플랫폼에서 ``sizeof(int) == sizeof(long)``\\는 :class:`c_ulong`\\의 별명입니다."

#: ../Doc/library/ctypes.rst:2223
#, fuzzy
msgid ""
"Represents the C 8-bit :c:type:`unsigned int` datatype.  Usually an alias"
" for :class:`c_ubyte`."
msgstr "C 8 비트 :c:type:`unsigned int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_ubyte`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2229
#, fuzzy
msgid ""
"Represents the C 16-bit :c:type:`unsigned int` datatype.  Usually an "
"alias for :class:`c_ushort`."
msgstr "C 16 비트 :c:type:`unsigned int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_ushort`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2235
#, fuzzy
msgid ""
"Represents the C 32-bit :c:type:`unsigned int` datatype.  Usually an "
"alias for :class:`c_uint`."
msgstr "C 32 비트 :c:type:`unsigned int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_uint`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2241
#, fuzzy
msgid ""
"Represents the C 64-bit :c:type:`unsigned int` datatype.  Usually an "
"alias for :class:`c_ulonglong`."
msgstr "C 64 비트 :c:type:`unsigned int` 데이터 유형을 나타냅니다. 일반적으로 :class:`c_ulonglong`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2247
#, fuzzy
msgid ""
"Represents the C :c:type:`unsigned long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr "C :c:type:`unsigned long` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2253
#, fuzzy
msgid ""
"Represents the C :c:type:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr "C :c:type:`unsigned long long` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2259
#, fuzzy
msgid ""
"Represents the C :c:type:`unsigned short` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr "C :c:type:`unsigned short` 데이터 유형을 나타냅니다. 생성자는 선택적 정수 초기화기를 허용합니다. 오버플로 검사가 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2265
#, fuzzy
msgid ""
"Represents the C :c:type:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr "C :c:type:`void *` 유형을 나타냅니다. 값은 정수로 표시됩니다. 생성자는 선택적 정수 초기화기를 허용합니다."

#: ../Doc/library/ctypes.rst:2271
#, fuzzy
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as "
"a single character unicode string.  The constructor accepts an optional "
"string initializer, the length of the string must be exactly one "
"character."
msgstr "C :c:type:`wchar_t` 데이터 유형을 나타내며 값을 단일 문자 유니 코드 문자열로 해석합니다. 생성자는 선택적 문자열 초기화자를 허용하며 문자열의 길이는 정확히 한 문자 여야합니다."

#: ../Doc/library/ctypes.rst:2278
#, fuzzy
msgid ""
"Represents the C :c:type:`wchar_t *` datatype, which must be a pointer to"
" a zero-terminated wide character string.  The constructor accepts an "
"integer address, or a string."
msgstr "0으로 끝나는 와이드 문자 문자열에 대한 포인터 여야하는 C :c:type:`wchar_t *` 데이터 유형을 나타냅니다. 생성자는 정수 주소 또는 문자열을 허용합니다."

#: ../Doc/library/ctypes.rst:2285
#, fuzzy
msgid ""
"Represent the C :c:type:`bool` datatype (more accurately, :c:type:`_Bool`"
" from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr "C :c:type:`bool` 데이터 유형을 나타냅니다 (보다 정확하게는 C99의 :c:type:`_Bool`). 이 값은 ``True`` 또는 ``False`` 일 수 있으며 생성자는 진리 값이있는 객체를 허용합니다."

#: ../Doc/library/ctypes.rst:2292
#, fuzzy
msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains "
"success or error information for a function or method call."
msgstr "윈도우 전용 : 함수 또는 메서드 호출에 대한 성공 또는 오류 정보가 들어있는 :c:type:`HRESULT` 값을 나타냅니다."

#: ../Doc/library/ctypes.rst:2298
#, fuzzy
msgid ""
"Represents the C :c:type:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:type:`PyObject *` pointer."
msgstr "C :c:type:`PyObject *` 데이터 유형을 나타냅니다. 인수없이 이것을 호출하면 ``NULL`` :c:type:`PyObject *` 포인터가 생성됩니다."

#: ../Doc/library/ctypes.rst:2301
#, fuzzy
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows "
"specific data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or "
":c:type:`DWORD`.  Some useful structures like :c:type:`MSG` or "
":c:type:`RECT` are also defined."
msgstr ":mod:`ctypes.wintypes` 모듈은 다른 윈도우 특정 데이터 유형 (예 : :c:type:`HWND`, :c:type:`WPARAM` 또는 :c:type:`DWORD`)을 제공합니다. :c:type:`MSG` 또는 :c:type:`RECT`\\와 같은 유용한 구조도 정의됩니다."

#: ../Doc/library/ctypes.rst:2309
#, fuzzy
msgid "Structured data types"
msgstr "구조화 된 데이터 형식"

#: ../Doc/library/ctypes.rst:2314
#, fuzzy
msgid "Abstract base class for unions in native byte order."
msgstr "네이티브의 byte 순서에 의한 공용 체제의 추상 기본 클래스입니다."

#: ../Doc/library/ctypes.rst:2319
#, fuzzy
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "*big endian* 바이트 순서로 된 구조체의 추상 기본 클래스입니다."

#: ../Doc/library/ctypes.rst:2324
#, fuzzy
msgid "Abstract base class for structures in *little endian* byte order."
msgstr "*little endian* 바이트 순서로 된 구조체의 추상 기본 클래스입니다."

#: ../Doc/library/ctypes.rst:2326
#, fuzzy
msgid ""
"Structures with non-native byte order cannot contain pointer type fields,"
" or any other data types containing pointer type fields."
msgstr "넌 - 네이티브 바이트 순서를 갖는 구조는 포인터 타입 필드 나 포인터 타입 필드를 포함하는 다른 데이터 타입을 포함 할 수 없다."

#: ../Doc/library/ctypes.rst:2332
#, fuzzy
msgid "Abstract base class for structures in *native* byte order."
msgstr "*native* 바이트 순서로 된 구조체의 추상 기본 클래스입니다."

#: ../Doc/library/ctypes.rst:2334
#, fuzzy
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. "
":mod:`ctypes` will create :term:`descriptor`\\s which allow reading and "
"writing the fields by direct attribute accesses.  These are the"
msgstr "구체적인 구조 및 공용체 유형은이 유형 중 하나를 서브 클래스 화하고 적어도 :attr:`_fields_` 클래스 변수를 정의하여 작성해야합니다. :mod:`ctypes`\\는 직접 속성 액세스로 필드를 읽고 쓸 수있는 :term:`descriptor` \\ s를 만듭니다. 이들은"

#: ../Doc/library/ctypes.rst:2342
#, fuzzy
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or "
"3-tuples.  The first item is the name of the field, the second item "
"specifies the type of the field; it can be any ctypes data type."
msgstr "구조체 필드를 정의하는 시퀀스입니다. 항목은 2-tuples 또는 3-tuples이어야합니다. 첫 번째 항목은 필드의 이름이고, 두 번째 항목은 필드의 유형을 지정합니다. 모든 ctypes 데이터 유형이 될 수 있습니다."

#: ../Doc/library/ctypes.rst:2346
#, fuzzy
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be"
" given.  It must be a small positive integer defining the bit width of "
"the field."
msgstr ":class:`c_int`\\와 같은 정수 유형 필드의 경우 세 번째 선택적 항목을 지정할 수 있습니다. 필드의 비트 폭을 정의하는 작은 양의 정수 여야합니다."

#: ../Doc/library/ctypes.rst:2350
#, fuzzy
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr "필드 이름은 하나의 구조체 또는 공용체 내에서 고유해야합니다. 이 옵션을 선택하지 않으면 이름을 반복 할 때 하나의 필드 만 액세스 할 수 있습니다."

#: ../Doc/library/ctypes.rst:2353
#, fuzzy
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating"
" data types that directly or indirectly reference themselves::"
msgstr ":attr:`_fields_` 클래스 변수 *after*\\를 구조 하위 클래스를 정의하는 class 문으로 정의 할 수 있습니다. 직접 또는 간접적으로 자신을 참조하는 데이터 유형을 만들 수 있습니다.::"

#: ../Doc/library/ctypes.rst:2363
#, fuzzy
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on "
"it, and so on).  Later assignments to the :attr:`_fields_` class variable"
" will raise an AttributeError."
msgstr "그러나 유형이 처음 사용되기 전에 :attr:`_fields_` 클래스 변수를 정의해야합니다 (인스턴스가 작성되고 :func:`sizeof`\\가 호출 됨 등). 나중에 :attr:`_fields_` 클래스 변수에 대입하면 AttributeError가 발생합니다."

#: ../Doc/library/ctypes.rst:2368
#, fuzzy
msgid ""
"It is possible to defined sub-subclasses of structure types, they inherit"
" the fields of the base class plus the :attr:`_fields_` defined in the "
"sub-subclass, if any."
msgstr "구조체 유형의 하위 서브 클래스를 정의 할 수 있습니다. 서브 클래스가있는 경우 기본 클래스와 하위 서브 클래스에 정의 된 :attr:`_fields_`\\의 필드를 상속합니다."

#: ../Doc/library/ctypes.rst:2375
#, fuzzy
msgid ""
"An optional small integer that allows overriding the alignment of "
"structure fields in the instance.  :attr:`_pack_` must already be defined"
" when :attr:`_fields_` is assigned, otherwise it will have no effect."
msgstr "인스턴스의 구조 필드 정렬을 재정의 할 수있는 선택적 작은 정수입니다. :attr:`_fields_`\\가 지정되면 :attr:`_pack_`\\가 이미 정의되어 있어야합니다. 그렇지 않으면 아무 효과가 없습니다."

#: ../Doc/library/ctypes.rst:2382
#, fuzzy
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. "
":attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr "익명 (익명) 필드의 이름을 나열하는 선택적 시퀀스입니다. :attr:`_fields_`\\가 지정되면 :attr:`_anonymous_`\\가 이미 정의되어 있어야합니다. 그렇지 않으면 아무 효과가 없습니다."

#: ../Doc/library/ctypes.rst:2386
#, fuzzy
msgid ""
"The fields listed in this variable must be structure or union type "
"fields. :mod:`ctypes` will create descriptors in the structure type that "
"allows accessing the nested fields directly, without the need to create "
"the structure or union field."
msgstr "이 변수에 나열된 필드는 구조체 또는 공용체 유형 필드 여야합니다. :mod:`ctypes`\\는 구조체 또는 공용체 필드를 만들 필요없이 중첩 된 필드에 직접 액세스 할 수있는 구조체 형식의 설명자를 만듭니다."

#: ../Doc/library/ctypes.rst:2391
#, fuzzy
msgid "Here is an example type (Windows)::"
msgstr "다음은 예제 유형입니다 (윈도우) ::"

#: ../Doc/library/ctypes.rst:2404
#, fuzzy
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field "
"is defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` "
"are equivalent, but the former is faster since it does not need to create"
" a temporary union instance::"
msgstr "``TYPEDESC`` 구조체는 COM 데이터 형식을 설명하고 ``vt`` 필드는 UNION 필드 중 어느 것이 유효한지 지정합니다. ``u`` 필드가 익명 필드로 정의되었으므로 이제 TYPEDESC 인스턴스에서 멤버에 직접 액세스 할 수 있습니다. ``td.lptdesc``\\와 ``td.u.lptdesc``\\는 동등하지만 이전 버전에서는 임시 인스턴스를 만들 필요가 없기 때문에 빠릅니다.::"

#: ../Doc/library/ctypes.rst:2416
#, fuzzy
msgid ""
"It is possible to defined sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate "
":attr:`_fields_` variable, the fields specified in this are appended to "
"the fields of the base class."
msgstr "구조의 하위 하위 클래스를 정의 할 수 있으며 기본 클래스의 필드를 상속합니다. 서브 클래스 정의에 별도의 :attr:`_fields_` 변수가 있으면이 변수에 지정된 필드가 기본 클래스의 필드에 추가됩니다."

#: ../Doc/library/ctypes.rst:2421
#, fuzzy
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in "
"the same order as they are appear in :attr:`_fields_`.  Keyword arguments"
" in the constructor are interpreted as attribute assignments, so they "
"will initialize :attr:`_fields_` with the same name, or create new "
"attributes for names not present in :attr:`_fields_`."
msgstr "구조체와 공용체 생성자는 위치 인수와 키워드 인수를 모두 허용합니다. 위치 인수는 :attr:`_fields_`\\에 나타나는 순서대로 멤버 필드를 초기화하는 데 사용됩니다. 생성자의 키워드 인수는 특성 할당으로 해석되므로 :attr:`_fields_`\\를 동일한 이름으로 초기화하거나 :attr:`_fields_`\\에없는 이름에 대한 새 특성을 만듭니다."

#: ../Doc/library/ctypes.rst:2432
#, fuzzy
msgid "Arrays and pointers"
msgstr "배열과 포인터"

#: ../Doc/library/ctypes.rst:2436
#, fuzzy
msgid "Abstract base class for arrays."
msgstr "배열의 추상 기본 클래스입니다."

#: ../Doc/library/ctypes.rst:2438
#, fuzzy
msgid ""
"The recommended way to create concrete array types is by multiplying any "
":mod:`ctypes` data type with a positive integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard "
"subscript and slice accesses; for slice reads, the resulting object is "
"*not* itself an :class:`Array`."
msgstr "구체적인 배열 유형을 만드는 데 권장되는 방법은 모든 :mod:`ctypes` 데이터 형식에 양의 정수를 곱하는 것입니다. 또는이 유형을 서브 클래스 화하고 :attr:`_length_` 및 :attr:`_type_` 클래스 변수를 정의 할 수 있습니다. 배열 요소는 표준 첨자 및 슬라이스 액세스를 사용하여 읽고 쓸 수 있습니다. 슬라이스 읽기의 경우 결과 객체는 *not* 자체와 :class:`Array`\\입니다."

#: ../Doc/library/ctypes.rst:2448
#, fuzzy
msgid ""
"A positive integer specifying the number of elements in the array. Out-"
"of-range subscripts result in an :exc:`IndexError`. Will be returned by "
":func:`len`."
msgstr "배열의 요소 수를 지정하는 양의 정수입니다. 범위를 벗어나는 하위 첨자는 :exc:`IndexError`\\가됩니다. :func:`len`\\에 의해 반환됩니다."

#: ../Doc/library/ctypes.rst:2455
#, fuzzy
msgid "Specifies the type of each element in the array."
msgstr "배열의 각 요소 유형을 지정합니다."

#: ../Doc/library/ctypes.rst:2458
#, fuzzy
msgid ""
"Array subclass constructors accept positional arguments, used to "
"initialize the elements in order."
msgstr "배열 서브 클래스 생성자는 요소를 순서대로 초기화하는 데 사용되는 위치 인수를 허용합니다."

#: ../Doc/library/ctypes.rst:2464
#, fuzzy
msgid "Private, abstract base class for pointers."
msgstr "포인터를위한 private, abstract 기본 클래스."

#: ../Doc/library/ctypes.rst:2466
#, fuzzy
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the "
"type that will be pointed to; this is done automatically by "
":func:`pointer`."
msgstr "구체적인 포인터 타입은 가리킬 타입을 가진 :func:`POINTER`\\를 호출함으로써 생성된다; 이것은 :func:`pointer`\\에 의해 자동으로 수행됩니다."

#: ../Doc/library/ctypes.rst:2470
#, fuzzy
msgid ""
"If a pointer points to an array, its elements can be read and written "
"using standard subscript and slice accesses.  Pointer objects have no "
"size, so :func:`len` will raise :exc:`TypeError`.  Negative subscripts "
"will read from the memory *before* the pointer (as in C), and out-of-"
"range subscripts will probably crash with an access violation (if you're "
"lucky)."
msgstr "포인터가 배열을 가리키면 해당 요소는 표준 첨자 및 슬라이스 액세스를 사용하여 읽고 쓸 수 있습니다. 포인터 객체는 크기가 없기 때문에 :func:`len`\\는 :exc:`TypeError`\\를 발생시킵니다. 음수 첨자는 메모리에서 *before* 포인터 (C에서와 같이)를 읽을 것이고, 범위를 벗어나는 하위 스크립트는 액세스 위반으로 인해 충돌 할 것입니다 (운이 좋다면)."

#: ../Doc/library/ctypes.rst:2480
#, fuzzy
msgid "Specifies the type pointed to."
msgstr "지정된 유형을 지정합니다."

#: ../Doc/library/ctypes.rst:2484
#, fuzzy
msgid ""
"Returns the object to which to pointer points.  Assigning to this "
"attribute changes the pointer to point to the assigned object."
msgstr "포인터가 가리키는 객체를 반환합니다. 이 속성에 지정하면 할당 된 객체를 가리 키도록 포인터가 변경됩니다."
