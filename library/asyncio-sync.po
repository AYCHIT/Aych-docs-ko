# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/asyncio-sync.rst:7
msgid "Synchronization Primitives"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:9
msgid ""
"asyncio synchronization primitives are designed to be similar to those of"
" the :mod:`threading` module with two important caveats:"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:12
msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used"
" for OS thread synchronization (use :mod:`threading` for that);"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:16
msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations"
" with timeouts."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:20
msgid "asyncio has the following basic sychronization primitives:"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:22
msgid ":class:`Lock`"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:23
msgid ":class:`Event`"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:24
msgid ":class:`Condition`"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:25
msgid ":class:`Semaphore`"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:26
msgid ":class:`BoundedSemaphore`"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:33
msgid "Lock"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:37
msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:39
msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:42
msgid "The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:51 ../Doc/library/asyncio-sync.rst:178
#: ../Doc/library/asyncio-sync.rst:274
msgid "which is equivalent to::"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:64
msgid "Acquire the lock."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:66
msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:71
msgid "Release the lock."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:73
msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:75
msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:79
msgid "Return ``True`` if the lock is *locked*."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:83
msgid "Event"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:87
msgid "An event object.  Not thread-safe."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:89
msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:92
msgid ""
"An Event object manages an internal flag that can be set to *true* with "
"the :meth:`set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`wait` method blocks until the flag is set to *true*."
"  The flag is set to *false* initially."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:99
msgid "Example::"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:124
msgid "Wait until the event is set."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:126
msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`set`."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:131
msgid "Set the event."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:133
msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:138
msgid "Clear (unset) the event."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:140
msgid ""
"Tasks awaiting on :meth:`wait` will now block until the :meth:`set` "
"method is called again."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:145
msgid "Return ``True`` if the event is set."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:149
msgid "Condition"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:153
msgid "A Condition object.  Not thread-safe."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:155
msgid ""
"An asyncio condition primitive can be used by a task to wait for some "
"event to happen and then get exclusive access to a shared resource."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:159
msgid ""
"In essence, a Condition object combines the functionality of an "
":class:`Event` and a :class:`Lock`.  It is possible to have multiple "
"Condition objects share one Lock, which allows coordinating exclusive "
"access to a shared resource between different tasks interested in "
"particular states of that shared resource."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:165
msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``."
"  In the latter case a new Lock object is created automatically."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:169
msgid ""
"The preferred way to use a Condition is an :keyword:`async with` "
"statement::"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:191
msgid "Acquire the underlying lock."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:193
msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:198
msgid ""
"Wake up at most *n* tasks (1 by default) waiting on this condition.  The "
"method is no-op if no tasks are waiting."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:201 ../Doc/library/asyncio-sync.rst:216
msgid ""
"The lock must be acquired before this method is called and released "
"shortly after.  If called with an *unlocked* lock a :exc:`RuntimeError` "
"error is raised."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:207
msgid "Return ``True`` if the underlying lock is acquired."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:211
msgid "Wake up all tasks waiting on this condition."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:213
msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:222
msgid "Release the underlying lock."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:224
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:229
msgid "Wait until notified."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:231
msgid ""
"If the calling task has not acquired the lock when this method is called,"
" a :exc:`RuntimeError` is raised."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:234
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, "
"the Condition re-acquires its lock and this method returns ``True``."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:241
msgid "Wait until a predicate becomes *true*."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:243
msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The final value is the return value."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:249
msgid "Semaphore"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:253
msgid "A Semaphore object.  Not thread-safe."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:255
msgid ""
"A semaphore manages an internal counter which is decremented by each "
":meth:`acquire` call and incremented by each :meth:`release` call. The "
"counter can never go below zero; when :meth:`acquire` finds that it is "
"zero, it blocks, waiting until some task calls :meth:`release`."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:261
msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a "
":exc:`ValueError` is raised."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:265
msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` "
"statement::"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:287
msgid "Acquire a semaphore."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:289
msgid ""
"If the internal counter is greater than zero, decrement it by one and "
"return ``True`` immediately.  If it is zero, wait until a :meth:`release`"
" is called and return ``True``."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:295
msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:299
msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake "
"up a task waiting to acquire the semaphore."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:302
msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:307
msgid "BoundedSemaphore"
msgstr ""

#: ../Doc/library/asyncio-sync.rst:311
msgid "A bounded semaphore object.  Not thread-safe."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:313
msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a "
":exc:`ValueError` in :meth:`~Semaphore.release` if it increases the "
"internal counter above the initial *value*."
msgstr ""

#: ../Doc/library/asyncio-sync.rst:323
msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or "
":keyword:`with` statement (``with await lock``, ``with (yield from "
"lock)``) is deprecated.  Use ``async with lock`` instead."
msgstr ""

#~ msgid "Locks"
#~ msgstr ""

#~ msgid ""
#~ "It is created in the unlocked "
#~ "state.  It has two basic methods, "
#~ ":meth:`acquire` and :meth:`release`.  When the"
#~ " state is unlocked, acquire() changes "
#~ "the state to locked and returns "
#~ "immediately.  When the state is locked,"
#~ " acquire() blocks until a call to "
#~ "release() in another coroutine changes "
#~ "it to unlocked, then the acquire() "
#~ "call resets it to locked and "
#~ "returns.  The release() method should "
#~ "only be called in the locked "
#~ "state; it changes the state to "
#~ "unlocked and returns immediately.  If an"
#~ " attempt is made to release an "
#~ "unlocked lock, a :exc:`RuntimeError` will "
#~ "be raised."
#~ msgstr ""

#~ msgid ""
#~ ":meth:`acquire` is a coroutine and "
#~ "should be called with ``yield from``."
#~ msgstr ""

#~ msgid ""
#~ "Locks also support the context "
#~ "management protocol.  ``(yield from lock)``"
#~ " should be used as the context "
#~ "manager expression."
#~ msgstr ""

#~ msgid "Usage::"
#~ msgstr ""

#~ msgid "Context manager usage::"
#~ msgstr ""

#~ msgid "Lock objects can be tested for locking state::"
#~ msgstr ""

#~ msgid "Semaphores"
#~ msgstr ""

#~ msgid "Semaphores also support the context management protocol."
#~ msgstr ""

#~ msgid "Synchronization primitives"
#~ msgstr ""

#~ msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
#~ msgstr ""

#~ msgid "Locks:"
#~ msgstr ""

#~ msgid "Semaphores:"
#~ msgstr ""

#~ msgid ""
#~ "asyncio lock API was designed to "
#~ "be close to classes of the "
#~ ":mod:`threading` module (:class:`~threading.Lock`, "
#~ ":class:`~threading.Event`, :class:`~threading.Condition`, "
#~ ":class:`~threading.Semaphore`, "
#~ ":class:`~threading.BoundedSemaphore`), but it has"
#~ " no *timeout* parameter. The "
#~ ":func:`asyncio.wait_for` function can be used"
#~ " to cancel a task after a "
#~ "timeout."
#~ msgstr ""

#~ msgid "Primitive lock objects."
#~ msgstr ""

#~ msgid ""
#~ "A primitive lock is a synchronization"
#~ " primitive that is not owned by "
#~ "a particular coroutine when locked.  A"
#~ " primitive lock is in one of "
#~ "two states, 'locked' or 'unlocked'."
#~ msgstr ""

#~ msgid ""
#~ "The lock is created in the "
#~ "unlocked state. It has two basic "
#~ "methods, :meth:`acquire` and :meth:`release`. "
#~ "When the state is unlocked, acquire()"
#~ " changes the state to locked and "
#~ "returns immediately.  When the state is"
#~ " locked, acquire() blocks until a "
#~ "call to release() in another coroutine"
#~ " changes it to unlocked, then the "
#~ "acquire() call resets it to locked "
#~ "and returns.  The release() method "
#~ "should only be called in the "
#~ "locked state; it changes the state "
#~ "to unlocked and returns immediately.  If"
#~ " an attempt is made to release "
#~ "an unlocked lock, a :exc:`RuntimeError` "
#~ "will be raised."
#~ msgstr ""

#~ msgid ""
#~ "When more than one coroutine is "
#~ "blocked in acquire() waiting for the "
#~ "state to turn to unlocked, only "
#~ "one coroutine proceeds when a release()"
#~ " call resets the state to unlocked;"
#~ " first coroutine which is blocked in"
#~ " acquire() is being processed."
#~ msgstr ""

#~ msgid ":meth:`acquire` is a coroutine and should be called with ``await``."
#~ msgstr ""

#~ msgid ""
#~ "Locks support the :ref:`context management "
#~ "protocol <async-with-locks>`."
#~ msgstr ""

#~ msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
#~ msgstr ""

#~ msgid "Return ``True`` if the lock is acquired."
#~ msgstr ""

#~ msgid "Acquire a lock."
#~ msgstr ""

#~ msgid ""
#~ "This method blocks until the lock "
#~ "is unlocked, then sets it to "
#~ "locked and returns ``True``."
#~ msgstr ""

#~ msgid "This method is a :ref:`coroutine <coroutine>`."
#~ msgstr ""

#~ msgid "Release a lock."
#~ msgstr ""

#~ msgid ""
#~ "When the lock is locked, reset it"
#~ " to unlocked, and return.  If any "
#~ "other coroutines are blocked waiting for"
#~ " the lock to become unlocked, allow"
#~ " exactly one of them to proceed."
#~ msgstr ""

#~ msgid "There is no return value."
#~ msgstr ""

#~ msgid ""
#~ "An Event implementation, asynchronous "
#~ "equivalent to :class:`threading.Event`."
#~ msgstr ""

#~ msgid ""
#~ "Class implementing event objects. An "
#~ "event manages a flag that can be"
#~ " set to true with the :meth:`set` "
#~ "method and reset to false with the"
#~ " :meth:`clear` method.  The :meth:`wait` "
#~ "method blocks until the flag is "
#~ "true. The flag is initially false."
#~ msgstr ""

#~ msgid ""
#~ "Reset the internal flag to false. "
#~ "Subsequently, coroutines calling :meth:`wait` "
#~ "will block until :meth:`set` is called"
#~ " to set the internal flag to "
#~ "true again."
#~ msgstr ""

#~ msgid "Return ``True`` if and only if the internal flag is true."
#~ msgstr ""

#~ msgid ""
#~ "Set the internal flag to true. All"
#~ " coroutines waiting for it to become"
#~ " true are awakened. Coroutine that "
#~ "call :meth:`wait` once the flag is "
#~ "true will not block at all."
#~ msgstr ""

#~ msgid "Block until the internal flag is true."
#~ msgstr ""

#~ msgid ""
#~ "If the internal flag is true on"
#~ " entry, return ``True`` immediately. "
#~ "Otherwise, block until another coroutine "
#~ "calls :meth:`set` to set the flag "
#~ "to true, then return ``True``."
#~ msgstr ""

#~ msgid ""
#~ "A Condition implementation, asynchronous "
#~ "equivalent to :class:`threading.Condition`."
#~ msgstr ""

#~ msgid ""
#~ "This class implements condition variable "
#~ "objects. A condition variable allows one"
#~ " or more coroutines to wait until "
#~ "they are notified by another coroutine."
#~ msgstr ""

#~ msgid ""
#~ "If the *lock* argument is given "
#~ "and not ``None``, it must be a "
#~ ":class:`Lock` object, and it is used "
#~ "as the underlying lock.  Otherwise, a"
#~ " new :class:`Lock` object is created "
#~ "and used as the underlying lock."
#~ msgstr ""

#~ msgid ""
#~ "Conditions support the :ref:`context "
#~ "management protocol <async-with-locks>`."
#~ msgstr ""

#~ msgid ""
#~ "By default, wake up one coroutine "
#~ "waiting on this condition, if any. "
#~ "If the calling coroutine has not "
#~ "acquired the lock when this method "
#~ "is called, a :exc:`RuntimeError` is "
#~ "raised."
#~ msgstr ""

#~ msgid ""
#~ "This method wakes up at most *n*"
#~ " of the coroutines waiting for the"
#~ " condition variable; it is a no-"
#~ "op if no coroutines are waiting."
#~ msgstr ""

#~ msgid ""
#~ "An awakened coroutine does not actually"
#~ " return from its :meth:`wait` call "
#~ "until it can reacquire the lock. "
#~ "Since :meth:`notify` does not release "
#~ "the lock, its caller should."
#~ msgstr ""

#~ msgid ""
#~ "Wake up all coroutines waiting on "
#~ "this condition. This method acts like"
#~ " :meth:`notify`, but wakes up all "
#~ "waiting coroutines instead of one. If"
#~ " the calling coroutine has not "
#~ "acquired the lock when this method "
#~ "is called, a :exc:`RuntimeError` is "
#~ "raised."
#~ msgstr ""

#~ msgid ""
#~ "When the lock is locked, reset it"
#~ " to unlocked, and return. If any "
#~ "other coroutines are blocked waiting for"
#~ " the lock to become unlocked, allow"
#~ " exactly one of them to proceed."
#~ msgstr ""

#~ msgid ""
#~ "If the calling coroutine has not "
#~ "acquired the lock when this method "
#~ "is called, a :exc:`RuntimeError` is "
#~ "raised."
#~ msgstr ""

#~ msgid ""
#~ "This method releases the underlying "
#~ "lock, and then blocks until it is"
#~ " awakened by a :meth:`notify` or "
#~ ":meth:`notify_all` call for the same "
#~ "condition variable in another coroutine.  "
#~ "Once awakened, it re-acquires the "
#~ "lock and returns ``True``."
#~ msgstr ""

#~ msgid "Wait until a predicate becomes true."
#~ msgstr ""

#~ msgid ""
#~ "The predicate should be a callable "
#~ "which result will be interpreted as "
#~ "a boolean value. The final predicate "
#~ "value is the return value."
#~ msgstr ""

#~ msgid "A Semaphore implementation."
#~ msgstr ""

#~ msgid ""
#~ "A semaphore manages an internal counter"
#~ " which is decremented by each "
#~ ":meth:`acquire` call and incremented by "
#~ "each :meth:`release` call. The counter "
#~ "can never go below zero; when "
#~ ":meth:`acquire` finds that it is zero,"
#~ " it blocks, waiting until some other"
#~ " coroutine calls :meth:`release`."
#~ msgstr ""

#~ msgid ""
#~ "The optional argument gives the initial"
#~ " value for the internal counter; it"
#~ " defaults to ``1``. If the value "
#~ "given is less than ``0``, "
#~ ":exc:`ValueError` is raised."
#~ msgstr ""

#~ msgid ""
#~ "Semaphores support the :ref:`context "
#~ "management protocol <async-with-locks>`."
#~ msgstr ""

#~ msgid ""
#~ "If the internal counter is larger "
#~ "than zero on entry, decrement it "
#~ "by one and return ``True`` immediately."
#~ "  If it is zero on entry, "
#~ "block, waiting until some other "
#~ "coroutine has called :meth:`release` to "
#~ "make it larger than ``0``, and "
#~ "then return ``True``."
#~ msgstr ""

#~ msgid ""
#~ "Release a semaphore, incrementing the "
#~ "internal counter by one. When it "
#~ "was zero on entry and another "
#~ "coroutine is waiting for it to "
#~ "become larger than zero again, wake "
#~ "up that coroutine."
#~ msgstr ""

#~ msgid "A bounded semaphore implementation. Inherit from :class:`Semaphore`."
#~ msgstr ""

#~ msgid ""
#~ "This raises :exc:`ValueError` in "
#~ ":meth:`~Semaphore.release` if it would "
#~ "increase the value above the initial "
#~ "value."
#~ msgstr ""

#~ msgid ""
#~ "Bounded semapthores support the :ref:`context"
#~ " management protocol <async-with-locks>`."
#~ msgstr ""

#~ msgid ""
#~ "Using locks, conditions and semaphores "
#~ "in the :keyword:`async with` statement"
#~ msgstr ""

#~ msgid ""
#~ ":class:`Lock`, :class:`Condition`, :class:`Semaphore`, "
#~ "and :class:`BoundedSemaphore` objects can be"
#~ " used in :keyword:`async with` statements."
#~ msgstr ""

#~ msgid ""
#~ "The :meth:`acquire` method will be "
#~ "called when the block is entered, "
#~ "and :meth:`release` will be called when"
#~ " the block is exited.  Hence, the "
#~ "following snippet::"
#~ msgstr ""

#~ msgid "is equivalent to::"
#~ msgstr ""

#~ msgid ""
#~ "Lock acquiring using ``await lock`` or"
#~ " ``yield from lock`` and :keyword:`with`"
#~ " statement (``with await lock``, ``with "
#~ "(yield from lock)``) are deprecated."
#~ msgstr ""

