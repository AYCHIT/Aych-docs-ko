# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/asyncio-dev.rst:7
msgid "Developing with asyncio"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:9
msgid ""
"Asynchronous programming is different from classic \"sequential\" "
"programming."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:12
msgid "This page lists common mistakes and traps and explains how to avoid them."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:19
msgid "Debug Mode"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:21
msgid ""
"By default asyncio runs in production mode.  In order to ease the "
"development asyncio has a *debug mode*."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:24
msgid "There are several ways to enable asyncio debug mode:"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:26
msgid "Setting the :envvar:`PYTHONASYNCIODEBUG` environment variable to ``1``."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:28
msgid "Using the :option:`-X` ``dev`` Python command line option."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:30
msgid "Passing ``debug=True`` to :func:`asyncio.run`."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:32
msgid "Calling :meth:`loop.set_debug`."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:34
msgid "In addition to enabling the debug mode, consider also:"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:36
msgid ""
"setting the log level of the :ref:`asyncio logger <asyncio-logger>` to "
":py:data:`logging.DEBUG`, for example the following snippet of code can "
"be run at startup of the application::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:42
msgid ""
"configuring the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings.  One way of doing that is by using the :option:`-W` ``default``"
" command line option."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:47
msgid "When the debug mode is enabled:"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:49
msgid ""
"asyncio checks for :ref:`coroutines that were not awaited <asyncio-"
"coroutine-not-scheduled>` and logs them; this mitigates the \"forgotten "
"await\" pitfall."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:53
msgid ""
"Many non-treadsafe asyncio APIs (such as :meth:`loop.call_soon` and "
":meth:`loop.call_at` methods) raise an exception if they are called from "
"a wrong thread."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:57
msgid ""
"The execution time of the I/O selector is logged if it takes too long to "
"perform an I/O operation."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:60
msgid ""
"Callbacks taking longer than 100ms are logged.  The "
":attr:`loop.slow_callback_duration` attribute can be used to set the "
"minimum execution duration in seconds that is considered \"slow\"."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:68
msgid "Concurrency and Multithreading"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:70
msgid ""
"An event loop runs in a thread (typically the main thread) and executes "
"all callbacks and Tasks in its thread.  While a Task is running in the "
"event loop, no other Tasks can run in the same thread.  When a Task "
"executes an ``await`` expression, the running Task gets suspended, and "
"the event loop executes the next Task."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:76
msgid ""
"To schedule a callback from a different OS thread, the "
":meth:`loop.call_soon_threadsafe` method should be used. Example::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:81
msgid ""
"Almost all asyncio objects are not thread safe, which is typically not a "
"problem unless there is code that works with them from outside of a Task "
"or a callback.  If there's a need for such code to call a low-level "
"asyncio API, the :meth:`loop.call_soon_threadsafe` method should be used,"
" e.g.::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:89
msgid ""
"To schedule a coroutine object from a different OS thread, the "
":func:`run_coroutine_threadsafe` function should be used. It returns a "
":class:`concurrent.futures.Future` to access the result::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:102
msgid ""
"To handle signals and to execute subprocesses, the event loop must be run"
" in the main thread."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:105
msgid ""
"The :meth:`loop.run_in_executor` method can be used with a "
":class:`concurrent.futures.ThreadPoolExecutor` to execute blocking code "
"in a different OS thread without blocking the OS thread that the event "
"loop runs in."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:114
msgid "Running Blocking Code"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:116
msgid ""
"Blocking (CPU-bound) code should not be called directly.  For example, if"
" a function performs a CPU-intensive calculation for 1 second, all "
"concurrent asyncio Tasks and IO operations would be delayed by 1 second."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:121
msgid ""
"An executor can be used to run a task in a different thread or even in a "
"different process to avoid blocking block the OS thread with the event "
"loop.  See the :meth:`loop.run_in_executor` method for more details."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:130
msgid "Logging"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:132
msgid ""
"asyncio uses the :mod:`logging` module and all logging is performed via "
"the ``\"asyncio\"`` logger."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:135
msgid ""
"The default log level is :py:data:`logging.INFO`, which can be easily "
"adjusted::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:144
msgid "Detect never-awaited coroutines"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:146
msgid ""
"When a coroutine function is called, but not awaited (e.g. ``coro()`` "
"instead of ``await coro()``) or the coroutine is not scheduled with "
":meth:`asyncio.create_task`, asyncio will emit a :exc:`RuntimeWarning`::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:161 ../Doc/library/asyncio-dev.rst:206
msgid "Output::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:166 ../Doc/library/asyncio-dev.rst:222
msgid "Output in debug mode::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:179
msgid ""
"The usual fix is to either await the coroutine or call the "
":meth:`asyncio.create_task` function::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:187
msgid "Detect never-retrieved exceptions"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:189
msgid ""
"If a :meth:`Future.set_exception` is called but the Future object is "
"never awaited on, the exception would never be propagated to the user "
"code.  In this case, asyncio would emit a log message when the Future "
"object is garbage collected."
msgstr ""

#: ../Doc/library/asyncio-dev.rst:194
msgid "Example of an unhandled exception::"
msgstr ""

#: ../Doc/library/asyncio-dev.rst:217
msgid ""
":ref:`Enable the debug mode <asyncio-debug-mode>` to get the traceback "
"where the task was created::"
msgstr ""

#~ msgid ""
#~ "Python usually calls :func:`sys.displayhook` "
#~ "on unhandled exceptions. If "
#~ ":meth:`Future.set_exception` is called, but "
#~ "the exception is never consumed, "
#~ ":func:`sys.displayhook` is not called. "
#~ "Instead, :ref:`a log is emitted "
#~ "<asyncio-logger>` when the future is "
#~ "deleted by the garbage collector, with"
#~ " the traceback where the exception "
#~ "was raised."
#~ msgstr ""

#~ msgid ""
#~ "Enable the asyncio debug mode globally"
#~ " by setting the environment variable "
#~ ":envvar:`PYTHONASYNCIODEBUG` to ``1``, or by"
#~ " calling :meth:`AbstractEventLoop.set_debug`."
#~ msgstr ""

#~ msgid ""
#~ "An event loop runs in a thread "
#~ "and executes all callbacks and tasks "
#~ "in the same thread. While a task"
#~ " is running in the event loop, "
#~ "no other task is running in the"
#~ " same thread. But when the task "
#~ "uses ``yield from``, the task is "
#~ "suspended and the event loop executes"
#~ " the next task."
#~ msgstr ""

#~ msgid ""
#~ "When a coroutine function calls other"
#~ " coroutine functions and tasks, they "
#~ "should be chained explicitly with "
#~ "``yield from``. Otherwise, the execution "
#~ "is not guaranteed to be sequential."
#~ msgstr ""

#~ msgid "To fix the example, tasks must be marked with ``yield from``::"
#~ msgstr ""

#~ msgid "Develop with asyncio"
#~ msgstr ""

#~ msgid ""
#~ "Asynchronous programming is different than "
#~ "classical \"sequential\" programming. This "
#~ "page lists common traps and explains "
#~ "how to avoid them."
#~ msgstr ""

#~ msgid "Debug mode of asyncio"
#~ msgstr ""

#~ msgid ""
#~ "The implementation of :mod:`asyncio` has "
#~ "been written for performance. In order"
#~ " to ease the development of "
#~ "asynchronous code, you may wish to "
#~ "enable *debug mode*."
#~ msgstr ""

#~ msgid "To enable all debug checks for an application:"
#~ msgstr ""

#~ msgid ""
#~ "Enable the asyncio debug mode globally"
#~ " by setting the environment variable "
#~ ":envvar:`PYTHONASYNCIODEBUG` to ``1``, using "
#~ "``-X dev`` command line option (see "
#~ "the :option:`-X` option), or by calling"
#~ " :meth:`AbstractEventLoop.set_debug`."
#~ msgstr ""

#~ msgid ""
#~ "Set the log level of the "
#~ ":ref:`asyncio logger <asyncio-logger>` to "
#~ ":py:data:`logging.DEBUG`. For example, call "
#~ "``logging.basicConfig(level=logging.DEBUG)`` at startup."
#~ msgstr ""

#~ msgid ""
#~ "Configure the :mod:`warnings` module to "
#~ "display :exc:`ResourceWarning` warnings. For "
#~ "example, use the ``-Wdefault`` command "
#~ "line option of Python to display "
#~ "them."
#~ msgstr ""

#~ msgid "Examples debug checks:"
#~ msgstr ""

#~ msgid ""
#~ "Log :ref:`coroutines defined but never "
#~ "\"yielded from\" <asyncio-coroutine-not-"
#~ "scheduled>`"
#~ msgstr ""

#~ msgid ""
#~ ":meth:`~AbstractEventLoop.call_soon` and "
#~ ":meth:`~AbstractEventLoop.call_at` methods raise an"
#~ " exception if they are called from"
#~ " the wrong thread."
#~ msgstr ""

#~ msgid "Log the execution time of the selector"
#~ msgstr ""

#~ msgid ""
#~ "Log callbacks taking more than 100 "
#~ "ms to be executed. The "
#~ ":attr:`AbstractEventLoop.slow_callback_duration` attribute "
#~ "is the minimum duration in seconds "
#~ "of \"slow\" callbacks."
#~ msgstr ""

#~ msgid ""
#~ ":exc:`ResourceWarning` warnings are emitted "
#~ "when transports and event loops are "
#~ ":ref:`not closed explicitly <asyncio-close-"
#~ "transports>`."
#~ msgstr ""

#~ msgid ""
#~ "The new ``-X dev`` command line "
#~ "option can now also be used to "
#~ "enable the debug mode."
#~ msgstr ""

#~ msgid ""
#~ "The :meth:`AbstractEventLoop.set_debug` method and"
#~ " the :ref:`asyncio logger <asyncio-"
#~ "logger>`."
#~ msgstr ""

#~ msgid "Cancellation"
#~ msgstr ""

#~ msgid ""
#~ "Cancellation of tasks is not common "
#~ "in classic programming. In asynchronous "
#~ "programming, not only is it something"
#~ " common, but you have to prepare "
#~ "your code to handle it."
#~ msgstr ""

#~ msgid ""
#~ "Futures and tasks can be cancelled "
#~ "explicitly with their :meth:`Future.cancel` "
#~ "method. The :func:`wait_for` function cancels"
#~ " the waited task when the timeout "
#~ "occurs. There are many other cases "
#~ "where a task can be cancelled "
#~ "indirectly."
#~ msgstr ""

#~ msgid ""
#~ "Don't call :meth:`~Future.set_result` or "
#~ ":meth:`~Future.set_exception` method of "
#~ ":class:`Future` if the future is "
#~ "cancelled: it would fail with an "
#~ "exception. For example, write::"
#~ msgstr ""

#~ msgid ""
#~ "Don't schedule directly a call to "
#~ "the :meth:`~Future.set_result` or the "
#~ ":meth:`~Future.set_exception` method of a "
#~ "future with :meth:`AbstractEventLoop.call_soon`: the"
#~ " future can be cancelled before its"
#~ " method is called."
#~ msgstr ""

#~ msgid ""
#~ "If you wait for a future, you "
#~ "should check early if the future "
#~ "was cancelled to avoid useless "
#~ "operations. Example::"
#~ msgstr ""

#~ msgid "The :func:`shield` function can also be used to ignore cancellation."
#~ msgstr ""

#~ msgid "Concurrency and multithreading"
#~ msgstr ""

#~ msgid ""
#~ "An event loop runs in a thread "
#~ "and executes all callbacks and tasks "
#~ "in the same thread. While a task"
#~ " is running in the event loop, "
#~ "no other task is running in the"
#~ " same thread. But when the task "
#~ "uses ``await``, the task is suspended"
#~ " and the event loop executes the "
#~ "next task."
#~ msgstr ""

#~ msgid ""
#~ "To schedule a callback from a "
#~ "different thread, the "
#~ ":meth:`AbstractEventLoop.call_soon_threadsafe` method "
#~ "should be used. Example::"
#~ msgstr ""

#~ msgid ""
#~ "Most asyncio objects are not thread "
#~ "safe. You should only worry if you"
#~ " access objects outside the event "
#~ "loop. For example, to cancel a "
#~ "future, don't call directly its "
#~ ":meth:`Future.cancel` method, but::"
#~ msgstr ""

#~ msgid ""
#~ "To schedule a coroutine object from "
#~ "a different thread, the "
#~ ":func:`run_coroutine_threadsafe` function should be"
#~ " used. It returns a "
#~ ":class:`concurrent.futures.Future` to access the "
#~ "result::"
#~ msgstr ""

#~ msgid ""
#~ "The :meth:`AbstractEventLoop.run_in_executor` method "
#~ "can be used with a thread pool "
#~ "executor to execute a callback in "
#~ "different thread to not block the "
#~ "thread of the event loop."
#~ msgstr ""

#~ msgid ""
#~ "The :ref:`Synchronization primitives <asyncio-"
#~ "sync>` section describes ways to "
#~ "synchronize tasks."
#~ msgstr ""

#~ msgid ""
#~ "The :ref:`Subprocess and threads <asyncio-"
#~ "subprocess-threads>` section lists asyncio "
#~ "limitations to run subprocesses from "
#~ "different threads."
#~ msgstr ""

#~ msgid "Handle blocking functions correctly"
#~ msgstr ""

#~ msgid ""
#~ "Blocking functions should not be called"
#~ " directly. For example, if a function"
#~ " blocks for 1 second, other tasks "
#~ "are delayed by 1 second which can"
#~ " have an important impact on "
#~ "reactivity."
#~ msgstr ""

#~ msgid ""
#~ "For networking and subprocesses, the "
#~ ":mod:`asyncio` module provides high-level "
#~ "APIs like :ref:`protocols <asyncio-protocol>`."
#~ msgstr ""

#~ msgid ""
#~ "An executor can be used to run "
#~ "a task in a different thread or"
#~ " even in a different process, to "
#~ "not block the thread of the event"
#~ " loop. See the "
#~ ":meth:`AbstractEventLoop.run_in_executor` method."
#~ msgstr ""

#~ msgid ""
#~ "The :ref:`Delayed calls <asyncio-delayed-"
#~ "calls>` section details how the event"
#~ " loop handles time."
#~ msgstr ""

#~ msgid ""
#~ "The :mod:`asyncio` module logs information "
#~ "with the :mod:`logging` module in the"
#~ " logger ``'asyncio'``."
#~ msgstr ""

#~ msgid ""
#~ "The default log level for the "
#~ ":mod:`asyncio` module is :py:data:`logging.INFO`."
#~ " For those not wanting such verbosity"
#~ " from :mod:`asyncio` the log level "
#~ "can be changed.  For example, to "
#~ "change the level to "
#~ ":py:data:`logging.WARNING`:"
#~ msgstr ""

#~ msgid "Detect coroutine objects never scheduled"
#~ msgstr ""

#~ msgid ""
#~ "When a coroutine function is called "
#~ "and its result is not passed to"
#~ " :func:`ensure_future` or to the "
#~ ":meth:`AbstractEventLoop.create_task` method, the "
#~ "execution of the coroutine object will"
#~ " never be scheduled which is probably"
#~ " a bug.  :ref:`Enable the debug mode"
#~ " of asyncio <asyncio-debug-mode>` to"
#~ " :ref:`log a warning <asyncio-logger>` "
#~ "to detect it."
#~ msgstr ""

#~ msgid "Example with the bug::"
#~ msgstr ""

#~ msgid ""
#~ "The fix is to call the "
#~ ":func:`ensure_future` function or the "
#~ ":meth:`AbstractEventLoop.create_task` method with "
#~ "the coroutine object."
#~ msgstr ""

#~ msgid ":ref:`Pending task destroyed <asyncio-pending-task-destroyed>`."
#~ msgstr ""

#~ msgid "Detect exceptions never consumed"
#~ msgstr ""

#~ msgid ""
#~ "Python usually calls :func:`sys.excepthook` on"
#~ " unhandled exceptions. If "
#~ ":meth:`Future.set_exception` is called, but "
#~ "the exception is never consumed, "
#~ ":func:`sys.excepthook` is not called. Instead,"
#~ " :ref:`a log is emitted <asyncio-"
#~ "logger>` when the future is deleted "
#~ "by the garbage collector, with the "
#~ "traceback where the exception was "
#~ "raised."
#~ msgstr ""

#~ msgid "Example of unhandled exception::"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`Enable the debug mode of asyncio"
#~ " <asyncio-debug-mode>` to get the "
#~ "traceback where the task was created."
#~ " Output in debug mode::"
#~ msgstr ""

#~ msgid ""
#~ "There are different options to fix "
#~ "this issue. The first option is to"
#~ " chain the coroutine in another "
#~ "coroutine and use classic try/except::"
#~ msgstr ""

#~ msgid ""
#~ "Another option is to use the "
#~ ":meth:`AbstractEventLoop.run_until_complete` function::"
#~ msgstr ""

#~ msgid "The :meth:`Future.exception` method."
#~ msgstr ""

#~ msgid "Chain coroutines correctly"
#~ msgstr ""

#~ msgid ""
#~ "When a coroutine function calls other"
#~ " coroutine functions and tasks, they "
#~ "should be chained explicitly with "
#~ "``await``. Otherwise, the execution is "
#~ "not guaranteed to be sequential."
#~ msgstr ""

#~ msgid ""
#~ "Example with different bugs using "
#~ ":func:`asyncio.sleep` to simulate slow "
#~ "operations::"
#~ msgstr ""

#~ msgid "Expected output:"
#~ msgstr ""

#~ msgid "Actual output:"
#~ msgstr ""

#~ msgid ""
#~ "The loop stopped before the ``create()``"
#~ " finished, ``close()`` has been called "
#~ "before ``write()``, whereas coroutine "
#~ "functions were called in this order: "
#~ "``create()``, ``write()``, ``close()``."
#~ msgstr ""

#~ msgid "To fix the example, tasks must be marked with ``await``::"
#~ msgstr ""

#~ msgid "Or without ``asyncio.ensure_future()``::"
#~ msgstr ""

#~ msgid "Pending task destroyed"
#~ msgstr ""

#~ msgid ""
#~ "If a pending task is destroyed, "
#~ "the execution of its wrapped "
#~ ":ref:`coroutine <coroutine>` did not complete."
#~ " It is probably a bug and so"
#~ " a warning is logged."
#~ msgstr ""

#~ msgid "Example of log:"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`Enable the debug mode of asyncio"
#~ " <asyncio-debug-mode>` to get the "
#~ "traceback where the task was created."
#~ " Example of log in debug mode:"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`Detect coroutine objects never scheduled"
#~ " <asyncio-coroutine-not-scheduled>`."
#~ msgstr ""

#~ msgid "Close transports and event loops"
#~ msgstr ""

#~ msgid ""
#~ "When a transport is no more "
#~ "needed, call its ``close()`` method to"
#~ " release resources. Event loops must "
#~ "also be closed explicitly."
#~ msgstr ""

#~ msgid ""
#~ "If a transport or an event loop"
#~ " is not closed explicitly, a "
#~ ":exc:`ResourceWarning` warning will be emitted"
#~ " in its destructor. By default, "
#~ ":exc:`ResourceWarning` warnings are ignored. "
#~ "The :ref:`Debug mode of asyncio "
#~ "<asyncio-debug-mode>` section explains how"
#~ " to display them."
#~ msgstr ""

