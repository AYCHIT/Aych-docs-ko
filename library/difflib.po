# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/difflib.rst:2
msgid ":mod:`difflib` --- Helpers for computing deltas"
msgstr ":mod:`difflib` --- 델타 계산을 위한 도우미"

#: ../Doc/library/difflib.rst:11
msgid "**Source code:** :source:`Lib/difflib.py`"
msgstr "**소스 코드:** :source:`Lib/difflib.py`"

#: ../Doc/library/difflib.rst:20
msgid ""
"This module provides classes and functions for comparing sequences. It "
"can be used for example, for comparing files, and can produce difference "
"information in various formats, including HTML and context and unified "
"diffs. For comparing directories and files, see also, the :mod:`filecmp` "
"module."
msgstr "이 모듈은 시퀀스 비교를 위한 클래스와 함수를 제공합니다. 예를 들어 파일을 비교하는 데 사용할 수 있으며, HTML 및 문맥(context) 과 통합(unified) diff를 비롯한 다양한 형식의 차이 정보를 생성 할 수 있습니다. 디렉터리와 파일을 비교하려면, :mod:`filecmp` 모듈을 참조하십시오."

#: ../Doc/library/difflib.rst:28
#, fuzzy
msgid ""
"This is a flexible class for comparing pairs of sequences of any type, so"
" long as the sequence elements are :term:`hashable`.  The basic algorithm"
" predates, and is a little fancier than, an algorithm published in the "
"late 1980's by Ratcliff and Obershelp under the hyperbolic name \"gestalt"
" pattern matching.\"  The idea is to find the longest contiguous matching"
" subsequence that contains no \"junk\" elements; these \"junk\" elements "
"are ones that are uninteresting in some sense, such as blank lines or "
"whitespace.  (Handling junk is an extension to the Ratcliff and Obershelp"
" algorithm.) The same idea is then applied recursively to the pieces of "
"the sequences to the left and to the right of the matching subsequence.  "
"This does not yield minimal edit sequences, but does tend to yield "
"matches that \"look right\" to people."
msgstr "이 요소는 시퀀스 요소가 :term:`해시 가능 <hashable>`\\이면 모든 유형의 시퀀스 쌍을 비교할 수있는 유연한 클래스입니다. 기본 알고리즘은 1980 년대 후반에 Ratcliff와 Obershelp가 'gestalt pattern matching'이라는 과장된 이름으로 발표 한 알고리즘보다 약간 더 애호가이며, 다소 애호가가 있습니다. 아이디어는 \"정크\"요소가없는 가장 긴 연속 매칭 서브 시퀀스를 찾는 것입니다. 이러한 \"쓰레기\"요소는 빈 줄이나 공백과 같은 어떤 의미에서는 흥미롭지 않은 요소입니다. (처리 정크는 Ratcliff 및 Obershelp 알고리즘의 확장입니다.) 동일한 아이디어가 다음에 일치하는 서브 시퀀스의 왼쪽과 오른쪽 시퀀스의 조각에 재귀 적으로 적용됩니다. 이것은 최소한의 편집 시퀀스를 산출하지는 않지만 사람들에게 \"돋보이는\"일치를 산출하는 경향이 있습니다."

#: ../Doc/library/difflib.rst:40
#, fuzzy
msgid ""
"**Timing:** The basic Ratcliff-Obershelp algorithm is cubic time in the "
"worst case and quadratic time in the expected case. "
":class:`SequenceMatcher` is quadratic time for the worst case and has "
"expected-case behavior dependent in a complicated way on how many "
"elements the sequences have in common; best case time is linear."
msgstr "**타이밍 :** 기본 Ratcliff-Obershelp 알고리즘은 최악의 경우 입방 시간이고 예상되는 경우는 2 차 시간입니다. :class:`SequenceMatcher`\\는 최악의 경우에 2 차 시간이며 시퀀스에 공통으로 포함 된 요소의 수에 따라 복잡한 경우 예상되는 동작이 달라집니다. 가장 좋은 경우 시간은 선형입니다."

#: ../Doc/library/difflib.rst:46
#, python-format, fuzzy
msgid ""
"**Automatic junk heuristic:** :class:`SequenceMatcher` supports a "
"heuristic that automatically treats certain sequence items as junk. The "
"heuristic counts how many times each individual item appears in the "
"sequence. If an item's duplicates (after the first one) account for more "
"than 1% of the sequence and the sequence is at least 200 items long, this"
" item is marked as \"popular\" and is treated as junk for the purpose of "
"sequence matching. This heuristic can be turned off by setting the "
"``autojunk`` argument to ``False`` when creating the "
":class:`SequenceMatcher`."
msgstr "**Automatic junk heuristic :** :class:`SequenceMatcher`\\는 특정 시퀀스 항목을 자동으로 쓰레기로 처리하는 경험적 방법을 지원합니다. 경험적 방법은 각 개별 항목이 시퀀스에 나타나는 횟수를 계산합니다. 첫 번째 항목 이후의 중복 된 항목이 시퀀스의 1 % 이상을 차지하고 시퀀스의 길이가 최소 200 개 이상이면이 항목은 \"인기있는\"것으로 표시되고 시퀀스 일치를 위해 정크로 처리됩니다. 이 추론은 :class:`SequenceMatcher`\\를 만들 때 ``autojunk`` 인수를 ``False``\\로 설정하여 해제 할 수 있습니다."

#: ../Doc/library/difflib.rst:54 ../Doc/library/difflib.rst:383
#, fuzzy
msgid "The *autojunk* parameter."
msgstr "*autojunk* 매개 변수입니다."

#: ../Doc/library/difflib.rst:60
#, fuzzy
msgid ""
"This is a class for comparing sequences of lines of text, and producing "
"human-readable differences or deltas.  Differ uses "
":class:`SequenceMatcher` both to compare sequences of lines, and to "
"compare sequences of characters within similar (near-matching) lines."
msgstr "이것은 일련의 텍스트 행을 비교하고 인간이 읽을 수있는 차이 또는 델타를 생성하는 클래스입니다. Differ는 :class:`SequenceMatcher`\\를 사용하여 줄의 순서를 비교하고 유사한 (거의 일치하는) 줄 내의 문자 시퀀스를 비교합니다."

#: ../Doc/library/difflib.rst:65
#, fuzzy
msgid "Each line of a :class:`Differ` delta begins with a two-letter code:"
msgstr ":class:`Differ` 델타의 각 행은 2 자 코드로 시작합니다.:"

#: ../Doc/library/difflib.rst:68
#, fuzzy
msgid "Code"
msgstr "암호"

#: ../Doc/library/difflib.rst:68 ../Doc/library/difflib.rst:489
#, fuzzy
msgid "Meaning"
msgstr "의미"

#: ../Doc/library/difflib.rst:70
#, fuzzy
msgid "``'- '``"
msgstr "``'- '``"

#: ../Doc/library/difflib.rst:70
#, fuzzy
msgid "line unique to sequence 1"
msgstr "순서 1에 고유 한 행"

#: ../Doc/library/difflib.rst:72
#, fuzzy
msgid "``'+ '``"
msgstr "``'+ '``"

#: ../Doc/library/difflib.rst:72
#, fuzzy
msgid "line unique to sequence 2"
msgstr "시퀀스 2에 고유 한 라인"

#: ../Doc/library/difflib.rst:74
#, fuzzy
msgid "``'  '``"
msgstr "``'  '``"

#: ../Doc/library/difflib.rst:74
#, fuzzy
msgid "line common to both sequences"
msgstr "두 서열에 공통 인 선"

#: ../Doc/library/difflib.rst:76
#, fuzzy
msgid "``'? '``"
msgstr "``'? '``"

#: ../Doc/library/difflib.rst:76
#, fuzzy
msgid "line not present in either input sequence"
msgstr "입력 순서에없는 행"

#: ../Doc/library/difflib.rst:79
#, fuzzy
msgid ""
"Lines beginning with '``?``' attempt to guide the eye to intraline "
"differences, and were not present in either input sequence. These lines "
"can be confusing if the sequences contain tab characters."
msgstr "'``?``\\'로 시작하는 라인은 눈을 인트라 라인 차이로 유도하려고 시도하며 입력 순서에도 나타나지 않습니다. 이 줄은 시퀀스에 탭 문자가 포함 된 경우 혼동을 줄 수 있습니다."

#: ../Doc/library/difflib.rst:86
#, fuzzy
msgid ""
"This class can be used to create an HTML table (or a complete HTML file "
"containing the table) showing a side by side, line by line comparison of "
"text with inter-line and intra-line change highlights.  The table can be "
"generated in either full or contextual difference mode."
msgstr "이 클래스는 HTML 테이블 (또는 테이블을 포함하는 완전한 HTML 파일)을 작성하는 데 사용할 수 있습니다.이 HTML은 라인과 행간 변경 하이라이트와 텍스트를 한 줄씩 비교하여 보여줍니다. 테이블은 전체 또는 문맥 차이 모드로 생성 될 수 있습니다."

#: ../Doc/library/difflib.rst:91
#, fuzzy
msgid "The constructor for this class is:"
msgstr "이 클래스의 생성자는 다음과 같습니다.:"

#: ../Doc/library/difflib.rst:96
#, fuzzy
msgid "Initializes instance of :class:`HtmlDiff`."
msgstr ":class:`HtmlDiff`\\의 인스턴스를 초기화합니다."

#: ../Doc/library/difflib.rst:98
#, fuzzy
msgid ""
"*tabsize* is an optional keyword argument to specify tab stop spacing and"
" defaults to ``8``."
msgstr "*tabsize*\\는 탭 간격을 지정하는 선택적 키워드 인수이며 기본값은 ``8``\\입니다."

#: ../Doc/library/difflib.rst:101
#, fuzzy
msgid ""
"*wrapcolumn* is an optional keyword to specify column number where lines "
"are broken and wrapped, defaults to ``None`` where lines are not wrapped."
msgstr "*wrapcolumn*\\는 행 번호를 지정하는 선택적 키워드로, 행이 구분되고 랩핑되며 행이 랩핑되지 않은 ``None``\\로 기본 설정됩니다."

#: ../Doc/library/difflib.rst:104
#, fuzzy
msgid ""
"*linejunk* and *charjunk* are optional keyword arguments passed into "
":func:`ndiff` (used by :class:`HtmlDiff` to generate the side by side "
"HTML differences).  See :func:`ndiff` documentation for argument default "
"values and descriptions."
msgstr "*linejunk* 및 *charjunk*\\는 :func:`ndiff`\\로 전달되는 선택적 키워드 인수입니다 (:class:`HtmlDiff`\\가 나란히있는 HTML 차이를 생성하는 데 사용됨). 인수 기본값과 설명은 :func:`ndiff` 설명서를 참조하십시오."

#: ../Doc/library/difflib.rst:108
#, fuzzy
msgid "The following methods are public:"
msgstr "다음과 같은 방법이 공개됩니다.:"

#: ../Doc/library/difflib.rst:113
#, fuzzy
msgid ""
"Compares *fromlines* and *tolines* (lists of strings) and returns a "
"string which is a complete HTML file containing a table showing line by "
"line differences with inter-line and intra-line changes highlighted."
msgstr "*fromlines* 및 *tolines* (문자열 목록)를 비교하고 행간 및 행간 변경 사항이 강조 표시된 행마다 차이점을 표시하는 표가 포함 된 완전한 HTML 파일 인 문자열을 반환합니다."

#: ../Doc/library/difflib.rst:117
#, fuzzy
msgid ""
"*fromdesc* and *todesc* are optional keyword arguments to specify from/to"
" file column header strings (both default to an empty string)."
msgstr "*fromdesc* 및 *todesc*\\는 파일 열 머리글 문자열을 /에서 파일 문자열 헤더 열로 지정하는 선택적 키워드 인수입니다 (기본값은 모두 빈 문자열입니다)."

#: ../Doc/library/difflib.rst:120
#, fuzzy
msgid ""
"*context* and *numlines* are both optional keyword arguments. Set "
"*context* to ``True`` when contextual differences are to be shown, else "
"the default is ``False`` to show the full files. *numlines* defaults to "
"``5``.  When *context* is ``True`` *numlines* controls the number of "
"context lines which surround the difference highlights.  When *context* "
"is ``False`` *numlines* controls the number of lines which are shown "
"before a difference highlight when using the \"next\" hyperlinks (setting"
" to zero would cause the \"next\" hyperlinks to place the next difference"
" highlight at the top of the browser without any leading context)."
msgstr "*context* 및 *numlines*\\는 모두 선택적 키워드 인수입니다. 문맥상의 차이가 나타날 때 *context*\\를 ``True``\\로 설정하십시오. 그렇지 않은 경우 기본값은 전체 파일을 표시하는 ``False``\\입니다. *numlines*\\의 기본값은 ``5``\\입니다. *context*\\가 ``True`` 일 때 *numlines*\\는 차이 하이라이트를 둘러싸는 컨텍스트 라인의 수를 제어합니다. *context*\\가 ``False`` 인 경우 *numlines*\\는 \"다음\"하이퍼 링크를 사용할 때 차이 하이라이트 앞에 표시되는 줄 수를 제어합니다 (0으로 설정하면 \"다음\"하이퍼 링크가 브라우저의 맨 위에 아무런 유도없이 다음 차이 하이라이트를 놓을 수 있음) 문맥)."

#: ../Doc/library/difflib.rst:130
#, fuzzy
msgid ""
"*charset* keyword-only argument was added.  The default charset of HTML "
"document changed from ``'ISO-8859-1'`` to ``'utf-8'``."
msgstr "*charset* 키워드 전용 인수가 추가되었습니다. HTML 문서의 기본 문자 집합이 ``'ISO-8859-1'``\\에서 ``'utf-8'``\\로 변경되었습니다."

#: ../Doc/library/difflib.rst:136
#, fuzzy
msgid ""
"Compares *fromlines* and *tolines* (lists of strings) and returns a "
"string which is a complete HTML table showing line by line differences "
"with inter-line and intra-line changes highlighted."
msgstr "*fromlines* 및 *tolines* (문자열 목록)를 비교하고 줄간 및 줄간 변경 사항이 강조 표시된 줄 단위 차이를 나타내는 완전한 HTML 표인 문자열을 반환합니다."

#: ../Doc/library/difflib.rst:140
#, fuzzy
msgid ""
"The arguments for this method are the same as those for the "
":meth:`make_file` method."
msgstr "이 메소드의 인수는 :meth:`make_file` 메소드의 인수와 동일합니다."

#: ../Doc/library/difflib.rst:143
#, fuzzy
msgid ""
":file:`Tools/scripts/diff.py` is a command-line front-end to this class "
"and contains a good example of its use."
msgstr ":file:`Tools/scripts/diff.py`\\는이 클래스의 명령 줄 프런트 엔드이며 좋은 사용 예를 포함합니다."

#: ../Doc/library/difflib.rst:149
#, fuzzy
msgid ""
"Compare *a* and *b* (lists of strings); return a delta (a "
":term:`generator` generating the delta lines) in context diff format."
msgstr "*a*\\와 *b* (문자열 목록) 비교; 델타 (delta 행을 생성하는 :term:`generator`)를 컨텍스트 diff 형식으로 리턴하십시오."

#: ../Doc/library/difflib.rst:152
#, fuzzy
msgid ""
"Context diffs are a compact way of showing just the lines that have "
"changed plus a few lines of context.  The changes are shown in a "
"before/after style.  The number of context lines is set by *n* which "
"defaults to three."
msgstr "컨텍스트 차이는 변경된 선과 몇 줄의 컨텍스트를 표시하는 간결한 방법입니다. 변경 사항은 이전 / 이후 스타일로 표시됩니다. 컨텍스트 라인의 수는 *n*\\에 의해 설정되며 기본값은 3입니다."

#: ../Doc/library/difflib.rst:156
#, fuzzy
msgid ""
"By default, the diff control lines (those with ``***`` or ``---``) are "
"created with a trailing newline.  This is helpful so that inputs created "
"from :func:`io.IOBase.readlines` result in diffs that are suitable for "
"use with :func:`io.IOBase.writelines` since both the inputs and outputs "
"have trailing newlines."
msgstr "기본적으로 diff 제어 라인 (``***`` 또는 ``---`` 포함)은 후행 줄 바꿈으로 생성됩니다. 이것은 :func:`io.IOBase.readlines`\\에서 생성 된 입력이 :func:`io.IOBase.writelines`\\와 함께 사용하기에 적합한 diff를 생성하도록하는데 유용합니다. 왜냐하면 입력과 출력 모두 줄 바꿈 줄이 있기 때문입니다."

#: ../Doc/library/difflib.rst:162 ../Doc/library/difflib.rst:293
#, fuzzy
msgid ""
"For inputs that do not have trailing newlines, set the *lineterm* "
"argument to ``\"\"`` so that the output will be uniformly newline free."
msgstr "후행 줄 바꿈이없는 입력의 경우 *lineterm* 인수를 ``\"\"``\\로 설정하면 출력에 균일 한 개행이 적용되지 않습니다."

#: ../Doc/library/difflib.rst:165 ../Doc/library/difflib.rst:296
#, fuzzy
msgid ""
"The context diff format normally has a header for filenames and "
"modification times.  Any or all of these may be specified using strings "
"for *fromfile*, *tofile*, *fromfiledate*, and *tofiledate*.  The "
"modification times are normally expressed in the ISO 8601 format. If not "
"specified, the strings default to blanks."
msgstr "컨텍스트 diff 형식에는 일반적으로 파일 이름과 수정 시간에 대한 헤더가 있습니다. 이들 중 일부 또는 전부는 *fromfile*, *tofile*, *fromfiledate* 및 *tofiledate*\\에 대한 문자열을 사용하여 지정 될 수 있습니다. 수정 시간은 일반적으로 ISO 8601 형식으로 표현됩니다. 지정하지 않으면,. 자 열의 기본값은 공 i입니다."

#: ../Doc/library/difflib.rst:188 ../Doc/library/difflib.rst:317
#, fuzzy
msgid "See :ref:`difflib-interface` for a more detailed example."
msgstr "보다 자세한 예제는 :ref:`difflib-interface`\\를 참조하십시오."

#: ../Doc/library/difflib.rst:193
#, fuzzy
msgid ""
"Return a list of the best \"good enough\" matches.  *word* is a sequence "
"for which close matches are desired (typically a string), and "
"*possibilities* is a list of sequences against which to match *word* "
"(typically a list of strings)."
msgstr "가장 \"좋은\"일치 항목의 목록을 반환하십시오. *word*\\는 근접 일치가 필요한 시퀀스 (일반적으로 문자열)이며 *possibilities*\\는 *word* (일반적으로 문자열 목록)와 일치하는 시퀀스 목록입니다."

#: ../Doc/library/difflib.rst:197
#, fuzzy
msgid ""
"Optional argument *n* (default ``3``) is the maximum number of close "
"matches to return; *n* must be greater than ``0``."
msgstr "선택적 인수 *n* (기본값 ``3``)는 반환 할 닫기 일치의 최대 개수입니다. *n*\\는 ``0``\\보다 커야합니다."

#: ../Doc/library/difflib.rst:200
#, fuzzy
msgid ""
"Optional argument *cutoff* (default ``0.6``) is a float in the range [0, "
"1]. Possibilities that don't score at least that similar to *word* are "
"ignored."
msgstr "선택 인수 *cutoff* (기본값 ``0.6``)는 [0, 1] 범위의 부동 소수점 형입니다. 적어도 *word*\\와 비슷한 점수를 내지 않을 가능성은 무시됩니다."

#: ../Doc/library/difflib.rst:203
#, fuzzy
msgid ""
"The best (no more than *n*) matches among the possibilities are returned "
"in a list, sorted by similarity score, most similar first."
msgstr "가능성 중에서 가장 좋은 (*n* 이상) 일치가 유사성 점수로 정렬 된 목록으로 반환됩니다. 가장 유사한 순서가 먼저 적용됩니다."

#: ../Doc/library/difflib.rst:219
#, fuzzy
msgid ""
"Compare *a* and *b* (lists of strings); return a :class:`Differ`\\ -style"
" delta (a :term:`generator` generating the delta lines)."
msgstr "*a*\\와 *b* (문자열 목록) 비교; :class:`Differ` \\ - 스타일 델타 (델타 라인을 생성하는 :term:`generator`)를 반환합니다."

#: ../Doc/library/difflib.rst:222
#, fuzzy
msgid ""
"Optional keyword parameters *linejunk* and *charjunk* are filtering "
"functions (or ``None``):"
msgstr "선택적 키워드 매개 변수 *linejunk* 및 *charjunk*\\는 필터링 함수 (또는 ``None``)입니다.:"

#: ../Doc/library/difflib.rst:225
#, fuzzy
msgid ""
"*linejunk*: A function that accepts a single string argument, and returns"
" true if the string is junk, or false if not. The default is ``None``. "
"There is also a module-level function :func:`IS_LINE_JUNK`, which filters"
" out lines without visible characters, except for at most one pound "
"character (``'#'``) -- however the underlying :class:`SequenceMatcher` "
"class does a dynamic analysis of which lines are so frequent as to "
"constitute noise, and this usually works better than using this function."
msgstr "*linejunk* : 단일 문자열 인수를 허용하고 문자열이 정크 인 경우 true를 반환하고 그렇지 않으면 false를 반환하는 함수입니다. 기본값은 ``None``\\입니다. 또한 모듈 수준의 함수 :func:`IS_LINE_JUNK`\\가 있습니다. :func:`IS_LINE_JUNK`\\는 최대 1 파운드 문자 (``'#'``) --를 제외하고 눈에 보이는 문자가없는 행을 필터링하지만 기본 :class:`SequenceMatcher` 클래스는 노이즈를 구성하는 빈도가 높은 행을 동적으로 분석합니다. 이것은 보통이 함수를 사용하는 것보다 효과적입니다."

#: ../Doc/library/difflib.rst:233
#, fuzzy
msgid ""
"*charjunk*: A function that accepts a character (a string of length 1), "
"and returns if the character is junk, or false if not. The default is "
"module-level function :func:`IS_CHARACTER_JUNK`, which filters out "
"whitespace characters (a blank or tab; it's a bad idea to include newline"
" in this!)."
msgstr "*charjunk* : 문자 (길이 1의 문자열)를 허용하고 문자가 정크 인 경우를 반환하고 그렇지 않으면 false를 반환하는 함수입니다. 기본값은 모듈 수준의 함수 :func:`IS_CHARACTER_JUNK`\\입니다.이 함수는 공백 문자 (공백 또는 탭으로,이 경우 개행 문자를 포함하는 것은 좋지 않습니다)를 필터링합니다."

#: ../Doc/library/difflib.rst:238
#, fuzzy
msgid ""
":file:`Tools/scripts/ndiff.py` is a command-line front-end to this "
"function."
msgstr ":file:`Tools/scripts/ndiff.py`\\는이 기능에 대한 명령 행 프론트 엔드입니다."

#: ../Doc/library/difflib.rst:256
#, fuzzy
msgid "Return one of the two sequences that generated a delta."
msgstr "델타를 생성 한 두 시퀀스 중 하나를 반환합니다."

#: ../Doc/library/difflib.rst:258
#, fuzzy
msgid ""
"Given a *sequence* produced by :meth:`Differ.compare` or :func:`ndiff`, "
"extract lines originating from file 1 or 2 (parameter *which*), stripping"
" off line prefixes."
msgstr ":meth:`Differ.compare` 또는 :func:`ndiff`\\에 의해 생성 된 *sequence*\\가 주어지면 파일 접두어를 제거하여 파일 1 또는 2 (매개 변수 *which*)에서 시작하는 행을 추출합니다."

#: ../Doc/library/difflib.rst:262
#, fuzzy
msgid "Example:"
msgstr "예:"

#: ../Doc/library/difflib.rst:279
#, fuzzy
msgid ""
"Compare *a* and *b* (lists of strings); return a delta (a "
":term:`generator` generating the delta lines) in unified diff format."
msgstr "*a*\\와 *b* (문자열 목록) 비교; 델타 (델타 라인을 생성하는 :term:`generator`)를 통합 된 diff 형식으로 반환하십시오."

#: ../Doc/library/difflib.rst:282
#, fuzzy
msgid ""
"Unified diffs are a compact way of showing just the lines that have "
"changed plus a few lines of context.  The changes are shown in an inline "
"style (instead of separate before/after blocks).  The number of context "
"lines is set by *n* which defaults to three."
msgstr "통합 된 diff는 변경된 행과 몇 줄의 컨텍스트를 표시하는 간결한 방법입니다. 변경 사항은 별도의 before / after 블록 대신 인라인 스타일로 표시됩니다. 컨텍스트 라인의 수는 *n*\\에 의해 설정되며 기본값은 3입니다."

#: ../Doc/library/difflib.rst:287
#, fuzzy
msgid ""
"By default, the diff control lines (those with ``---``, ``+++``, or "
"``@@``) are created with a trailing newline.  This is helpful so that "
"inputs created from :func:`io.IOBase.readlines` result in diffs that are "
"suitable for use with :func:`io.IOBase.writelines` since both the inputs "
"and outputs have trailing newlines."
msgstr "기본적으로 diff 제어 행 (``---``, ``+++`` 또는 ``@@``\\가있는 행)은 후행 행으로 작성됩니다. 이것은 :func:`io.IOBase.readlines`\\에서 생성 된 입력이 :func:`io.IOBase.writelines`\\와 함께 사용하기에 적합한 diff를 생성하도록하는데 유용합니다. 왜냐하면 입력과 출력 모두 줄 바꿈 줄이 있기 때문입니다."

#: ../Doc/library/difflib.rst:321
#, fuzzy
msgid ""
"Compare *a* and *b* (lists of bytes objects) using *dfunc*; yield a "
"sequence of delta lines (also bytes) in the format returned by *dfunc*. "
"*dfunc* must be a callable, typically either :func:`unified_diff` or "
":func:`context_diff`."
msgstr "*a* 및 *b* (바이트 개체 목록)를 *dfunc*\\를 사용하여 비교하십시오. *dfunc*\\에 의해 반환 된 형식으로 일련의 델타 선 (바이트)을 생성합니다. *dfunc*\\는 호출 가능해야하며 일반적으로 :func:`unified_diff` 또는 :func:`context_diff`\\입니다."

#: ../Doc/library/difflib.rst:326
#, fuzzy
msgid ""
"Allows you to compare data with unknown or inconsistent encoding. All "
"inputs except *n* must be bytes objects, not str. Works by losslessly "
"converting all inputs (except *n*) to str, and calling ``dfunc(a, b, "
"fromfile, tofile, fromfiledate, tofiledate, n, lineterm)``. The output of"
" *dfunc* is then converted back to bytes, so the delta lines that you "
"receive have the same unknown/inconsistent encodings as *a* and *b*."
msgstr "알 수 없거나 일치하지 않는 인코딩과 데이터를 비교할 수 있습니다. *n*\\를 제외한 모든 입력은 str이 아닌 bytes 객체 여야합니다. 무손실로 모든 입력 (*n* 제외)을 str로 변환하고 ``dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm)``\\를 호출하여 작동합니다. *dfunc*\\의 출력은 다시 바이트로 변환되므로 수신하는 델타 라인은 *a* 및 *b*\\와 동일한 알 수없는 / 일관되지 않은 인코딩을 갖습니다."

#: ../Doc/library/difflib.rst:337
#, fuzzy
msgid ""
"Return true for ignorable lines.  The line *line* is ignorable if *line* "
"is blank or contains a single ``'#'``, otherwise it is not ignorable.  "
"Used as a default for parameter *linejunk* in :func:`ndiff` in older "
"versions."
msgstr "무시할 수있는 행에 대해서는 true를 리턴합니다. *line*\\가 공백이거나 하나의 ``'#'``\\를 포함하면 *line* 행은 무시할 수 있습니다. 그렇지 않으면 무시할 수 없습니다. 이전 버전의 :func:`ndiff`\\에서 매개 변수 *linejunk*\\의 기본값으로 사용됩니다."

#: ../Doc/library/difflib.rst:344
#, fuzzy
msgid ""
"Return true for ignorable characters.  The character *ch* is ignorable if"
" *ch* is a space or tab, otherwise it is not ignorable.  Used as a "
"default for parameter *charjunk* in :func:`ndiff`."
msgstr "무시할 수있는 문자에 대해서는 true를 반환합니다. 문자 *ch*\\는 *ch*\\가 공백이나 탭이면 무시할 수 있습니다. 그렇지 않으면 무시할 수 없습니다. :func:`ndiff`\\에서 매개 변수 *charjunk*\\의 기본값으로 사용됩니다."

#: ../Doc/library/difflib.rst:352
#, fuzzy
msgid ""
"`Pattern Matching: The Gestalt Approach <http://www.drdobbs.com/database"
"/pattern-matching-the-gestalt-approach/184407970>`_"
msgstr "`Pattern Matching: The Gestalt Approach <http://www.drdobbs.com/database/pattern-matching-the-gestalt-approach/184407970>`_"

#: ../Doc/library/difflib.rst:352
#, fuzzy
msgid ""
"Discussion of a similar algorithm by John W. Ratcliff and D. E. Metzener."
" This was published in `Dr. Dobb's Journal <http://www.drdobbs.com/>`_ in"
" July, 1988."
msgstr "John W. Ratcliff와 DE Metzener의 비슷한 알고리즘에 대한 토론. 이것은 1988 년 7 월 `Dr. Dobb's Journal <http://www.drdobbs.com/>`_\\에 출판되었습니다."

#: ../Doc/library/difflib.rst:359
#, fuzzy
msgid "SequenceMatcher Objects"
msgstr "SequenceMatcher 객체"

#: ../Doc/library/difflib.rst:361
#, fuzzy
msgid "The :class:`SequenceMatcher` class has this constructor:"
msgstr ":class:`SequenceMatcher` 클래스에는 다음과 같은 생성자가 있습니다.:"

#: ../Doc/library/difflib.rst:366
#, fuzzy
msgid ""
"Optional argument *isjunk* must be ``None`` (the default) or a one-"
"argument function that takes a sequence element and returns true if and "
"only if the element is \"junk\" and should be ignored. Passing ``None`` "
"for *isjunk* is equivalent to passing ``lambda x: 0``; in other words, no"
" elements are ignored. For example, pass::"
msgstr "선택 인수 *isjunk*\\는 ``None`` (기본값) 또는 시퀀스 요소를 취하는 하나의 인수 함수 여야하며 요소가 \"junk\"이고 무시되어야하는 경우에만 true를 반환합니다. *isjunk*\\에 대한 ``None``\\를 전달하는 것은 ``lambda x: 0``\\를 전달하는 것과 같습니다. 즉, 무시 된 요소가 없습니다. 예 : pass ::"

#: ../Doc/library/difflib.rst:374
#, fuzzy
msgid ""
"if you're comparing lines as sequences of characters, and don't want to "
"synch up on blanks or hard tabs."
msgstr "행을 문자의 시퀀스로 비교하고 공백이나 단단한 탭을 동기화하고 싶지 않은 경우"

#: ../Doc/library/difflib.rst:377
#, fuzzy
msgid ""
"The optional arguments *a* and *b* are sequences to be compared; both "
"default to empty strings.  The elements of both sequences must be "
":term:`hashable`."
msgstr "선택적 인수 *a* 및 *b*\\는 비교할 시퀀스입니다. 둘 다 공백 문자열을 기본값으로 사용합니다. 두 시퀀스의 요소는 모두 :term:`hashable` 여야합니다."

#: ../Doc/library/difflib.rst:380
#, fuzzy
msgid ""
"The optional argument *autojunk* can be used to disable the automatic "
"junk heuristic."
msgstr "*autojunk* 옵션 인수는 자동 정크 휴리스틱을 비활성화하는 데 사용할 수 있습니다."

#: ../Doc/library/difflib.rst:386
#, fuzzy
msgid ""
"SequenceMatcher objects get three data attributes: *bjunk* is the set of "
"elements of *b* for which *isjunk* is ``True``; *bpopular* is the set of "
"non-junk elements considered popular by the heuristic (if it is not "
"disabled); *b2j* is a dict mapping the remaining elements of *b* to a "
"list of positions where they occur. All three are reset whenever *b* is "
"reset with :meth:`set_seqs` or :meth:`set_seq2`."
msgstr "SequenceMatcher 객체는 세 가지 데이터 속성을 갖습니다. *bjunk*\\는 *isjunk*\\가 ``True`` 인 *b* 요소 집합입니다. *bpopular*\\는 휴리스틱에서 인기가 있다고 판단되는 비 정크 요소 세트입니다 (사용하지 않는 경우). *b2j*\\는 *b*\\의 나머지 요소를 발생하는 위치 목록에 매핑하는 사전입니다. *b*\\가 :meth:`set_seqs` 또는 :meth:`set_seq2`\\로 재설정 될 때마다 세 개 모두 재설정됩니다."

#: ../Doc/library/difflib.rst:393
#, fuzzy
msgid "The *bjunk* and *bpopular* attributes."
msgstr "*bjunk* 및 *bpopular* 속성"

#: ../Doc/library/difflib.rst:396
#, fuzzy
msgid ":class:`SequenceMatcher` objects have the following methods:"
msgstr ":class:`SequenceMatcher` 객체에는 다음과 같은 메소드가 있습니다.:"

#: ../Doc/library/difflib.rst:400
#, fuzzy
msgid "Set the two sequences to be compared."
msgstr "비교할 두 시퀀스를 설정합니다."

#: ../Doc/library/difflib.rst:402
#, fuzzy
msgid ""
":class:`SequenceMatcher` computes and caches detailed information about "
"the second sequence, so if you want to compare one sequence against many "
"sequences, use :meth:`set_seq2` to set the commonly used sequence once "
"and call :meth:`set_seq1` repeatedly, once for each of the other "
"sequences."
msgstr ":class:`SequenceMatcher`\\는 두 번째 시퀀스에 대한 자세한 정보를 계산하고 캐시하므로 많은 시퀀스에 대해 하나의 시퀀스를 비교하려면 :meth:`set_seq2`\\를 사용하여 자주 사용되는 시퀀스를 한 번 설정하고 :meth:`set_seq1`\\를 다른 시퀀스 각각에 대해 한 번 반복적으로 호출합니다."

#: ../Doc/library/difflib.rst:410
#, fuzzy
msgid ""
"Set the first sequence to be compared.  The second sequence to be "
"compared is not changed."
msgstr "비교할 첫 번째 시퀀스를 설정합니다. 비교할 두 번째 시퀀스는 변경되지 않습니다."

#: ../Doc/library/difflib.rst:416
#, fuzzy
msgid ""
"Set the second sequence to be compared.  The first sequence to be "
"compared is not changed."
msgstr "비교할 두 번째 시퀀스를 설정합니다. 비교할 첫 번째 시퀀스는 변경되지 않습니다."

#: ../Doc/library/difflib.rst:422
#, fuzzy
msgid "Find longest matching block in ``a[alo:ahi]`` and ``b[blo:bhi]``."
msgstr "``a[alo:ahi]`` 및 ``b[blo:bhi]``\\에서 가장 긴 일치 블록을 찾으십시오."

#: ../Doc/library/difflib.rst:424
#, fuzzy
msgid ""
"If *isjunk* was omitted or ``None``, :meth:`find_longest_match` returns "
"``(i, j, k)`` such that ``a[i:i+k]`` is equal to ``b[j:j+k]``, where "
"``alo <= i <= i+k <= ahi`` and ``blo <= j <= j+k <= bhi``. For all ``(i',"
" j', k')`` meeting those conditions, the additional conditions ``k >= "
"k'``, ``i <= i'``, and if ``i == i'``, ``j <= j'`` are also met. In other"
" words, of all maximal matching blocks, return one that starts earliest "
"in *a*, and of all those maximal matching blocks that start earliest in "
"*a*, return the one that starts earliest in *b*."
msgstr "*isjunk*\\가 생략되거나 ``None`` 인 경우 :meth:`find_longest_match`\\는 ``(i, j, k)``\\를 반환하여 ``a[i:i+k]``\\가 ``b[j:j+k]``\\와 같습니다 (``alo <= i <= i+k <= ahi`` 및 ``blo <= j <= j+k <= bhi``). 해당 조건을 충족시키는 모든 ``(i', j', k')``\\에 대해 추가 조건 ``k >= k'``, ``i <= i'`` 및 ``i == i'``, ``j <= j'``\\가 충족되는 경우에도 조건이 충족됩니다. 즉, 모든 최대 일치 블록 중에서 *a*\\에서 가장 초기에 시작하는 블록을 반환하고 *a*\\에서 가장 초기에 시작하는 모든 최대 일치 블록을 반환하고 *b*\\에서 가장 먼저 시작하는 블록을 반환합니다."

#: ../Doc/library/difflib.rst:437
#, fuzzy
msgid ""
"If *isjunk* was provided, first the longest matching block is determined "
"as above, but with the additional restriction that no junk element "
"appears in the block.  Then that block is extended as far as possible by "
"matching (only) junk elements on both sides. So the resulting block never"
" matches on junk except as identical junk happens to be adjacent to an "
"interesting match."
msgstr "*isjunk*\\가 제공되면, 가장 긴 정합 블록이 상기와 같이 결정되지만, 정크 요소가 블록에 나타나지 않는 추가 제한이있다. 그런 다음 해당 블록은 양쪽에서 정크 요소를 일치시켜 (가능한 한) 최대한 확장됩니다. 결과 블록은 정크와 일치하지 않습니다. 단, 같은 정크가 흥미로운 매치에 인접 해있는 경우는 예외입니다."

#: ../Doc/library/difflib.rst:444
#, fuzzy
msgid ""
"Here's the same example as before, but considering blanks to be junk. "
"That prevents ``' abcd'`` from matching the ``' abcd'`` at the tail end "
"of the second sequence directly.  Instead only the ``'abcd'`` can match, "
"and matches the leftmost ``'abcd'`` in the second sequence:"
msgstr "이전과 같은 예가 있지만 공백을 쓰레기로 간주합니다. 이렇게하면 ``' abcd'``\\가 두 번째 시퀀스의 끝에있는 ``' abcd'``\\와 직접 일치하지 않게됩니다. 대신 ``'abcd'`` 만 일치 할 수 있으며 두 번째 시퀀스에서 가장 왼쪽의 ``'abcd'``\\와 일치합니다.:"

#: ../Doc/library/difflib.rst:453
#, fuzzy
msgid "If no blocks match, this returns ``(alo, blo, 0)``."
msgstr "일치하는 블록이 없으면 ``(alo, blo, 0)``\\를 리턴합니다."

#: ../Doc/library/difflib.rst:455
#, fuzzy
msgid "This method returns a :term:`named tuple` ``Match(a, b, size)``."
msgstr "이 메서드는 :term:`named tuple` ``Match(a, b, size)``\\를 반환합니다."

#: ../Doc/library/difflib.rst:460
#, fuzzy
msgid ""
"Return list of triples describing matching subsequences. Each triple is "
"of the form ``(i, j, n)``, and means that ``a[i:i+n] == b[j:j+n]``.  The "
"triples are monotonically increasing in *i* and *j*."
msgstr "일치하는 서브 순서를 기술하는 트리플의리스트를 돌려줍니다. 각 트리플은 ``(i, j, n)`` 형식이며 ``a[i:i+n] == b[j:j+n]``\\를의 L합니다. 트리플은 *i*\\와 *j*\\에서 단조롭게 증가합니다."

#: ../Doc/library/difflib.rst:464
#, fuzzy
msgid ""
"The last triple is a dummy, and has the value ``(len(a), len(b), 0)``.  "
"It is the only triple with ``n == 0``.  If ``(i, j, n)`` and ``(i', j', "
"n')`` are adjacent triples in the list, and the second is not the last "
"triple in the list, then ``i+n != i'`` or ``j+n != j'``; in other words, "
"adjacent triples always describe non-adjacent equal blocks."
msgstr "마지막 트리플은 더미이며 ``(len(a), len(b), 0)`` 값을가집니다. ``n == 0``\\가있는 유일한 트리플입니다. ``(i, j, n)``\\와 ``(i', j', n')``\\가 목록에서 인접한 세 쌍이고 두 번째가 목록의 마지막 트리플이 아니면 ``i+n != i'`` 또는 ``j+n != j'``\\입니다. 즉, 인접 트리플은 항상 인접하지 않은 동일한 블록을 나타냅니다."

#: ../Doc/library/difflib.rst:481
#, fuzzy
msgid ""
"Return list of 5-tuples describing how to turn *a* into *b*. Each tuple "
"is of the form ``(tag, i1, i2, j1, j2)``.  The first tuple has ``i1 == j1"
" == 0``, and remaining tuples have *i1* equal to the *i2* from the "
"preceding tuple, and, likewise, *j1* equal to the previous *j2*."
msgstr "*a*\\를 *b*\\로 변환하는 방법을 설명하는 5 튜플의 목록을 반환합니다. 각 튜플은 ``(tag, i1, i2, j1, j2)`` 형식입니다. 첫 번째 튜플에는 ``i1 == j1 == 0``\\가 있고 나머지 튜플에는 이전 튜플의 *i2*\\와 동일한 *i1*\\가 있고, 마찬가지로 *j1*\\는 이전 *j2*\\와 같습니다."

#: ../Doc/library/difflib.rst:486
#, fuzzy
msgid "The *tag* values are strings, with these meanings:"
msgstr "*tag* 값은 다음과 같은 의미의 문자열입니다.:"

#: ../Doc/library/difflib.rst:489
#, fuzzy
msgid "Value"
msgstr "값"

#: ../Doc/library/difflib.rst:491
#, fuzzy
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../Doc/library/difflib.rst:491
#, fuzzy
msgid "``a[i1:i2]`` should be replaced by ``b[j1:j2]``."
msgstr "``a[i1:i2]``\\는 ``b[j1:j2]``\\로 대체해야합니다."

#: ../Doc/library/difflib.rst:494
#, fuzzy
msgid "``'delete'``"
msgstr "``'delete'``"

#: ../Doc/library/difflib.rst:494
#, fuzzy
msgid "``a[i1:i2]`` should be deleted.  Note that ``j1 == j2`` in this case."
msgstr "``a[i1:i2]``\\는 삭제해야합니다. 이 경우 ``j1 == j2``\\를 유의하십시오."

#: ../Doc/library/difflib.rst:497
#, fuzzy
msgid "``'insert'``"
msgstr "``'insert'``"

#: ../Doc/library/difflib.rst:497
#, fuzzy
msgid ""
"``b[j1:j2]`` should be inserted at ``a[i1:i1]``. Note that ``i1 == i2`` "
"in this case."
msgstr "``b[j1:j2]``\\는 ``a[i1:i1]``\\에 삽입되어야합니다. 이 경우 ``i1 == i2``\\를 유의하십시오."

#: ../Doc/library/difflib.rst:501
#, fuzzy
msgid "``'equal'``"
msgstr "``'equal'``"

#: ../Doc/library/difflib.rst:501
#, fuzzy
msgid "``a[i1:i2] == b[j1:j2]`` (the sub-sequences are equal)."
msgstr "``a[i1:i2] == b[j1:j2]`` (하위 시퀀스가 동일 함)."

#: ../Doc/library/difflib.rst:505
#, fuzzy
msgid "For example::"
msgstr "예를 들면 ::"

#: ../Doc/library/difflib.rst:522
#, fuzzy
msgid "Return a :term:`generator` of groups with up to *n* lines of context."
msgstr "최대 *n* 행의 컨텍스트로 그룹의 :term:`generator`\\를 리턴하십시오."

#: ../Doc/library/difflib.rst:524
#, fuzzy
msgid ""
"Starting with the groups returned by :meth:`get_opcodes`, this method "
"splits out smaller change clusters and eliminates intervening ranges "
"which have no changes."
msgstr ":meth:`get_opcodes`\\에서 반환 된 그룹부터 시작하여이 방법은 더 작은 변경 클러스터를 분할하고 변경 사항이없는 중간 범위를 제거합니다."

#: ../Doc/library/difflib.rst:528
#, fuzzy
msgid "The groups are returned in the same format as :meth:`get_opcodes`."
msgstr "그룹은 :meth:`get_opcodes`\\와 동일한 형식으로 리턴됩니다."

#: ../Doc/library/difflib.rst:533
#, fuzzy
msgid ""
"Return a measure of the sequences' similarity as a float in the range [0,"
" 1]."
msgstr "[0, 1]의 범위의 float로서 순서의 유사성의 measure를 돌려줍니다."

#: ../Doc/library/difflib.rst:536
#, fuzzy
msgid ""
"Where T is the total number of elements in both sequences, and M is the "
"number of matches, this is 2.0\\*M / T. Note that this is ``1.0`` if the "
"sequences are identical, and ``0.0`` if they have nothing in common."
msgstr "여기서 T는 두 시퀀스의 요소의 총 개수이고 M은 일치 개수입니다.이 시퀀스는 2.0 \\ * M / T입니다. 시퀀스가 동일하면 ``1.0``\\이고 공통 요소가없는 경우 ``0.0``\\입니다."

#: ../Doc/library/difflib.rst:540
#, fuzzy
msgid ""
"This is expensive to compute if :meth:`get_matching_blocks` or "
":meth:`get_opcodes` hasn't already been called, in which case you may "
"want to try :meth:`quick_ratio` or :meth:`real_quick_ratio` first to get "
"an upper bound."
msgstr ":meth:`get_matching_blocks` 또는 :meth:`get_opcodes`\\가 아직 호출되지 않은 경우 계산하는 데 비용이 많이 든다.이 경우 :meth:`quick_ratio` 또는 :meth:`real_quick_ratio`\\를 먼저 시도하여 상한값을 얻으려고 할 수있다."

#: ../Doc/library/difflib.rst:548
#, fuzzy
msgid "Return an upper bound on :meth:`ratio` relatively quickly."
msgstr "비교적 빨리 :meth:`ratio`\\의 상한을 반환하십시오."

#: ../Doc/library/difflib.rst:553
#, fuzzy
msgid "Return an upper bound on :meth:`ratio` very quickly."
msgstr ":meth:`ratio`\\의 상한을 매우 빨리 반환하십시오."

#: ../Doc/library/difflib.rst:556
#, fuzzy
msgid ""
"The three methods that return the ratio of matching to total characters "
"can give different results due to differing levels of approximation, "
"although :meth:`quick_ratio` and :meth:`real_quick_ratio` are always at "
"least as large as :meth:`ratio`:"
msgstr "총 문자 수에 대한 일치 비율을 반환하는 세 가지 방법은 :meth:`quick_ratio` 및 :meth:`real_quick_ratio`\\가 항상 :meth:`ratio`\\만큼 큰 경우에도 서로 다른 수준의 근사값 때문에 다른 결과를 줄 수 있습니다.:"

#: ../Doc/library/difflib.rst:573
#, fuzzy
msgid "SequenceMatcher Examples"
msgstr "SequenceMatcher 예제"

#: ../Doc/library/difflib.rst:575
#, fuzzy
msgid "This example compares two strings, considering blanks to be \"junk\":"
msgstr "이 예제에서는 공백을 \"쓸데없는\"것으로 간주하여 두 문자열을 비교합니다.:"

#: ../Doc/library/difflib.rst:581
#, fuzzy
msgid ""
":meth:`ratio` returns a float in [0, 1], measuring the similarity of the "
"sequences.  As a rule of thumb, a :meth:`ratio` value over 0.6 means the "
"sequences are close matches:"
msgstr ":meth:`ratio`\\는 [0, 1]에 float를 반환하여 시퀀스의 유사성을 측정합니다. 경험적으로 :meth:`ratio` 값이 0.6 이상이면 시퀀스가 가까운 일치를 의미합니다.:"

#: ../Doc/library/difflib.rst:588
#, fuzzy
msgid ""
"If you're only interested in where the sequences match, "
":meth:`get_matching_blocks` is handy:"
msgstr "시퀀스가 일치하는 부분에만 관심이 있다면 :meth:`get_matching_blocks`\\가 유용합니다.:"

#: ../Doc/library/difflib.rst:597
#, fuzzy
msgid ""
"Note that the last tuple returned by :meth:`get_matching_blocks` is "
"always a dummy, ``(len(a), len(b), 0)``, and this is the only case in "
"which the last tuple element (number of elements matched) is ``0``."
msgstr ":meth:`get_matching_blocks`\\에 의해 반환 된 마지막 튜플은 항상 더미 인 ``(len(a), len(b), 0)``\\이며 이는 마지막 튜플 요소 (일치하는 요소의 수)가 ``0`` 인 유일한 경우입니다."

#: ../Doc/library/difflib.rst:601
#, fuzzy
msgid ""
"If you want to know how to change the first sequence into the second, use"
" :meth:`get_opcodes`:"
msgstr "첫 번째 시퀀스를 두 번째 시퀀스로 변경하는 방법을 알고 싶다면 :meth:`get_opcodes`\\를 사용하십시오.:"

#: ../Doc/library/difflib.rst:612
#, fuzzy
msgid ""
"The :func:`get_close_matches` function in this module which shows how "
"simple code building on :class:`SequenceMatcher` can be used to do useful"
" work."
msgstr "이 모듈의 :func:`get_close_matches` 함수는 :class:`SequenceMatcher`\\에서 간단한 코드 작성을 통해 유용한 작업을 수행하는 방법을 보여줍니다."

#: ../Doc/library/difflib.rst:616
#, fuzzy
msgid ""
"`Simple version control recipe "
"<https://code.activestate.com/recipes/576729/>`_ for a small application "
"built with :class:`SequenceMatcher`."
msgstr ":class:`SequenceMatcher`\\로 빌드 된 작은 응용 프로그램의 경우 `Simple version control recipe <https://code.activestate.com/recipes/576729/>`_."

#: ../Doc/library/difflib.rst:624
#, fuzzy
msgid "Differ Objects"
msgstr "개체 차별화"

#: ../Doc/library/difflib.rst:626
#, fuzzy
msgid ""
"Note that :class:`Differ`\\ -generated deltas make no claim to be "
"**minimal** diffs. To the contrary, minimal diffs are often counter-"
"intuitive, because they synch up anywhere possible, sometimes accidental "
"matches 100 pages apart. Restricting synch points to contiguous matches "
"preserves some notion of locality, at the occasional cost of producing a "
"longer diff."
msgstr ":class:`Differ` \\ 생성 된 델타는 **최소** 차등이라고 주장하지 않습니다. 반대로, 최소한의 차이는 자주 반 직관적입니다. 왜냐하면 어디서나 가능한 한 동기를 취하기 때문입니다. 우발적 인 경우 100 페이지가 서로 일치하기도합니다. 동기화 지점을 인접한 일치 항목으로 제한하면 가끔씩 더 긴 diff를 생성하는 데 드는 비용으로 지역에 대한 개념이 유지됩니다."

#: ../Doc/library/difflib.rst:632
#, fuzzy
msgid "The :class:`Differ` class has this constructor:"
msgstr ":class:`Differ` 클래스에는 다음과 같은 생성자가 있습니다.:"

#: ../Doc/library/difflib.rst:637
#, fuzzy
msgid ""
"Optional keyword parameters *linejunk* and *charjunk* are for filter "
"functions (or ``None``):"
msgstr "선택적 키워드 매개 변수 *linejunk* 및 *charjunk*\\는 필터 기능 (또는 ``None``) 용입니다.:"

#: ../Doc/library/difflib.rst:640
#, fuzzy
msgid ""
"*linejunk*: A function that accepts a single string argument, and returns"
" true if the string is junk.  The default is ``None``, meaning that no "
"line is considered junk."
msgstr "*linejunk* : 단일 문자열 인수를 받아들이고 해당 문자열이 정크 인 경우 true를 반환하는 함수입니다. 기본값은 ``None``\\입니다. 즉, 선이 쓰레기로 간주되지 않습니다."

#: ../Doc/library/difflib.rst:644
#, fuzzy
msgid ""
"*charjunk*: A function that accepts a single character argument (a string"
" of length 1), and returns true if the character is junk. The default is "
"``None``, meaning that no character is considered junk."
msgstr "*charjunk* : 단일 문자 인수 (길이가 1 인 문자열)를 허용하고 문자가 쓸데없는 경우 true를 반환하는 함수입니다. 기본값은 ``None``\\이며, 이는 문자가 정크로 간주되지 않음을 의미합니다."

#: ../Doc/library/difflib.rst:648
#, fuzzy
msgid ""
"These junk-filtering functions speed up matching to find differences and "
"do not cause any differing lines or characters to be ignored.  Read the "
"description of the :meth:`~SequenceMatcher.find_longest_match` method's "
"*isjunk* parameter for an explanation."
msgstr "이러한 정크 필터링 기능은 차이점을 찾기 위해 일치 속도를 높이고 다른 선이나 문자를 무시하지 않습니다. 설명을 위해 :meth:`~SequenceMatcher.find_longest_match` 메소드의 *isjunk* 매개 변수에 대한 설명을 읽으십시오."

#: ../Doc/library/difflib.rst:654
#, fuzzy
msgid ":class:`Differ` objects are used (deltas generated) via a single method:"
msgstr "단일 메소드를 통해 :class:`Differ` 오브젝트가 사용됩니다 (델타가 생성됨).:"

#: ../Doc/library/difflib.rst:659
#, fuzzy
msgid ""
"Compare two sequences of lines, and generate the delta (a sequence of "
"lines)."
msgstr "두 개의 라인 시퀀스를 비교하고 델타 (라인 시퀀스)를 생성합니다."

#: ../Doc/library/difflib.rst:661
#, fuzzy
msgid ""
"Each sequence must contain individual single-line strings ending with "
"newlines.  Such sequences can be obtained from the "
":meth:`~io.IOBase.readlines` method of file-like objects.  The delta "
"generated also consists of newline-terminated strings, ready to be "
"printed as-is via the :meth:`~io.IOBase.writelines` method of a file-like"
" object."
msgstr "각 시퀀스에는 개행으로 끝나는 개별 단일 행 문자열이 포함되어야합니다. 이러한 시퀀스는 파일과 같은 객체의 :meth:`~io.IOBase.readlines` 메소드에서 얻을 수 있습니다. 또한 생성 된 델타는 파일과 유사한 객체의 :meth:`~io.IOBase.writelines` 메소드를 통해 그대로 인쇄 될 수 있도록 새줄로 끝나는 문자열로 구성됩니다."

#: ../Doc/library/difflib.rst:672
#, fuzzy
msgid "Differ Example"
msgstr "다른 예"

#: ../Doc/library/difflib.rst:674
#, fuzzy
msgid ""
"This example compares two texts. First we set up the texts, sequences of "
"individual single-line strings ending with newlines (such sequences can "
"also be obtained from the :meth:`~io.BaseIO.readlines` method of file-"
"like objects):"
msgstr "이 예제는 두 개의 텍스트를 비교합니다. 먼저 텍스트를 설정합니다. 개행 문자로 끝나는 개별 단일 행 문자열의 시퀀스 (이러한 시퀀스는 파일과 유사한 객체의 :meth:`~io.BaseIO.readlines` 메서드에서도 얻을 수 있습니다).:"

#: ../Doc/library/difflib.rst:693
#, fuzzy
msgid "Next we instantiate a Differ object:"
msgstr "다음으로 Differ 객체를 인스턴스화합니다.:"

#: ../Doc/library/difflib.rst:697
#, fuzzy
msgid ""
"Note that when instantiating a :class:`Differ` object we may pass "
"functions to filter out line and character \"junk.\"  See the "
":meth:`Differ` constructor for details."
msgstr ":class:`Differ` 객체를 인스턴스화 할 때 줄과 문자 \"정크\"를 필터링하는 함수를 전달할 수 있습니다. 자세한 내용은 :meth:`Differ` 생성자를 참조하십시오."

#: ../Doc/library/difflib.rst:701
#, fuzzy
msgid "Finally, we compare the two:"
msgstr "마지막으로 두 가지를 비교합니다.:"

#: ../Doc/library/difflib.rst:705
#, fuzzy
msgid "``result`` is a list of strings, so let's pretty-print it:"
msgstr "``result``\\는 문자열 목록이므로 예쁜 인쇄를 해봅시다.:"

#: ../Doc/library/difflib.rst:720
#, fuzzy
msgid "As a single multi-line string it looks like this:"
msgstr "단일 멀티 라인 문자열로서 다음과 같이 보입니다.:"

#: ../Doc/library/difflib.rst:739
#, fuzzy
msgid "A command-line interface to difflib"
msgstr "difflib에 대한 명령 행 인터페이스"

#: ../Doc/library/difflib.rst:741
#, fuzzy
msgid ""
"This example shows how to use difflib to create a ``diff``-like utility. "
"It is also contained in the Python source distribution, as "
":file:`Tools/scripts/diff.py`."
msgstr "이 예제에서는 difflib를 사용하여 ``diff``\\와 유사한 유틸리티를 만드는 방법을 보여줍니다. 또한 Python 소스 배포판에 :file:`Tools/scripts/diff.py`\\로 포함되어 있습니다."
