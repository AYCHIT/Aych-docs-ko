# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 11:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/logging.rst:2
#, fuzzy
msgid ":mod:`logging` --- Logging facility for Python"
msgstr ":mod:`logging` --- Python을위한 로깅 기능"

#: ../Doc/library/logging.rst:10
msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**소스 코드:** :source:`Lib/logging/__init__.py`"

#: ../Doc/library/logging.rst:16
#, fuzzy
msgid ""
"This page contains the API reference information. For tutorial "
"information and discussion of more advanced topics, see"
msgstr "이 페이지는 API 참조 정보를 포함합니다. 자습서 정보 및 고급 주제에 대한 설명은 다음을 참조하십시오."

#: ../Doc/library/logging.rst:19
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`기초 자습서 <logging-basic-tutorial>`"

#: ../Doc/library/logging.rst:20
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`고급 자습서 <logging-advanced-tutorial>`"

#: ../Doc/library/logging.rst:21
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`로깅 요리책 <logging-cookbook>`"

#: ../Doc/library/logging.rst:25
#, fuzzy
msgid ""
"This module defines functions and classes which implement a flexible "
"event logging system for applications and libraries."
msgstr "이 모듈은 응용 프로그램 및 라이브러리에 대한 유연한 이벤트 로깅 시스템을 구현하는 함수 및 클래스를 정의합니다."

#: ../Doc/library/logging.rst:28
#, fuzzy
msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages "
"from third-party modules."
msgstr "표준 라이브러리 모듈에서 제공하는 로깅 API의 주요 이점은 모든 Python 모듈이 로깅에 참여할 수 있으므로 응용 프로그램 로그에 타사 모듈의 메시지와 통합 된 고유 메시지가 포함될 수 있다는 것입니다."

#: ../Doc/library/logging.rst:33
#, fuzzy
msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to see "
"the tutorials (see the links on the right)."
msgstr "이 모듈은 많은 기능과 유연성을 제공합니다. 로깅에 익숙하지 않다면, 그 길을 잡는 가장 좋은 방법은 튜토리얼을 보는 것입니다 (오른쪽 링크 참조)."

#: ../Doc/library/logging.rst:37
#, fuzzy
msgid ""
"The basic classes defined by the module, together with their functions, "
"are listed below."
msgstr "모듈에 의해 정의 된 기본 클래스와 그 기능은 다음과 같습니다."

#: ../Doc/library/logging.rst:40
#, fuzzy
msgid "Loggers expose the interface that application code directly uses."
msgstr "로거는 응용 프로그램 코드가 직접 사용하는 인터페이스를 노출합니다."

#: ../Doc/library/logging.rst:41
#, fuzzy
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr "핸들러는 (로거에 의해 작성된) 로그 레코드를 적절한 목적지로 송신합니다."

#: ../Doc/library/logging.rst:43
#, fuzzy
msgid ""
"Filters provide a finer grained facility for determining which log "
"records to output."
msgstr "필터는 출력 할 로그 레코드를 결정하기위한보다 세분화 된 기능을 제공합니다."

#: ../Doc/library/logging.rst:45
#, fuzzy
msgid "Formatters specify the layout of log records in the final output."
msgstr "포매터는 최종 출력에서 ​​로그 레코드의 레이아웃을 지정합니다."

#: ../Doc/library/logging.rst:51
#, fuzzy
msgid "Logger Objects"
msgstr "로거 객체"

#: ../Doc/library/logging.rst:53
#, fuzzy
msgid ""
"Loggers have the following attributes and methods.  Note that Loggers are"
" never instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to "
":func:`getLogger` with the same name will always return a reference to "
"the same Logger object."
msgstr "로거에는 다음과 같은 특성과 메서드가 있습니다. 로거는 결코 직접적으로 인스턴스화되지 않지만, 항상 모듈 수준의 함수 ``logging.getLogger(name)`` 를 통해주의하십시오. 동일 이름의 :func:`getLogger` 에 대한 복수 호출은 항상 같은 Logger 객체에 대한 참조를 반환합니다."

#: ../Doc/library/logging.rst:58
#, fuzzy
msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for "
"example). Loggers that are further down in the hierarchical list are "
"children of loggers higher up in the list.  For example, given a logger "
"with a name of ``foo``, loggers with names of ``foo.bar``, "
"``foo.bar.baz``, and ``foo.bam`` are all descendants of ``foo``.  The "
"logger name hierarchy is analogous to the Python package hierarchy, and "
"identical to it if you organise your loggers on a per-module basis using "
"the recommended construction ``logging.getLogger(__name__)``.  That's "
"because in a module, ``__name__`` is the module's name in the Python "
"package namespace."
msgstr "``name`` 은 잠재적으로 ``foo.bar.baz`` 와 같이 마침표로 구분 된 계층 적 값입니다 (예를 들어 ``foo`` 라고도 할 수 있습니다). 계층 적 목록에서 더 아래쪽에있는 로거는 목록에서 상위에있는 로거의 하위 항목입니다. 예를 들어, 이름이  ``foo`` 인 로거가 주어지면, ``foo.bar``, ``foo.bar.baz``, 그리고 ``foo.bam`` 의 이름을 가진 로거는 모두 ``foo``. 로거 이름 계층 구조는 Python 패키지 계층 구조와 비슷하며, ``logging.getLogger(__name__)`` 을 사용하여 모듈 단위로 로거를 구성하는 경우와 동일합니다. 왜냐하면 모듈에서 ``__name__`` 은 파이썬 패키지 네임 스페이스의 모듈 이름이기 때문입니다."

#: ../Doc/library/logging.rst:74
#, fuzzy
msgid ""
"If this attribute evaluates to true, events logged to this logger will be"
" passed to the handlers of higher level (ancestor) loggers, in addition "
"to any handlers attached to this logger. Messages are passed directly to "
"the ancestor loggers' handlers - neither the level nor filters of the "
"ancestor loggers in question are considered."
msgstr "이 속성이 true로 평가되면이 로거에 기록 된 이벤트는이 로거에 첨부 된 핸들러뿐 아니라 상위 (상위) 로거의 핸들러로 전달됩니다. 메시지는 조상 로거의 핸들러에 직접 전달됩니다. 문제의 조상 로거의 수준이나 필터는 고려하지 않습니다."

#: ../Doc/library/logging.rst:80
#, fuzzy
msgid ""
"If this evaluates to false, logging messages are not passed to the "
"handlers of ancestor loggers."
msgstr "이 값이 false로 평가되면 로깅 메시지가 상위 로거의 핸들러로 전달되지 않습니다."

#: ../Doc/library/logging.rst:83
#, fuzzy
msgid "The constructor sets this attribute to ``True``."
msgstr "생성자는이 속성을 ``True`` 로 설정합니다."

#: ../Doc/library/logging.rst:85
#, fuzzy
msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, "
"it may emit the same record multiple times. In general, you should not "
"need to attach a handler to more than one logger - if you just attach it "
"to the appropriate logger which is highest in the logger hierarchy, then "
"it will see all events logged by all descendant loggers, provided that "
"their propagate setting is left set to ``True``. A common scenario is to "
"attach handlers only to the root logger, and to let propagation take care"
" of the rest."
msgstr "로거 *및* 하나 이상의 조상에 핸들러를 연결하면 동일한 레코드를 여러 번 내보낼 수 있습니다. 일반적으로, 하나 이상의 로거에 핸들러를 부착 할 필요는 없습니다. 로거 계층에서 가장 높은 적절한 로거에 핸들러를 연결하면 전파 된 모든 로거가 기록한 모든 이벤트를 볼 수 있습니다. 설정은 ``True`` 로 설정되어 있습니다. 일반적인 시나리오는 루트 로거에만 핸들러를 연결하고 전파가 나머지를 처리하도록하는 것입니다."

#: ../Doc/library/logging.rst:96
#, fuzzy
msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are"
" less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or "
"handlers service this logger, unless a handler's level has been set to a "
"higher severity level than *level*."
msgstr "이 로거의 스레숄드를 *level* 로 설정합니다. *level* 보다 덜 심각한 로깅 메시지는 무시됩니다. 심각도 *level* 이상의 로깅 메시지는 핸들러 레벨이 *level* *보다 높은 심각도 레벨로 설정되지 않는 한이 로거를 처리하는 핸들러 또는 핸들러에 의해 생성됩니다."

#: ../Doc/library/logging.rst:101
#, fuzzy
msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which "
"causes all messages to be processed when the logger is the root logger, "
"or delegation to the parent when the logger is a non-root logger). Note "
"that the root logger is created with level :const:`WARNING`."
msgstr "로거가 생성되면, 레벨은 :const:`NOTSET` (로거가 루트 로거 일 때 모든 메시지를 처리하게하거나, 로거가 비 루트 로거 일 때 부모에게 위임)로 설정됩니다. 루트 로거는 level :const:`WARNING` 으로 생성됩니다."

#: ../Doc/library/logging.rst:106
#, fuzzy
msgid ""
"The term 'delegation to the parent' means that if a logger has a level of"
" NOTSET, its chain of ancestor loggers is traversed until either an "
"ancestor with a level other than NOTSET is found, or the root is reached."
msgstr "'부모에게 위임' 이라는 용어는 로거 수준이 NOTSET 인 경우 NOTSET이 아닌 다른 상위 수준이 발견되거나 루트에 도달 할 때까지 상위 조상 로거 체인이 통과 함을 의미합니다."

#: ../Doc/library/logging.rst:110
#, fuzzy
msgid ""
"If an ancestor is found with a level other than NOTSET, then that "
"ancestor's level is treated as the effective level of the logger where "
"the ancestor search began, and is used to determine how a logging event "
"is handled."
msgstr "조상이 NOTSET이 아닌 다른 레벨에서 발견되면 조상의 레벨은 조상 검색이 시작된 로거의 유효 레벨로 간주되어 로깅 이벤트가 처리되는 방식을 결정하는 데 사용됩니다."

#: ../Doc/library/logging.rst:114
#, fuzzy
msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages "
"will be processed. Otherwise, the root's level will be used as the "
"effective level."
msgstr "루트에 도달하고 NOTSET 레벨이 있으면 모든 메시지가 처리됩니다. 그렇지 않으면 루트 레벨이 유효 레벨로 사용됩니다."

#: ../Doc/library/logging.rst:117 ../Doc/library/logging.rst:407
#, fuzzy
msgid "See :ref:`levels` for a list of levels."
msgstr "참조 :ref:`levels` 레벨 목록."

#: ../Doc/library/logging.rst:119
#, fuzzy
msgid ""
"The *level* parameter now accepts a string representation of the level "
"such as 'INFO' as an alternative to the integer constants such as "
":const:`INFO`. Note, however, that levels are internally stored as "
"integers, and methods such as e.g. :meth:`getEffectiveLevel` and "
":meth:`isEnabledFor` will return/expect to be passed integers."
msgstr "*level* 매개 변수는 이제 :const:`INFO` 와 같은 정수 상수 대신 'INFO' 와 같은 레벨의 문자열 표현을 허용합니다. 그러나 레벨은 내부적으로 정수로 저장되며 예 :meth:`getEffectiveLevel` 및 :meth:`isEnabledFor` 와 같은 메서드는 전달 된 정수를 반환하거나 예상합니다."

#: ../Doc/library/logging.rst:129
#, fuzzy
msgid ""
"Indicates if a message of severity *lvl* would be processed by this "
"logger. This method checks first the module-level level set by "
"``logging.disable(lvl)`` and then the logger's effective level as "
"determined by :meth:`getEffectiveLevel`."
msgstr "심각도 *lvl* 의 메시지가 이 로거에서 처리되는지 여부를 나타냅니다. 이 메소드는 먼저 ``logging.disable(lvl)`` 에 의해 설정된 모듈 레벨 레벨을 확인한 다음 :meth:`getEffectiveLevel` 에 의해 결정되는 로거의 유효 레벨을 검사합니다."

#: ../Doc/library/logging.rst:137
#, fuzzy
msgid ""
"Indicates the effective level for this logger. If a value other than "
":const:`NOTSET` has been set using :meth:`setLevel`, it is returned. "
"Otherwise, the hierarchy is traversed towards the root until a value "
"other than :const:`NOTSET` is found, and that value is returned. The "
"value returned is an integer, typically one of :const:`logging.DEBUG`, "
":const:`logging.INFO` etc."
msgstr "이 로거의 유효 수준을 나타냅니다. :meth:`setLevel` 을 사용하여 :const:`NOTSET` 이외의 값이 설정되면, 그 값이 반환됩니다. 그렇지 않으면, 계층 구조는 :const:`NOTSET` 이외의 값이 발견 될 때까지 루트를 향해 탐색되고, 그 값이 리턴됩니다. 반환되는 값은 정수이며 일반적으로 :const:`logging.DEBUG`, :const:`logging.INFO` 중 하나입니다."

#: ../Doc/library/logging.rst:147
#, fuzzy
msgid ""
"Returns a logger which is a descendant to this logger, as determined by "
"the suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would "
"return the same logger as would be returned by "
"``logging.getLogger('abc.def.ghi')``. This is a convenience method, "
"useful when the parent logger is named using e.g. ``__name__`` rather "
"than a literal string."
msgstr "접미사에 의해 결정된대로이 로거의 자손 인 로거를 리턴합니다. 그러므로, ``logging.getLogger('abc').getChild('def.ghi')`` 는 ``logging.getLogger('abc.def.ghi')`` 에 의해 리턴 된 것과 같은 로거를 리턴합니다. 이것은 편리한 방법으로, 부모 로거가 리터럴 문자열이 아닌 예 ``__name__`` 를 사용하여 명명 될 때 유용합니다."

#: ../Doc/library/logging.rst:158
#, fuzzy
msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the"
" message format string, and the *args* are the arguments which are merged"
" into *msg* using the string formatting operator. (Note that this means "
"that you can use keywords in the format string, together with a single "
"dictionary argument.)"
msgstr "이 로거에 level :const:`DEBUG` 메시지를 기록합니다. *msg* 는 메시지 형식 문자열이고 *args* 는 문자열 형식 지정 연산자를 사용하여 *msg* 에 병합되는 인수입니다. (이는 형식 문자열의 키워드를 하나의 사전 인수와 함께 사용할 수 있음을 의미합니다.)"

#: ../Doc/library/logging.rst:163
#, fuzzy
msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, and *extra*."
msgstr "* kwargs *에는 검사 할 키워드 인수가 세 개 있습니다. *exc_info*, *stack_info* 및 *extra*."

#: ../Doc/library/logging.rst:166
#, fuzzy
msgid ""
"If *exc_info* does not evaluate as false, it causes exception information"
" to be added to the logging message. If an exception tuple (in the format"
" returned by :func:`sys.exc_info`) or an exception instance is provided, "
"it is used; otherwise, :func:`sys.exc_info` is called to get the "
"exception information."
msgstr "*exc_info* 가 false로 평가되지 않으면 로깅 메시지에 예외 정보가 추가됩니다. 예외 튜플 (:func:`sys.exc_info` 에 의해 반환 된 형식) 또는 예외 인스턴스가 제공되면 사용됩니다. 그렇지 않으면 :func:`sys.exc_info` 가 예외 정보를 얻기 위해 호출됩니다."

#: ../Doc/library/logging.rst:171 ../Doc/library/logging.rst:937
#, fuzzy
msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former "
"is stack frames from the bottom of the stack up to the logging call in "
"the current thread, whereas the latter is information about stack frames "
"which have been unwound, following an exception, while searching for "
"exception handlers."
msgstr "두 번째 선택적 키워드 인수는 *stack_info* 이며, 기본값은 ``False`` 입니다. true이면 스택 정보가 실제 로깅 호출을 포함하여 로깅 메시지에 추가됩니다. 이것은 *exc_info* 를 지정하여 표시되는 것과 같은 스택 정보가 아닙니다. 전자는 스택의 맨 아래에서 현재 스레드의 로깅 호출까지의 스택 프레임이며, 후자는 스택 스레드에 대한 정보입니다 예외 핸들러를 검색하는 동안 예외 뒤에 풀립니다."

#: ../Doc/library/logging.rst:180 ../Doc/library/logging.rst:946
#, fuzzy
msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just "
"show how you got to a certain point in your code, even when no exceptions"
" were raised. The stack frames are printed following a header line which "
"says:"
msgstr "*exc_info* 와는 독립적으로 *stack_info* 를 지정할 수 있습니다. 예를 들어 예외가 발생하지 않은 경우에도 코드의 특정 지점에 어떻게 도달했는지 보여줄 수 있습니다. 스택 프레임은 다음과 같은 헤더 행 다음에 인쇄됩니다.:"

#: ../Doc/library/logging.rst:188 ../Doc/library/logging.rst:954
#, fuzzy
msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when"
" displaying exception frames."
msgstr "이것은 예외 프레임을 표시 할 때 사용되는 ``Traceback (most recent call last):`` 을 모방합니다."

#: ../Doc/library/logging.rst:191
#, fuzzy
msgid ""
"The third keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the LogRecord "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr "세 번째 키워드 인수는 * extra *로, 사용자 정의 속성을 사용하여 로깅 이벤트 용으로 작성된 LogRecord의 __dict__을 채우는 데 사용되는 사전을 전달하는 데 사용할 수 있습니다. 이러한 사용자 지정 특성은 원하는대로 사용할 수 있습니다. 예를 들어 로그 된 메시지에 통합 될 수 있습니다. 예를 들면 ::"

#: ../Doc/library/logging.rst:203
#, fuzzy
msgid "would print something like"
msgstr "다음과 같은 것을 인쇄 할 것이다."

#: ../Doc/library/logging.rst:209 ../Doc/library/logging.rst:974
#, fuzzy
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the "
"keys used by the logging system. (See the :class:`Formatter` "
"documentation for more information on which keys are used by the logging "
"system.)"
msgstr "*extra* 에 전달 된 사전의 키는 로깅 시스템에서 사용하는 키와 충돌해서는 안됩니다. (어떤 키가 로깅 시스템에 의해 사용되는지에 대한 더 많은 정보는 :class:`Formatter` 문서를보십시오.)"

#: ../Doc/library/logging.rst:213 ../Doc/library/logging.rst:978
#, fuzzy
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the "
":class:`Formatter` has been set up with a format string which expects "
"'clientip' and 'user' in the attribute dictionary of the LogRecord. If "
"these are missing, the message will not be logged because a string "
"formatting exception will occur. So in this case, you always need to pass"
" the *extra* dictionary with these keys."
msgstr "로그 된 메시지에서 이러한 속성을 사용하려면 몇 가지주의를 기울여야합니다. 위의 예에서, 예를 들어, :class:`Formatter` 는 LogRecord의 속성 사전에 'clientip' 과 'user' 가 필요한 형식 문자열로 설정되었습니다. 이러한 문자가없는 경우 문자열 형식화 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서이 경우 *extra* 사전을이 키와 함께 전달해야합니다."

#: ../Doc/library/logging.rst:220 ../Doc/library/logging.rst:985
#, fuzzy
msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise "
"are dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it"
" is likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr "이것은 성가신 일이지만,이 기능은 같은 상황에서 동일한 코드가 실행되는 멀티 스레드 서버와이 컨텍스트에 따라 발생하는 흥미로운 조건 (예 : 원격 클라이언트 IP 주소 및 인증 된 위 예제에서 사용자 이름). 이런 상황에서는 specialize :class:`Formatter` 가 :class:`Handler` 와 함께 사용됩니다."

#: ../Doc/library/logging.rst:227 ../Doc/library/logging.rst:992
#, fuzzy
msgid "The *stack_info* parameter was added."
msgstr "*stack_info* 매개 변수가 추가되었습니다."

#: ../Doc/library/logging.rst:230
#, fuzzy
msgid "The *exc_info* parameter can now accept exception instances."
msgstr "*exc_info* 매개 변수는 이제 예외 인스턴스를 허용 할 수 있습니다."

#: ../Doc/library/logging.rst:236
#, fuzzy
msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are"
" interpreted as for :meth:`debug`."
msgstr "이 로거에 level :const:`INFO` 메시지를 기록합니다. 인수는 :meth:`debug` 로 해석됩니다."

#: ../Doc/library/logging.rst:242
#, fuzzy
msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr "이 로거에 level :const:`WARNING` 메시지를 기록합니다. 인수는 :meth:`debug` 로 해석됩니다."

#: ../Doc/library/logging.rst:245
#, fuzzy
msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr "기능적으로 ``warning`` 와 동일한 구식의 ``warn`` 메서드가 있습니다. ``warn`` 은 더 이상 사용되지 않으므로 사용하지 마십시오 - 대신 ``warning`` 을 사용하십시오."

#: ../Doc/library/logging.rst:251
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr "이 로거에서 level :const:`ERROR` 메시지를 로깅합니다. 인수는 :meth:`debug` 로 해석됩니다."

#: ../Doc/library/logging.rst:257
#, fuzzy
msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments"
" are interpreted as for :meth:`debug`."
msgstr "이 로거에 level :const:`CRITICAL` 메시지를 기록합니다. 인수는 :meth:`debug` 로 해석됩니다."

#: ../Doc/library/logging.rst:263
#, fuzzy
msgid ""
"Logs a message with integer level *lvl* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr "이 로거에 정수 수준 *lvl* 이있는 메시지를 로깅합니다. 다른 인수는 :meth:`debug` 로 해석됩니다."

#: ../Doc/library/logging.rst:269
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments "
"are interpreted as for :meth:`debug`. Exception info is added to the "
"logging message. This method should only be called from an exception "
"handler."
msgstr "이 로거에서 level :const:`ERROR` 메시지를 로깅합니다. 인수는 :meth:`debug` 로 해석됩니다. 예외 정보가 로깅 메시지에 추가됩니다. 이 메서드는 예외 처리기에서만 호출해야합니다."

#: ../Doc/library/logging.rst:276
#, fuzzy
msgid "Adds the specified filter *filter* to this logger."
msgstr "지정된 필터 *filter* 를이 로거에 추가합니다."

#: ../Doc/library/logging.rst:281
#, fuzzy
msgid "Removes the specified filter *filter* from this logger."
msgstr "이 로거에서 지정된 필터 *filter* 를 제거합니다."

#: ../Doc/library/logging.rst:286
#, fuzzy
msgid ""
"Applies this logger's filters to the record and returns a true value if "
"the record is to be processed. The filters are consulted in turn, until "
"one of them returns a false value. If none of them return a false value, "
"the record will be processed (passed to handlers). If one returns a false"
" value, no further processing of the record occurs."
msgstr "이 로거의 필터를 레코드에 적용하고 레코드가 처리 될 경우 true 값을 반환합니다. 필터 중 하나가 거짓 값을 반환 할 때까지 필터는 차례로 참조됩니다. 그 중 아무 것도 거짓 값을 반환하지 않으면 레코드가 처리됩니다 (처리기로 전달됨). 거짓 값을 반환하면 더 이상의 레코드 처리가 발생하지 않습니다."

#: ../Doc/library/logging.rst:295
#, fuzzy
msgid "Adds the specified handler *hdlr* to this logger."
msgstr "지정된 핸들러 *hdlr* 를이 로거에 추가합니다."

#: ../Doc/library/logging.rst:300
#, fuzzy
msgid "Removes the specified handler *hdlr* from this logger."
msgstr "이 로거에서 지정된 핸들러 *hdlr* 을 제거합니다."

#: ../Doc/library/logging.rst:305
#, fuzzy
msgid ""
"Finds the caller's source filename and line number. Returns the filename,"
" line number, function name and stack information as a 4-element tuple. "
"The stack information is returned as ``None`` unless *stack_info* is "
"``True``."
msgstr "호출자의 소스 파일 이름과 행 번호를 찾습니다. 파일 이름, 행 번호, 함수 이름 및 스택 정보를 4 요소 터플로 반환합니다. 스택 정보는 *stack_info* 가 ``True`` 가 아니면 ``None`` 으로 반환됩니다."

#: ../Doc/library/logging.rst:312
#, fuzzy
msgid ""
"Handles a record by passing it to all handlers associated with this "
"logger and its ancestors (until a false value of *propagate* is found). "
"This method is used for unpickled records received from a socket, as well"
" as those created locally. Logger-level filtering is applied using "
":meth:`~Logger.filter`."
msgstr "이 로거와 그 조상과 연관된 모든 핸들러에 레코드를 전달하여 레코드를 처리합니다 (false 값 *propagate* 가 발견 될 때까지). 이 메서드는 소켓에서받은 unpickled 레코드와 로컬로 만든 레코드에 사용됩니다. 로거 레벨 필터링은 :meth:`~Logger.filter` 를 사용하여 적용됩니다."

#: ../Doc/library/logging.rst:320
#, fuzzy
msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr "이 메소드는 특수한 :class:`LogRecord` 인스턴스를 작성하기 위해서 서브 클래스에서 오버라이드 (override) 할 수있는 팩토리 메소드입니다."

#: ../Doc/library/logging.rst:325
#, fuzzy
msgid ""
"Checks to see if this logger has any handlers configured. This is done by"
" looking for handlers in this logger and its parents in the logger "
"hierarchy. Returns ``True`` if a handler was found, else ``False``. The "
"method stops searching up the hierarchy whenever a logger with the "
"'propagate' attribute set to false is found - that will be the last "
"logger which is checked for the existence of handlers."
msgstr "이 로거에 처리기가 구성되어 있는지 확인합니다. 이것은이 로거의 핸들러와 로거 계층의 부모를 찾는 것입니다. 핸들러가 발견되면 ``True`` 를 리턴하고 그렇지 않으면 ``False`` 를 리턴합니다. 이 메소드는 &#39;propagate&#39;속성이 false로 설정된 로거가 발견 될 때마다 계층 구조 검색을 중지합니다. 이는 처리기의 존재 여부를 검사하는 마지막 로거가됩니다."

#: ../Doc/library/logging.rst:334
#, fuzzy
msgid "Loggers can now be pickled and unpickled."
msgstr "이제 로거는 절임 및 언 피클 링이 가능합니다."

#: ../Doc/library/logging.rst:340
#, fuzzy
msgid "Logging Levels"
msgstr "로깅 레벨"

#: ../Doc/library/logging.rst:342
#, fuzzy
msgid ""
"The numeric values of logging levels are given in the following table. "
"These are primarily of interest if you want to define your own levels, "
"and need them to have specific values relative to the predefined levels. "
"If you define a level with the same numeric value, it overwrites the "
"predefined value; the predefined name is lost."
msgstr "로깅 수준의 숫자 값은 다음 표에 나와 있습니다. 이것은 자신의 레벨을 정의하고 사전 정의 된 레벨과 관련된 특정 값을 갖도록하려는 경우 주로 관심의 대상입니다. 동일한 숫자 값을 가진 레벨을 정의하면 미리 정의 된 값을 덮어 씁니다. 사전 정의 된 이름이 유실됩니다."

#: ../Doc/library/logging.rst:349
#, fuzzy
msgid "Level"
msgstr "수평"

#: ../Doc/library/logging.rst:349
#, fuzzy
msgid "Numeric value"
msgstr "숫자 값"

#: ../Doc/library/logging.rst:351
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../Doc/library/logging.rst:351
msgid "50"
msgstr "50"

#: ../Doc/library/logging.rst:353
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../Doc/library/logging.rst:353
msgid "40"
msgstr "40"

#: ../Doc/library/logging.rst:355
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../Doc/library/logging.rst:355
msgid "30"
msgstr "30"

#: ../Doc/library/logging.rst:357
msgid "``INFO``"
msgstr "``INFO``"

#: ../Doc/library/logging.rst:357
msgid "20"
msgstr "20"

#: ../Doc/library/logging.rst:359
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../Doc/library/logging.rst:359
msgid "10"
msgstr "10"

#: ../Doc/library/logging.rst:361
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../Doc/library/logging.rst:361
msgid "0"
msgstr "0"

#: ../Doc/library/logging.rst:368
#, fuzzy
msgid "Handler Objects"
msgstr "핸들러 객체"

#: ../Doc/library/logging.rst:370
#, fuzzy
msgid ""
"Handlers have the following attributes and methods. Note that "
":class:`Handler` is never instantiated directly; this class acts as a "
"base for more useful subclasses. However, the :meth:`__init__` method in "
"subclasses needs to call :meth:`Handler.__init__`."
msgstr "핸들러에는 다음과 같은 특성과 메소드가 있습니다. 클래스 :`Handler`는 절대로 직접 인스턴스화되지 않습니다. 이 클래스는보다 유용한 서브 클래스의 기반이됩니다. 그러나, 서브 클래스에서 :meth:`__init__` 메쏘드는 :meth:`Handler.__init__` 을 호출해야합니다."

#: ../Doc/library/logging.rst:379
#, fuzzy
msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting "
"the list of filters to the empty list and creating a lock (using "
":meth:`createLock`) for serializing access to an I/O mechanism."
msgstr "레벨을 설정하고 필터 목록을 빈리스트로 설정하고 I / O 메커니즘에 대한 액세스를 직렬화하기 위해 (:meth:`createLock` 을 사용하여) 잠금을 생성함으로써 :class:`Handler` 인스턴스를 초기화합니다."

#: ../Doc/library/logging.rst:386
#, fuzzy
msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr "스레드 세이브가 아닌 기본 I / O 기능에 대한 액세스를 직렬화하는 데 사용할 수있는 스레드 잠금을 초기화합니다."

#: ../Doc/library/logging.rst:392
#, fuzzy
msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr ":meth:`createLock` 로 생성 된 스레드 잠금을 가져옵니다."

#: ../Doc/library/logging.rst:397
#, fuzzy
msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr ":meth:`acquire` 로 획득 한 스레드 잠금을 해제합니다."

#: ../Doc/library/logging.rst:402
#, fuzzy
msgid ""
"Sets the threshold for this handler to *level*. Logging messages which "
"are less severe than *level* will be ignored. When a handler is created, "
"the level is set to :const:`NOTSET` (which causes all messages to be "
"processed)."
msgstr "이 핸들러의 스레숄드를 *level* 로 설정합니다. *level* 보다 덜 심각한 로깅 메시지는 무시됩니다. 핸들러가 생성되면, 레벨은 :const:`NOTSET` (모든 메시지가 처리되게 함)으로 설정됩니다."

#: ../Doc/library/logging.rst:409
#, fuzzy
msgid ""
"The *level* parameter now accepts a string representation of the level "
"such as 'INFO' as an alternative to the integer constants such as "
":const:`INFO`."
msgstr "*level* 매개 변수는 이제 :const:`INFO` 와 같은 정수 상수 대신 'INFO' 와 같은 레벨의 문자열 표현을 허용합니다."

#: ../Doc/library/logging.rst:417
#, fuzzy
msgid "Sets the :class:`Formatter` for this handler to *fmt*."
msgstr "이 핸들러의 :class:`Formatter` 를 *fmt* 로 설정합니다."

#: ../Doc/library/logging.rst:422
#, fuzzy
msgid "Adds the specified filter *filter* to this handler."
msgstr "지정된 필터 *filter* 를이 처리기에 추가합니다."

#: ../Doc/library/logging.rst:427
#, fuzzy
msgid "Removes the specified filter *filter* from this handler."
msgstr "이 핸들러로부터, 지정된 필터 *filter* 를 삭제합니다."

#: ../Doc/library/logging.rst:432
#, fuzzy
msgid ""
"Applies this handler's filters to the record and returns a true value if "
"the record is to be processed. The filters are consulted in turn, until "
"one of them returns a false value. If none of them return a false value, "
"the record will be emitted. If one returns a false value, the handler "
"will not emit the record."
msgstr "이 핸들러의 필터를 레코드에 적용하고 레코드가 처리 될 경우 true 값을 반환합니다. 필터 중 하나가 거짓 값을 반환 할 때까지 필터는 차례로 참조됩니다. 그 중 아무 것도 거짓 값을 반환하지 않으면 레코드가 방출됩니다. false 값을 반환하면 처리기에서 레코드를 방출하지 않습니다."

#: ../Doc/library/logging.rst:441
#, fuzzy
msgid ""
"Ensure all logging output has been flushed. This version does nothing and"
" is intended to be implemented by subclasses."
msgstr "모든 로그 출력이 플러시되었는지 확인하십시오. 이 버전은 아무 것도하지 않으며 하위 클래스로 구현됩니다."

#: ../Doc/library/logging.rst:447
#, fuzzy
msgid ""
"Tidy up any resources used by the handler. This version does no output "
"but removes the handler from an internal list of handlers which is closed"
" when :func:`shutdown` is called. Subclasses should ensure that this gets"
" called from overridden :meth:`close` methods."
msgstr "핸들러가 사용하는 리소스를 정리하십시오. 이 버전은 출력을하지 않지만 :func:`shutdown` 이 호출 될 때 닫히는 핸들러의 내부 목록에서 핸들러를 제거합니다. 서브 클래스는 이것이 overridden :meth:`close` 메소드로부터 호출되도록해야합니다."

#: ../Doc/library/logging.rst:455
#, fuzzy
msgid ""
"Conditionally emits the specified logging record, depending on filters "
"which may have been added to the handler. Wraps the actual emission of "
"the record with acquisition/release of the I/O thread lock."
msgstr "처리기에 추가되었을 수있는 필터에 따라 조건부로 지정된 로깅 레코드를 내 보냅니다. 레코드의 실제 방출을 I / O 스레드 잠금 획득 / 해제와 함께 래핑합니다."

#: ../Doc/library/logging.rst:462
#, fuzzy
msgid ""
"This method should be called from handlers when an exception is "
"encountered during an :meth:`emit` call. If the module-level attribute "
"``raiseExceptions`` is ``False``, exceptions get silently ignored. This "
"is what is mostly wanted for a logging system - most users will not care "
"about errors in the logging system, they are more interested in "
"application errors. You could, however, replace this with a custom "
"handler if you wish. The specified record is the one which was being "
"processed when the exception occurred. (The default value of "
"``raiseExceptions`` is ``True``, as that is more useful during "
"development)."
msgstr "이 메소드는 :meth:`emit` 호출 중에 예외가 발생할 때 핸들러에서 호출되어야합니다. 모듈 레벨 속성 ``raiseExceptions`` 가 ``False`` 인 경우 예외는 무시됩니다. 이것은 대부분 로깅 시스템에 필요합니다. 대부분의 사용자는 로깅 시스템의 오류를 신경 쓰지 않고 응용 프로그램 오류에 더 관심이 있습니다. 그러나 원하는 경우 사용자 지정 처리기로 바꿀 수 있습니다. 지정된 레코드는 예외가 발생할 때 처리되고 있던 레코드입니다. (``raiseExceptions`` 의 기본값은 ``True`` 입니다. 개발 중에 더 유용합니다)."

#: ../Doc/library/logging.rst:475
#, fuzzy
msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, "
"use the default formatter for the module."
msgstr "레코드에 대해 포맷팅 - 포맷터가 설정된 경우 사용하십시오. 그렇지 않으면 모듈에 대한 기본 포맷터를 사용하십시오."

#: ../Doc/library/logging.rst:481
#, fuzzy
msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a "
":exc:`NotImplementedError`."
msgstr "지정된 로깅 레코드를 실제로 로깅하는 데 필요한 작업을 수행하십시오. 이 버전은 서브 클래스에 의해 구현되기 위해 :exc:`NotImplementedError` 를 발생시킵니다."

#: ../Doc/library/logging.rst:485
#, fuzzy
msgid "For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr "표준으로 포함 된 핸들러 목록은 :mod:`logging.handlers` 를 참조하십시오."

#: ../Doc/library/logging.rst:490
#, fuzzy
msgid "Formatter Objects"
msgstr "포매터 객체"

#: ../Doc/library/logging.rst:494
#, python-format, fuzzy
msgid ""
":class:`Formatter` objects have the following attributes and methods. "
"They are responsible for converting a :class:`LogRecord` to (usually) a "
"string which can be interpreted by either a human or an external system. "
"The base :class:`Formatter` allows a formatting string to be specified. "
"If none is supplied, the default value of ``'%(message)s'`` is used, "
"which just includes the message in the logging call. To have additional "
"items of information in the formatted output (such as a timestamp), keep "
"reading."
msgstr ":class:`Formatter` 객체는 다음과 같은 속성과 메소드를 가지고 있습니다. 이들은 :class:`LogRecord` 를 인간이나 외부 시스템이 해석 할 수있는 문자열로 변환하는 역할을합니다. base :class:`Formatter` 는 서식 지정 문자열을 지정할 수있게합니다. 아무 것도 지정하지 않으면 ``'%(message)s'`` 의 기본값이 사용됩니다. 단지 로깅 호출에 메시지 만 포함됩니다. 서식이 지정된 출력 (예 : 시간 소인)에 추가 정보를 가지려면 계속해서 읽으십시오."

#: ../Doc/library/logging.rst:502
#, python-format, fuzzy
msgid ""
"A Formatter can be initialized with a format string which makes use of "
"knowledge of the :class:`LogRecord` attributes - such as the default "
"value mentioned above making use of the fact that the user's message and "
"arguments are pre-formatted into a :class:`LogRecord`'s *message* "
"attribute.  This format string contains standard Python %-style mapping "
"keys. See section :ref:`old-string-formatting` for more information on "
"string formatting."
msgstr "Formatter는 :class:`LogRecord` 속성에 대한 지식을 사용하는 포맷 문자열로 초기화 될 수 있습니다 - 위에서 언급 한 디폴트 값과 같이 사용자의 메시지와 인수는 미리 로 형식화되어 있습니다 :class:`LogRecord` 의 *message* 속성. 이 형식 문자열은 표준 Python %-스타일 매핑 키를 포함합니다. 문자열 포맷팅에 대한 더 많은 정보는 See section :ref:`old-string-formatting`."

#: ../Doc/library/logging.rst:509
#, fuzzy
msgid ""
"The useful mapping keys in a :class:`LogRecord` are given in the section "
"on :ref:`logrecord-attributes`."
msgstr ":class:`LogRecord` 의 유용한 매핑 키는 :ref:`logrecord-attributes` 섹션에 있습니다."

#: ../Doc/library/logging.rst:515
#, python-format, fuzzy
msgid ""
"Returns a new instance of the :class:`Formatter` class.  The instance is "
"initialized with a format string for the message as a whole, as well as a"
" format string for the date/time portion of a message.  If no *fmt* is "
"specified, ``'%(message)s'`` is used.  If no *datefmt* is specified, a "
"format is used which is described in the :meth:`formatTime` "
"documentation."
msgstr ":class:`Formatter` 클래스의 새로운 인스턴스를 리턴합니다. 인스턴스는 전체 메시지의 형식 문자열과 메시지의 날짜 / 시간 부분에 대한 형식 문자열로 초기화됩니다. *fmt* 가 지정되지 않으면 ``'%(message)s'`` 가 사용됩니다. *datefmt* 가 지정되지 않으면 :meth:`formatTime` 문서에 설명 된 형식이 사용됩니다."

#: ../Doc/library/logging.rst:521
#, python-format, fuzzy
msgid ""
"The *style* parameter can be one of '%', '{' or '$' and determines how "
"the format string will be merged with its data: using one of "
"%-formatting, :meth:`str.format` or :class:`string.Template`. See :ref"
":`formatting-styles` for more information on using {- and $-formatting "
"for log messages."
msgstr "*style* 매개 변수는 '%', '{' 또는 '$' 중 하나 일 수 있으며 형식 문자열이 데이터와 병합되는 방식을 결정합니다. %-formatting, :meth:`str.format` 또는 :class:`string.Template`. 로그 메시지에 {- and $-formatting을 사용하는 방법에 대한 자세한 내용은 :ref:`formatting-styles` 을 참조하십시오."

#: ../Doc/library/logging.rst:526
#, fuzzy
msgid "The *style* parameter was added."
msgstr "*style* 매개 변수가 추가되었습니다."

#: ../Doc/library/logging.rst:532
#, fuzzy
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the"
" dictionary, a couple of preparatory steps are carried out. The *message*"
" attribute of the record is computed using *msg* % *args*. If the "
"formatting string contains ``'(asctime)'``, :meth:`formatTime` is called "
"to format the event time. If there is exception information, it is "
"formatted using :meth:`formatException` and appended to the message. Note"
" that the formatted exception information is cached in attribute "
"*exc_text*. This is useful because the exception information can be "
"pickled and sent across the wire, but you should be careful if you have "
"more than one :class:`Formatter` subclass which customizes the formatting"
" of exception information. In this case, you will have to clear the "
"cached value after a formatter has done its formatting, so that the next "
"formatter to handle the event doesn't use the cached value but "
"recalculates it afresh."
msgstr "레코드의 속성 사전은 문자열 형식화 작업의 피연산자로 사용됩니다. 결과 문자열을 반환합니다. 사전을 포맷하기 전에 몇 가지 준비 단계가 수행됩니다. 레코드의 *message* 속성은 *msg* % *args* 를 사용하여 계산됩니다. 형식화 문자열에 ``'(asctime)'`` 이 들어 있으면 :meth:`formatTime` 이 호출되어 이벤트 시간을 형식화합니다. 예외 정보가있는 경우 :meth:`formatException` 을 사용하여 형식화되고 메시지에 추가됩니다. 형식화 된 예외 정보는 *exc_text* 속성에 캐시됩니다. 이것은 유익한 정보가 훔쳐서 전선을 통해 전송 될 수 있기 때문에 유용하지만 예외 정보의 형식을 사용자 정의하는 :class:`Formatter` 서브 클래스가 두 개 이상있는 경우주의해야합니다. 이 경우 포매터가 포맷을 완료 한 후 캐시 된 값을 지워야하므로 이벤트를 처리 할 다음 포맷터는 캐시 된 값을 사용하지 않고 새로 계산됩니다."

#: ../Doc/library/logging.rst:548
#, fuzzy
msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr "스택 정보를 사용할 수있는 경우 예외 정보 뒤에 추가됩니다. 필요할 경우 :meth:`formatStack` 을 사용하여 변환합니다."

#: ../Doc/library/logging.rst:554
#, python-format, fuzzy
msgid ""
"This method should be called from :meth:`format` by a formatter which "
"wants to make use of a formatted time. This method can be overridden in "
"formatters to provide for any specific requirement, but the basic "
"behavior is as follows: if *datefmt* (a string) is specified, it is used "
"with :func:`time.strftime` to format the creation time of the record. "
"Otherwise, the format '%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part"
" is a millisecond value and the other letters are as per the "
":func:`time.strftime` documentation.  An example time in this format is "
"``2003-01-23 00:29:50,411``.  The resulting string is returned."
msgstr "이 메소드는 형식화 된 시간을 사용하려는 포맷터에 의해 :meth:`format` 에서 호출되어야합니다. 이 메소드는 특정 요구 사항을 제공하기 위해 포맷터에서 재정의 될 수 있지만 기본 동작은 다음과 같습니다. if *datefmt* (문자열)이 지정된 경우 :func:`time.strftime` 과 함께 사용하여 생성 시간을 형식화합니다 기록의. 그렇지 않으면 '%Y-%m-%d %H:%M:%S,uuu' 형식이 사용됩니다. 여기서 uuu 부분은 밀리 초 값이고 다른 문자는 :func:`time.strftime` 문서. 이 형식의 예제 시간은 ``2003-01-23 00:29:50,411`` 입니다. 결과 문자열이 반환됩니다."

#: ../Doc/library/logging.rst:564
#, fuzzy
msgid ""
"This function uses a user-configurable function to convert the creation "
"time to a tuple. By default, :func:`time.localtime` is used; to change "
"this for a particular formatter instance, set the ``converter`` attribute"
" to a function with the same signature as :func:`time.localtime` or "
":func:`time.gmtime`. To change it for all formatters, for example if you "
"want all logging times to be shown in GMT, set the ``converter`` "
"attribute in the ``Formatter`` class."
msgstr "이 함수는 사용자가 구성 할 수있는 함수를 사용하여 생성 시간을 튜플로 변환합니다. 기본적으로 :func:`time.localtime` 이 사용됩니다; 특정 포매터 인스턴스에서이를 변경하려면 ``converter`` 속성을 :func:`time.localtime` 또는 :func:`time.gmtime` 과 같은 서명을 가진 함수로 설정하십시오. 예를 들어 모든 로깅 시간을 GMT로 표시하려면 모든 포맷터를 변경하려면 ``Formatter`` 클래스에 ``converter`` 속성을 설정하십시오."

#: ../Doc/library/logging.rst:572
#, python-format, fuzzy
msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by"
" a strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after "
"the comma is a millisecond value. Because strptime does not have a format"
" placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings"
" have been hardcoded into this method. With the change, these strings are"
" defined as class-level attributes which can be overridden at the "
"instance level when desired. The names of the attributes are "
"``default_time_format`` (for the strptime format string) and "
"``default_msec_format`` (for appending the millisecond value)."
msgstr "이전에 기본 형식은 다음과 같이 하드 코딩되었습니다. ``2010-09-06 22:38:15,292`` 쉼표 앞에있는 부분은 strptime 형식 문자열 (``'%Y-%m-%d %H:%M:%S'``)이며 쉼표 뒤의 부분은 밀리 초 값입니다. strptime에는 밀리 초 동안 형식 자리 표시자가 없기 때문에 밀리 초 값은 다른 형식 문자열 인 ``'%s,%03d'`` 을 사용하여 추가되며 ---이 형식 문자열은 모두이 메소드에 하드 코드되었습니다. 이 문자열을 변경하면 원하는 경우 인스턴스 수준에서 재정의 할 수있는 클래스 수준 특성으로 정의됩니다. 속성 이름은 ``default_time_format`` (strptime 형식 문자열 용)과 ``default_msec_format`` (밀리 초 값 추가 용)입니다."

#: ../Doc/library/logging.rst:587
#, fuzzy
msgid ""
"Formats the specified exception information (a standard exception tuple "
"as returned by :func:`sys.exc_info`) as a string. This default "
"implementation just uses :func:`traceback.print_exception`. The resulting"
" string is returned."
msgstr "지정된 예외 정보 (:func:`sys.exc_info` 에 의해 반환 된 표준 예외 튜플)를 문자열로 형식화합니다. 이 기본 구현은 :func:`traceback.print_exception` 을 사용합니다. 결과 문자열이 반환됩니다."

#: ../Doc/library/logging.rst:594
#, fuzzy
msgid ""
"Formats the specified stack information (a string as returned by "
":func:`traceback.print_stack`, but with the last newline removed) as a "
"string. This default implementation just returns the input value."
msgstr "지정된 스택 정보 (:func:`traceback.print_stack` 에 의해 반환 된 문자열이지만 마지막 줄 바꿈이 제거 된 문자열)을 문자열로 형식화합니다. 이 기본 구현은 입력 값을 반환합니다."

#: ../Doc/library/logging.rst:601
#, fuzzy
msgid "Filter Objects"
msgstr "필터 개체"

#: ../Doc/library/logging.rst:603
#, fuzzy
msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class"
" only allows events which are below a certain point in the logger "
"hierarchy. For example, a filter initialized with 'A.B' will allow events"
" logged by loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not "
"'A.BB', 'B.A.B' etc. If initialized with the empty string, all events are"
" passed."
msgstr "``Filters`` 는 ``Handlers`` 와 ``Loggers`` 에서 레벨에 의해 제공되는 것보다 더 정교한 필터링을 위해 사용될 수 있습니다. 기본 필터 클래스는 로그 작성기 계층 구조의 특정 지점 아래에있는 이벤트 만 허용합니다. 예를 들어 'A.B' 로 초기화 된 필터는 로거 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' 등으로 기록 된 이벤트를 허용하지만 'A.BB', 'B.A.B' 등은 기록 할 수 없습니다. 빈 문자열을 사용하면 모든 이벤트가 전달됩니다."

#: ../Doc/library/logging.rst:613
#, fuzzy
msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified,"
" it names a logger which, together with its children, will have its "
"events allowed through the filter. If *name* is the empty string, allows "
"every event."
msgstr ":class:`Filter` 클래스의 인스턴스를 리턴합니다.*name* 을 지정하면 (자), 그 아이와 함께 필터를 개입시켜 이벤트가 허가되는 로거의 이름을 지정합니다. *name* 이 빈 문자열이면 모든 이벤트를 허용합니다."

#: ../Doc/library/logging.rst:620
#, fuzzy
msgid ""
"Is the specified record to be logged? Returns zero for no, nonzero for "
"yes. If deemed appropriate, the record may be modified in-place by this "
"method."
msgstr "지정된 레코드가 기록됩니까? no의 경우 0을 반환하고 yes의 경우 0이 아닌 값을 반환합니다. 적절하다고 판단되면이 방법으로 해당 레코드를 수정할 수 있습니다."

#: ../Doc/library/logging.rst:624
#, fuzzy
msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted"
" whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have "
"been generated by descendant loggers will not be filtered by a logger's "
"filter setting, unless the filter has also been applied to those "
"descendant loggers."
msgstr "핸들러에 첨부 된 필터는 이벤트가 핸들러에 의해 방출되기 전에 참조되며, 이벤트가 로깅 될 때마다 (:meth:`debug`, :meth:`info` 등), 전에 핸들러에게 이벤트를 보냅니다. 즉, 자손 로거에 의해 생성 된 이벤트는 필터가 해당 자손 로거에도 적용되지 않은 경우 로거의 필터 설정에 의해 필터링되지 않습니다."

#: ../Doc/library/logging.rst:631
#, fuzzy
msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance"
" which has a ``filter`` method with the same semantics."
msgstr "실제로 ``Filter`` 를 하위 클래스화할 필요는 없습니다 : 동일한 의미론을 가진 ``filter`` 메소드를 가진 인스턴스를 전달할 수 있습니다."

#: ../Doc/library/logging.rst:634
#, fuzzy
msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other "
"callable) as a filter. The filtering logic will check to see if the "
"filter object has a ``filter`` attribute: if it does, it's assumed to be "
"a ``Filter`` and its :meth:`~Filter.filter` method is called. Otherwise, "
"it's assumed to be a callable and called with the record as the single "
"parameter. The returned value should conform to that returned by "
":meth:`~Filter.filter`."
msgstr "특수한 ``Filter`` 클래스를 만들거나 ``filter`` 메서드로 다른 클래스를 사용할 필요가 없습니다 : 함수 (또는 다른 호출 가능 함수)를 필터로 사용할 수 있습니다. 필터링 로직은 필터 객체가 ``filter`` 속성을 가지고 있는지 확인합니다 : 만약 있다면 필터는 ``Filter`` 라고 가정하고 :meth:`~Filter.filter` 메소드가 호출됩니다. 그렇지 않으면 호출 가능하다고 가정하고 레코드를 단일 매개 변수로 호출합니다. 반환 된 값은 :meth:`~Filter.filter` 에 의해 반환 된 값과 일치해야합니다."

#: ../Doc/library/logging.rst:644
#, fuzzy
msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is"
" processed by the handler or logger they're attached to: this can be "
"useful if you want to do things like counting how many records were "
"processed by a particular logger or handler, or adding, changing or "
"removing attributes in the LogRecord being processed. Obviously changing "
"the LogRecord needs to be done with some care, but it does allow the "
"injection of contextual information into logs (see :ref:`filters-"
"contextual`)."
msgstr "필터는 주로 레벨보다 정교한 기준에 따라 레코드를 필터링하는 데 주로 사용되지만 첨부 된 처리기 또는 로거에서 처리되는 모든 레코드를 볼 수 있습니다.이 방법은 얼마나 많은 레코드를 계산할지와 같은 작업을 수행하려는 경우 유용 할 수 있습니다 레코드는 특정 로거 또는 핸들러에서 처리되거나 처리중인 LogRecord에서 속성을 추가, 변경 또는 제거합니다. 분명히 LogRecord를 변경하는 것은주의를 기울여야 할 필요가 있지만 로그에 문맥 정보를 주입하는 것을 허용합니다 (:ref:`filters-contextual`)."

#: ../Doc/library/logging.rst:656
#, fuzzy
msgid "LogRecord Objects"
msgstr "LogRecord 객체"

#: ../Doc/library/logging.rst:658
#, fuzzy
msgid ""
":class:`LogRecord` instances are created automatically by the "
":class:`Logger` every time something is logged, and can be created "
"manually via :func:`makeLogRecord` (for example, from a pickled event "
"received over the wire)."
msgstr ":class:`LogRecord` 인스턴스는 어떤 것이 로깅 될 때마다 :class:`Logger` 에 의해 자동적으로 생성되며 :func:`makeLogRecord` 를 통해 수동으로 생성 될 수 있습니다 (예 : 전선을 통해 수신 된 절임 된 이벤트로부터)."

#: ../Doc/library/logging.rst:666
#, fuzzy
msgid "Contains all the information pertinent to the event being logged."
msgstr "기록되는 이벤트와 관련된 모든 정보를 포함합니다."

#: ../Doc/library/logging.rst:668
#, fuzzy
msgid ""
"The primary information is passed in :attr:`msg` and :attr:`args`, which "
"are combined using ``msg % args`` to create the :attr:`message` field of "
"the record."
msgstr "주요 정보는 :attr:`msg` 과 :attr:`args` 에 전달되며, ``msg % args`` 를 사용하여 결합되어 레코드의 :attr:`message` 필드를 생성합니다."

#: ../Doc/library/logging.rst
#, fuzzy
msgid "Parameters"
msgstr "매개 변수"

#: ../Doc/library/logging.rst:672
#, fuzzy
msgid ""
"The name of the logger used to log the event represented by this "
"LogRecord. Note that this name will always have this value, even though "
"it may be emitted by a handler attached to a different (ancestor) logger."
msgstr "이 LogRecord가 나타내는 이벤트의 로그에 사용되는 로그의 이름입니다. 이 이름은 다른 (조상) 로거에 첨부 된 핸들러에 의해 방출 될 수 있더라도 항상이 값을 갖습니다."

#: ../Doc/library/logging.rst:676
#, fuzzy
msgid ""
"The numeric level of the logging event (one of DEBUG, INFO etc.) Note "
"that this is converted to *two* attributes of the LogRecord: ``levelno`` "
"for the numeric value and ``levelname`` for the corresponding level name."
msgstr "로깅 이벤트의 숫자 레벨 (DEBUG, INFO 등) 숫자 값에 대한 LogRecord :``levelno`` 와 해당 레벨 이름에 대한 ``levelname`` 의 *두* 속성으로 변환됩니다 ."

#: ../Doc/library/logging.rst:680
#, fuzzy
msgid "The full pathname of the source file where the logging call was made."
msgstr "로깅 호출이 발생한 소스 파일의 전체 경로 이름입니다."

#: ../Doc/library/logging.rst:682
#, fuzzy
msgid "The line number in the source file where the logging call was made."
msgstr "로깅 호출이 발생한 소스 파일의 행 번호."

#: ../Doc/library/logging.rst:684
#, fuzzy
msgid ""
"The event description message, possibly a format string with placeholders"
" for variable data."
msgstr "이벤트 설명 메시지입니다. 가변 데이터에 대한 자리 표시자가있는 형식 문자열 일 수 있습니다."

#: ../Doc/library/logging.rst:686
#, fuzzy
msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr "이벤트 설명을 얻기 위해 *msg* 인수에 병합 할 변수 데이터."

#: ../Doc/library/logging.rst:688
#, fuzzy
msgid ""
"An exception tuple with the current exception information, or ``None`` if"
" no exception information is available."
msgstr "현재의 예외 정보를 가지는 예외 튜플. 예외 정보가없는 경우는 ``None`` 입니다."

#: ../Doc/library/logging.rst:690
#, fuzzy
msgid ""
"The name of the function or method from which the logging call was "
"invoked."
msgstr "로깅 호출이 호출 된 함수 또는 메서드의 이름입니다."

#: ../Doc/library/logging.rst:692
#, fuzzy
msgid ""
"A text string representing stack information from the base of the stack "
"in the current thread, up to the logging call."
msgstr "로깅 호출까지 현재 스레드의 스택 기본 정보를 나타내는 텍스트 문자열입니다."

#: ../Doc/library/logging.rst:697
#, fuzzy
msgid ""
"Returns the message for this :class:`LogRecord` instance after merging "
"any user-supplied arguments with the message. If the user-supplied "
"message argument to the logging call is not a string, :func:`str` is "
"called on it to convert it to a string. This allows use of user-defined "
"classes as messages, whose ``__str__`` method can return the actual "
"format string to be used."
msgstr "사용자가 제공 한 인수를 메시지와 병합 한 후 this :class:`LogRecord` 인스턴스에 대한 메시지를 리턴합니다. 로깅 호출에 대한 사용자 제공 메시지 인수가 문자열이 아닌 경우 :func:`str` 이 호출되어 문자열로 변환됩니다. 이렇게하면 사용자 정의 클래스를 메시지로 사용할 수 있으며, ``__str__`` 메소드는 사용할 실제 형식 문자열을 반환 할 수 있습니다."

#: ../Doc/library/logging.rst:704
#, fuzzy
msgid ""
"The creation of a ``LogRecord`` has been made more configurable by "
"providing a factory which is used to create the record. The factory can "
"be set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` "
"(see this for the factory's signature)."
msgstr "``LogRecord`` 의 생성은 레코드를 생성하는 데 사용되는 팩토리를 제공함으로써 더 구성 가능하게되었습니다. 팩토리는 :func:`getLogRecordFactory` 와 :func:`setLogRecordFactory` 를 사용하여 설정할 수 있습니다 (팩토리의 서명은이 부분을 참조하십시오)."

#: ../Doc/library/logging.rst:710
#, fuzzy
msgid ""
"This functionality can be used to inject your own values into a LogRecord"
" at creation time. You can use the following pattern::"
msgstr "이 기능은, 작성시에 독자적인 값을 LogRecord에 주입하기 위해서 사용할 수 있습니다. 다음과 같은 패턴을 사용할 수 있습니다 ::"

#: ../Doc/library/logging.rst:722
#, fuzzy
msgid ""
"With this pattern, multiple factories could be chained, and as long as "
"they don't overwrite each other's attributes or unintentionally overwrite"
" the standard attributes listed above, there should be no surprises."
msgstr "이 패턴을 사용하면 여러 팩터 리를 체인으로 묶을 수 있으며, 서로의 속성을 덮어 쓰지 않거나 위에서 언급 한 표준 속성을 실수로 덮어 쓰지 않는 한 놀라움이 없어야합니다."

#: ../Doc/library/logging.rst:731
#, fuzzy
msgid "LogRecord attributes"
msgstr "LogRecord 속성"

#: ../Doc/library/logging.rst:733
#, python-format, fuzzy
msgid ""
"The LogRecord has a number of attributes, most of which are derived from "
"the parameters to the constructor. (Note that the names do not always "
"correspond exactly between the LogRecord constructor parameters and the "
"LogRecord attributes.) These attributes can be used to merge data from "
"the record into the format string. The following table lists (in "
"alphabetical order) the attribute names, their meanings and the "
"corresponding placeholder in a %-style format string."
msgstr "LogRecord에는 많은 속성이 있으며, 대부분 속성은 생성자에 대한 매개 변수에서 파생됩니다. 이름은 LogRecord 생성자 매개 변수와 LogRecord 속성 사이에서 항상 정확하게 일치하는 것은 아닙니다. 이러한 속성을 사용하여 레코드의 데이터를 형식 문자열로 병합 할 수 있습니다. 다음 표는 속성 이름, 의미 및 해당 자리 표시자를 % 스타일 서식 문자열로 (알파벳 순서로) 나열합니다."

#: ../Doc/library/logging.rst:741
#, fuzzy
msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use "
"``{attrname}`` as the placeholder in the format string. If you are using "
"$-formatting (:class:`string.Template`), use the form ``${attrname}``. In"
" both cases, of course, replace ``attrname`` with the actual attribute "
"name you want to use."
msgstr "{} -formatting (:func:`str.format`)을 사용한다면 ``{attrname}`` 을 형식 문자열의 자리 표시 자로 사용할 수 있습니다. $ -formatting (:class:`string.Template`)을 사용하고 있다면 ``${attrname}`` 형식을 사용하십시오. 두 경우 모두 ``attrname`` 을 사용하려는 실제 속성 이름으로 대체하십시오."

#: ../Doc/library/logging.rst:747
#, fuzzy
msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing"
" them after the attribute name, separated from it with a colon. For "
"example: a placeholder of ``{msecs:03d}`` would format a millisecond "
"value of ``4`` as ``004``. Refer to the :meth:`str.format` documentation "
"for full details on the options available to you."
msgstr "{} - 형식화의 경우, 속성 이름 다음에 콜론 (:)으로 구분하여 서식 플래그를 배치하여 형식화 플래그를 지정할 수 있습니다. 예를 들어, ``{msecs:03d}`` 의 자리 표시자는 밀리 초 값을 ``4`` 로, ``004`` 로 나타냅니다. 사용할 수있는 옵션에 대한 자세한 내용은 :meth:`str.format` 문서를 참조하십시오."

#: ../Doc/library/logging.rst:754
#, fuzzy
msgid "Attribute name"
msgstr "속성 이름"

#: ../Doc/library/logging.rst:754 ../Doc/library/logging.rst:1130
#, fuzzy
msgid "Format"
msgstr "체재"

#: ../Doc/library/logging.rst:754 ../Doc/library/logging.rst:1130
#, fuzzy
msgid "Description"
msgstr "기술"

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:756
msgid "args"
msgstr "args"

#: ../Doc/library/logging.rst:756 ../Doc/library/logging.rst:770
#: ../Doc/library/logging.rst:798 ../Doc/library/logging.rst:816
#, fuzzy
msgid "You shouldn't need to format this yourself."
msgstr "직접 서식을 지정할 필요는 없습니다."

#: ../Doc/library/logging.rst:756
#, fuzzy
msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a "
"dict whose values are used for the merge (when there is only one "
"argument, and it is a dictionary)."
msgstr "인수의 튜플은 ``message`` 를 생성하기 위해 ``msg`` 에 병합되거나 병합을 위해 값이 사용되는 dict (인수가 하나 뿐이며 사전입니다)."

#: ../Doc/library/logging.rst:761
msgid "asctime"
msgstr "asctime"

#: ../Doc/library/logging.rst:761
#, python-format
msgid "``%(asctime)s``"
msgstr "``%(asctime)s``"

#: ../Doc/library/logging.rst:761
#, fuzzy
msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the "
"comma are millisecond portion of the time)."
msgstr "인간이 읽을 수있는 시간 :class:`LogRecord` 가 생성되었습니다. 기본적으로 이것은 '2003-07-08 16:49:45,896' 형식입니다 (쉼표 뒤의 숫자는 밀리 초 부분입니다)."

#: ../Doc/library/logging.rst:767
msgid "created"
msgstr "created"

#: ../Doc/library/logging.rst:767
#, python-format
msgid "``%(created)f``"
msgstr "``%(created)f``"

#: ../Doc/library/logging.rst:767
#, fuzzy
msgid ""
"Time when the :class:`LogRecord` was created (as returned by "
":func:`time.time`)."
msgstr ":class:`LogRecord` 가 생성 된 시간 (:func:`time.time` 에 의해 반환 된 시간)."

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:770
msgid "exc_info"
msgstr "exc_info"

#: ../Doc/library/logging.rst:770
#, fuzzy
msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred,"
" ``None``."
msgstr "예외 튜플 (à la ``sys.exc_info``) 또는 예외가 발생하지 않았다면 ``None`` 입니다."

#: ../Doc/library/logging.rst:773
msgid "filename"
msgstr "filename"

#: ../Doc/library/logging.rst:773
#, python-format
msgid "``%(filename)s``"
msgstr "``%(filename)s``"

#: ../Doc/library/logging.rst:773
#, fuzzy
msgid "Filename portion of ``pathname``."
msgstr "``pathname`` 의 파일명 부분."

#: ../Doc/library/logging.rst:775
msgid "funcName"
msgstr "funcName"

#: ../Doc/library/logging.rst:775
#, python-format
msgid "``%(funcName)s``"
msgstr "``%(funcName)s``"

#: ../Doc/library/logging.rst:775
#, fuzzy
msgid "Name of function containing the logging call."
msgstr "로깅 호출을 포함하는 함수의 이름입니다."

#: ../Doc/library/logging.rst:777
msgid "levelname"
msgstr "levelname"

#: ../Doc/library/logging.rst:777
#, python-format
msgid "``%(levelname)s``"
msgstr "``%(levelname)s``"

#: ../Doc/library/logging.rst:777
#, fuzzy
msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, "
"``'WARNING'``, ``'ERROR'``, ``'CRITICAL'``)."
msgstr "메시지의 텍스트 로깅 수준 (```DEBUG``,``INFO``,``WARNING&#39;``,``ERROR``,``CRITICAL```)."

#: ../Doc/library/logging.rst:781
msgid "levelno"
msgstr "levelno"

#: ../Doc/library/logging.rst:781
#, python-format
msgid "``%(levelno)s``"
msgstr "``%(levelno)s``"

#: ../Doc/library/logging.rst:781
#, fuzzy
msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, "
":const:`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr "메시지의 숫자 로깅 레벨 (:const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."

#: ../Doc/library/logging.rst:786
msgid "lineno"
msgstr "lineno"

#: ../Doc/library/logging.rst:786
#, python-format
msgid "``%(lineno)d``"
msgstr "``%(lineno)d``"

#: ../Doc/library/logging.rst:786
#, fuzzy
msgid "Source line number where the logging call was issued (if available)."
msgstr "로깅 호출이 발행 된 소스 행 번호 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:789
msgid "message"
msgstr "message"

#: ../Doc/library/logging.rst:789
#, python-format
msgid "``%(message)s``"
msgstr "``%(message)s``"

#: ../Doc/library/logging.rst:789
#, fuzzy
msgid ""
"The logged message, computed as ``msg % args``. This is set when "
":meth:`Formatter.format` is invoked."
msgstr "로그 된 메시지는 ``msg % args`` 로 계산됩니다. 이것은 :meth:`Formatter.format` 이 호출 될 때 설정됩니다."

#: ../Doc/library/logging.rst:793
msgid "module"
msgstr "module"

#: ../Doc/library/logging.rst:793
#, python-format
msgid "``%(module)s``"
msgstr "``%(module)s``"

#: ../Doc/library/logging.rst:793
#, fuzzy
msgid "Module (name portion of ``filename``)."
msgstr "모듈 (``filename`` 의 이름 부분)."

#: ../Doc/library/logging.rst:795
msgid "msecs"
msgstr "msecs"

#: ../Doc/library/logging.rst:795
#, python-format
msgid "``%(msecs)d``"
msgstr "``%(msecs)d``"

#: ../Doc/library/logging.rst:795
#, fuzzy
msgid "Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr ":class:`LogRecord` 가 생성 된 시간의 밀리 초 부분."

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:798
msgid "msg"
msgstr "msg"

#: ../Doc/library/logging.rst:798
#, fuzzy
msgid ""
"The format string passed in the original logging call. Merged with "
"``args`` to produce ``message``, or an arbitrary object (see :ref"
":`arbitrary-object-messages`)."
msgstr "원래 로깅 호출에서 전달 된 형식 문자열. ``args`` 와 병합하여 ``message`` 또는 임의의 객체를 생성합니다 (참조 :ref:`arbitrary-object-messages` 참조)."

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:803
msgid "name"
msgstr "name"

#: ../Doc/library/logging.rst:803
#, python-format
msgid "``%(name)s``"
msgstr "``%(name)s``"

#: ../Doc/library/logging.rst:803
#, fuzzy
msgid "Name of the logger used to log the call."
msgstr "호출을 기록하는 데 사용되는 로거의 이름입니다."

#: ../Doc/library/logging.rst:805
msgid "pathname"
msgstr "pathname"

#: ../Doc/library/logging.rst:805
#, python-format
msgid "``%(pathname)s``"
msgstr "``%(pathname)s``"

#: ../Doc/library/logging.rst:805
#, fuzzy
msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr "로깅 호출이 발행 된 소스 파일의 전체 경로 이름 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:808
msgid "process"
msgstr "process"

#: ../Doc/library/logging.rst:808
#, python-format
msgid "``%(process)d``"
msgstr "``%(process)d``"

#: ../Doc/library/logging.rst:808
#, fuzzy
msgid "Process ID (if available)."
msgstr "프로세스 ID (사용 가능한 경우)."

#: ../Doc/library/logging.rst:810
msgid "processName"
msgstr "processName"

#: ../Doc/library/logging.rst:810
#, python-format
msgid "``%(processName)s``"
msgstr "``%(processName)s``"

#: ../Doc/library/logging.rst:810
#, fuzzy
msgid "Process name (if available)."
msgstr "프로세스 이름 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:812
msgid "relativeCreated"
msgstr "relativeCreated"

#: ../Doc/library/logging.rst:812
#, python-format
msgid "``%(relativeCreated)d``"
msgstr "``%(relativeCreated)d``"

#: ../Doc/library/logging.rst:812
#, fuzzy
msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time"
" the logging module was loaded."
msgstr "로깅 모듈이로드 된 시간을 기준으로 LogRecord가 작성된 시간 (밀리 초)."

#: ../Doc/library/logging.rst:816
msgid "stack_info"
msgstr "stack_info"

#: ../Doc/library/logging.rst:816
#, fuzzy
msgid ""
"Stack frame information (where available) from the bottom of the stack in"
" the current thread, up to and including the stack frame of the logging "
"call which resulted in the creation of this record."
msgstr "현재 스레드의 스택 맨 아래에서이 레코드를 생성 한 로깅 호출의 스택 프레임까지 프레임 정보를 스택에 쌓습니다 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:822
msgid "thread"
msgstr "thread"

#: ../Doc/library/logging.rst:822
#, python-format
msgid "``%(thread)d``"
msgstr "``%(thread)d``"

#: ../Doc/library/logging.rst:822
#, fuzzy
msgid "Thread ID (if available)."
msgstr "스레드 ID (사용 가능한 경우)."

#: ../Doc/library/logging.rst:824
msgid "threadName"
msgstr "threadName"

#: ../Doc/library/logging.rst:824
#, python-format
msgid "``%(threadName)s``"
msgstr "``%(threadName)s``"

#: ../Doc/library/logging.rst:824
#, fuzzy
msgid "Thread name (if available)."
msgstr "스레드 이름 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:827
#, fuzzy
msgid "*processName* was added."
msgstr "*processName* 이 추가되었습니다."

#: ../Doc/library/logging.rst:834
#, fuzzy
msgid "LoggerAdapter Objects"
msgstr "LoggerAdapter 객체"

#: ../Doc/library/logging.rst:836
#, fuzzy
msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual"
" information into logging calls. For a usage example, see the section on "
":ref:`adding contextual information to your logging output <context-"
"info>`."
msgstr ":class:`LoggerAdapter` 인스턴스는 컨텍스트 정보를 로깅 호출에 편리하게 전달하는 데 사용됩니다. 사용 예는 다음을 참조하십시오 :ref:`로그 출력에 상황 별 정보 추가하기 <context-info>`."

#: ../Doc/library/logging.rst:842
#, fuzzy
msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an "
"underlying :class:`Logger` instance and a dict-like object."
msgstr "기본 :class:`Logger` 인스턴스와 dict-like 오브젝트로 초기화 된 :class:`LoggerAdapter` 의 인스턴스를 리턴합니다."

#: ../Doc/library/logging.rst:847
#, fuzzy
msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in"
" order to insert contextual information. This implementation takes the "
"object passed as *extra* to the constructor and adds it to *kwargs* using"
" key 'extra'. The return value is a (*msg*, *kwargs*) tuple which has the"
" (possibly modified) versions of the arguments passed in."
msgstr "문맥 정보를 삽입하기 위해 로깅 호출에 전달 된 메시지 및 / 또는 키워드 인수를 수정합니다. 이 구현은 *extra* 로 전달 된 객체를 생성자에 가져와 'extra' 키를 사용하여 *kwargs* 에 추가합니다. 리턴 값은 전달 된 인수의 버전을 가진 (*msg*, *kwargs*) 튜플입니다."

#: ../Doc/library/logging.rst:853
#, fuzzy
msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, "
":meth:`~Logger.warning`, :meth:`~Logger.error`, "
":meth:`~Logger.exception`, :meth:`~Logger.critical`, :meth:`~Logger.log`,"
" :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel` and :meth:`~Logger.hasHandlers`. These methods "
"have the same signatures as their counterparts in :class:`Logger`, so you"
" can use the two types of instances interchangeably."
msgstr ":class:`Logger` : :meth:`~Logger.debug`, :meth:`~Logger.info`, :class:`LoggerAdapter` 는 다음과 같은 메소드를 지원합니다 : :meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :meth:`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` 그리고 :meth:`~Logger.hasHandlers`. 이 메소드들은 :class:`Logger` 에있는 것과 똑같은 서명을 가지므로 두 유형의 인스턴스를 같은 의미로 사용할 수 있습니다."

#: ../Doc/library/logging.rst:862
#, fuzzy
msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were "
"added to :class:`LoggerAdapter`.  These methods delegate to the "
"underlying logger."
msgstr ":meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` 그리고 :meth:`~Logger.hasHandlers` 메쏘드가 :class:`LoggerAdapter` 에 추가되었습니다. . 이러한 메소드는 기본 로거에 위임합니다."

#: ../Doc/library/logging.rst:869
#, fuzzy
msgid "Thread Safety"
msgstr "스레드 안전성"

#: ../Doc/library/logging.rst:871
#, fuzzy
msgid ""
"The logging module is intended to be thread-safe without any special work"
" needing to be done by its clients. It achieves this though using "
"threading locks; there is one lock to serialize access to the module's "
"shared data, and each handler also creates a lock to serialize access to "
"its underlying I/O."
msgstr "로깅 모듈은 클라이언트가 수행해야하는 특별한 작업없이 스레드로부터 안전하도록 만들어졌습니다. 스레딩 잠금을 사용하여이 작업을 수행합니다. 모듈의 공유 데이터에 대한 액세스를 직렬화하는 하나의 잠금이 있으며 각 핸들러는 기본 I / O에 대한 액세스를 직렬화하는 잠금을 작성합니다."

#: ../Doc/library/logging.rst:876
#, fuzzy
msgid ""
"If you are implementing asynchronous signal handlers using the "
":mod:`signal` module, you may not be able to use logging from within such"
" handlers. This is because lock implementations in the :mod:`threading` "
"module are not always re-entrant, and so cannot be invoked from such "
"signal handlers."
msgstr ":mod:`signal` 모듈을 사용하여 비동기 시그널 핸들러를 구현한다면, 핸들러 내에서 로깅을 사용할 수 없을 수도 있습니다. 이는 :mod:`threading` 모듈의 잠금 구현이 항상 재진입 적이기 때문에 이러한 시그널 핸들러에서 호출 할 수 없기 때문입니다."

#: ../Doc/library/logging.rst:883
#, fuzzy
msgid "Module-Level Functions"
msgstr "모듈 수준 함수"

#: ../Doc/library/logging.rst:885
#, fuzzy
msgid ""
"In addition to the classes described above, there are a number of module-"
" level functions."
msgstr "위에서 설명한 클래스 외에도 많은 모듈 수준 함수가 있습니다."

#: ../Doc/library/logging.rst:891
#, fuzzy
msgid ""
"Return a logger with the specified name or, if name is ``None``, return a"
" logger which is the root logger of the hierarchy. If specified, the name"
" is typically a dot-separated hierarchical name like *'a'*, *'a.b'* or "
"*'a.b.c.d'*. Choice of these names is entirely up to the developer who is"
" using logging."
msgstr "지정된 이름의 로거를 돌려줍니다. 이름이 ``None`` 인 경우, 계층의 루트 로거 인 로거를 돌려줍니다. 이 이름을 지정하면 일반적으로 *'a'*, *'a.b'* 또는 *'a.b.c.d'* 와 같이 점으로 구분 된 계층 구조 이름이됩니다. 이 이름의 선택은 전적으로 로깅을 사용하는 개발자에게 달려 있습니다."

#: ../Doc/library/logging.rst:896
#, fuzzy
msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed "
"between different parts of an application."
msgstr "주어진 이름으로이 함수를 호출하면 모두 동일한 로거 인스턴스를 반환합니다. 즉, 응용 프로그램의 다른 부분간에 로거 인스턴스를 전달할 필요가 없습니다."

#: ../Doc/library/logging.rst:903
#, fuzzy
msgid ""
"Return either the standard :class:`Logger` class, or the last class "
"passed to :func:`setLoggerClass`. This function may be called from within"
" a new class definition, to ensure that installing a customized "
":class:`Logger` class will not undo customizations already applied by "
"other code. For example::"
msgstr "표준 :class:`Logger` 클래스를 반환하거나 :func:`setLoggerClass` 에 전달 된 마지막 클래스를 반환하십시오. 이 함수는 새 클래스 정의 내에서 호출하여 customize :class:`Logger` 클래스를 설치해도 다른 코드가 이미 적용한 사용자 정의를 실행 취소하지 않도록 할 수 있습니다. 예를 들면 ::"

#: ../Doc/library/logging.rst:914
#, fuzzy
msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr ":class:`LogRecord` 를 생성하는 데 사용되는 호출 가능 함수를 반환합니다."

#: ../Doc/library/logging.rst:916
#, fuzzy
msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, "
"to allow developers more control over how the :class:`LogRecord` "
"representing a logging event is constructed."
msgstr "이 함수는 :func:`setLogRecordFactory` 와 함께 제공되어, 개발자가 로깅 이벤트를 나타내는 :class:`LogRecord` 가 어떻게 구성되는지보다 잘 제어 할 수 있습니다."

#: ../Doc/library/logging.rst:921
#, fuzzy
msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr "팩토리 호출 방법에 대한 더 자세한 정보는 :func:`setLogRecordFactory` 를보세요."

#: ../Doc/library/logging.rst:926
#, fuzzy
msgid ""
"Logs a message with level :const:`DEBUG` on the root logger. The *msg* is"
" the message format string, and the *args* are the arguments which are "
"merged into *msg* using the string formatting operator. (Note that this "
"means that you can use keywords in the format string, together with a "
"single dictionary argument.)"
msgstr "루트 로거에서 level :const:`DEBUG` 메시지를 기록합니다. *msg* 는 메시지 형식 문자열이고 *args* 는 문자열 형식 지정 연산자를 사용하여 *msg* 에 병합되는 인수입니다. (이는 형식 문자열의 키워드를 하나의 사전 인수와 함께 사용할 수 있음을 의미합니다.)"

#: ../Doc/library/logging.rst:931
#, fuzzy
msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info* which, if it does not evaluate as false, causes exception "
"information to be added to the logging message. If an exception tuple (in"
" the format returned by :func:`sys.exc_info`) is provided, it is used; "
"otherwise, :func:`sys.exc_info` is called to get the exception "
"information."
msgstr "*kwargs* 에는 검사 할 키워드 인수가 세 개 있습니다. *exc_info* false로 평가되지 않으면 예외 정보가 로깅 메시지에 추가됩니다. 예외 튜플 (:func:`sys.exc_info` 에 의해 반환 된 형식으로)이 제공되면, 그것은 사용됩니다; 그렇지 않으면 :func:`sys.exc_info` 가 예외 정보를 얻기 위해 호출됩니다."

#: ../Doc/library/logging.rst:957
#, fuzzy
msgid ""
"The third optional keyword argument is *extra* which can be used to pass "
"a dictionary which is used to populate the __dict__ of the LogRecord "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr "세 번째 선택적 키워드 인수는 *extra* 로깅 이벤트 용으로 작성된 LogRecord의 __dict__을 사용자 정의 속성으로 채우는 데 사용되는 사전을 전달하는 데 사용할 수 있습니다. 이러한 사용자 지정 특성은 원하는대로 사용할 수 있습니다. 예를 들어 로그 된 메시지에 통합 될 수 있습니다. 예를 들면 ::"

#: ../Doc/library/logging.rst:968
#, fuzzy
msgid "would print something like:"
msgstr "다음과 같이 인쇄 할 것입니다 :"

#: ../Doc/library/logging.rst:997
#, fuzzy
msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments"
" are interpreted as for :func:`debug`."
msgstr "루트 logger에 level :const:`INFO` 메시지를 기록합니다. 인수는 :func:`debug` 와 같이 해석됩니다."

#: ../Doc/library/logging.rst:1003
#, fuzzy
msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr "root logger에 level :const:`WARNING` 메시지를 기록합니다. 인수는 :func:`debug` 와 같이 해석됩니다."

#: ../Doc/library/logging.rst:1006
#, fuzzy
msgid ""
"There is an obsolete function ``warn`` which is functionally identical to"
" ``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr "기능적으로 ``warning`` 와 동일한 쓸모없는 함수 ``warn`` 이 있습니다. ``warn`` 은 더 이상 사용되지 않으므로 사용하지 마십시오 - 대신 ``warning`` 을 사용하십시오."

#: ../Doc/library/logging.rst:1013
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr "루트 logger에 level :const:`ERROR` 메시지를 기록합니다. 인수는 :func:`debug` 와 같이 해석됩니다."

#: ../Doc/library/logging.rst:1019
#, fuzzy
msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr "루트 로거에서 level :const:`CRITICAL` 메시지를 기록합니다. 인수는 :func:`debug` 와 같이 해석됩니다."

#: ../Doc/library/logging.rst:1025
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The "
"arguments are interpreted as for :func:`debug`. Exception info is added "
"to the logging message. This function should only be called from an "
"exception handler."
msgstr "루트 logger에 level :const:`ERROR` 메시지를 기록합니다. 인수는 :func:`debug` 와 같이 해석됩니다. 예외 정보가 로깅 메시지에 추가됩니다. 이 함수는 예외 처리기에서만 호출해야합니다."

#: ../Doc/library/logging.rst:1031
#, fuzzy
msgid ""
"Logs a message with level *level* on the root logger. The other arguments"
" are interpreted as for :func:`debug`."
msgstr "루트 로거에 레벨 *level* 의 메시지를 기록합니다. 다른 인수는 :func:`debug` 와 같이 해석됩니다."

#: ../Doc/library/logging.rst:1034
#, fuzzy
msgid ""
"The above module-level convenience functions, which delegate to the root "
"logger, call :func:`basicConfig` to ensure that at least one handler is "
"available. Because of this, they should *not* be used in threads, in "
"versions of Python earlier than 2.7.1 and 3.2, unless at least one "
"handler has been added to the root logger *before* the threads are "
"started. In earlier versions of Python, due to a thread safety "
"shortcoming in :func:`basicConfig`, this can (under rare circumstances) "
"lead to handlers being added multiple times to the root logger, which can"
" in turn lead to multiple messages for the same event."
msgstr "위의 모듈 레벨 편의 함수는 루트 로거에 위임하여 적어도 하나의 핸들러가 사용 가능하도록 :func:`basicConfig` 를 호출합니다. 따라서 스레드가 시작되기 *전에* 적어도 하나의 핸들러가 루트 로거에 추가되지 않는 한, 스레드를 2.7.1 및 3.2 이전의 Python 버전에서 사용하지 *않아야* 합니다. 이전 버전의 Python에서는 :func:`basicConfig` 의 스레드 안전상의 결점으로 인해 (드물 긴하지만) 루트 로거에 여러 번 추가되는 핸들러로 이어질 수 있으며, 동일한 핸들러에 대해 여러 메시지가 나타날 수 있습니다 행사."

#: ../Doc/library/logging.rst:1046
#, fuzzy
msgid ""
"Provides an overriding level *lvl* for all loggers which takes precedence"
" over the logger's own level. When the need arises to temporarily "
"throttle logging output down across the whole application, this function "
"can be useful. Its effect is to disable all logging calls of severity "
"*lvl* and below, so that if you call it with a value of INFO, then all "
"INFO and DEBUG events would be discarded, whereas those of severity "
"WARNING and above would be processed according to the logger's effective "
"level. If ``logging.disable(logging.NOTSET)`` is called, it effectively "
"removes this overriding level, so that logging output again depends on "
"the effective levels of individual loggers."
msgstr "로거 자체 레벨보다 우선 순위가 높은 모든 로거에 대해 우선 레벨 *lvl* 을 제공합니다. 로깅 출력을 전체 애플리케이션에 일시적으로 억제해야하는 필요성이 생길 때이 기능이 유용 할 수 있습니다. 그 효과는 심각도 * lvl * 및 그 이하의 모든 로깅 호출을 사용 불가능하게하는 것입니다. 따라서 INFO 값으로 호출하면 모든 INFO 및 DEBUG 이벤트는 삭제되지만 WARNING 이상의 심각도는 처리됩니다 로거의 유효 수준. ``logging.disable(logging.NOTSET)`` 이 불려지면,이 오버 라이딩 레벨을 효과적으로 제거하므로, 로깅 출력은 개별 로거의 유효 레벨에 따라 달라집니다."

#: ../Doc/library/logging.rst:1057
#, fuzzy
msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *lvl* parameter, but will have to explicitly supply"
" a suitable value."
msgstr "``CRITICAL`` 보다 더 높은 커스텀 로깅 레벨을 정의했다면 (권장하지 않음), *lvl* 매개 변수의 기본값에 의존 할 수 없지만, 명시 적으로 적합한 가치."

#: ../Doc/library/logging.rst:1062
#, fuzzy
msgid ""
"The *lvl* parameter was defaulted to level ``CRITICAL``. See Issue #28524"
" for more information about this change."
msgstr "*lvl* 매개 변수의 기본값은 ``CRITICAL`` 입니다. 이 변경 사항에 대한 자세한 내용은 문제 #28524를 참조하십시오."

#: ../Doc/library/logging.rst:1068
#, fuzzy
msgid ""
"Associates level *lvl* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for "
"example when a :class:`Formatter` formats a message. This function can "
"also be used to define your own levels. The only constraints are that all"
" levels used must be registered using this function, levels should be "
"positive integers and they should increase in increasing order of "
"severity."
msgstr "내부 사전에 level *lvl* 텍스트를 *levelName* 와 연결합니다.이 사전은 예 :class:`Formatter` 가 메시지를 형식화 할 때와 같이 숫자 수준을 텍스트 표현으로 매핑하는 데 사용됩니다. 이 기능을 사용하여 자신의 레벨을 정의 할 수도 있습니다. 유일한 제약 조건은 사용되는 모든 레벨이이 함수를 사용하여 등록되어야하며 레벨은 양의 정수이어야하며 심각도가 높아지는 순서로 증가해야한다는 것입니다."

#: ../Doc/library/logging.rst:1075
#, fuzzy
msgid ""
"If you are thinking of defining your own levels, please see the section "
"on :ref:`custom-levels`."
msgstr "자신 만의 레벨을 정의 할 생각이라면 :ref:`custom-levels` 섹션을보십시오."

#: ../Doc/library/logging.rst:1080
#, python-format, fuzzy
msgid ""
"Returns the textual representation of logging level *lvl*. If the level "
"is one of the predefined levels :const:`CRITICAL`, :const:`ERROR`, "
":const:`WARNING`, :const:`INFO` or :const:`DEBUG` then you get the "
"corresponding string. If you have associated levels with names using "
":func:`addLevelName` then the name you have associated with *lvl* is "
"returned. If a numeric value corresponding to one of the defined levels "
"is passed in, the corresponding string representation is returned. "
"Otherwise, the string 'Level %s' % lvl is returned."
msgstr "로깅 레벨 *lvl* 의 텍스트 표현을 리턴합니다. 레벨이 미리 정의 된 레벨 중 하나 인 경우 :const:`CRITICAL`, :const:`ERROR`, :const:`WARNING`, :const:`INFO` 또는 :const:`DEBUG`. :func:`addLevelName` 을 사용하여 레벨과 이름을 연관 짓는 경우 *lvl* 과 연결된 이름이 반환됩니다. 정의 된 수준 중 하나에 해당하는 숫자 값이 전달되면 해당 문자열 표현이 반환됩니다. 그렇지 않으면 문자열 'Level %s' % lvl 이 (가) 반환됩니다."

#: ../Doc/library/logging.rst:1088
#, python-format, fuzzy
msgid ""
"Levels are internally integers (as they need to be compared in the "
"logging logic). This function is used to convert between an integer level"
" and the level name displayed in the formatted log output by means of the"
" ``%(levelname)s`` format specifier (see :ref:`logrecord-attributes`)."
msgstr "레벨은 내부적으로 정수입니다 (로깅 로직에서 비교해야 함). 이 함수는 ``%(levelname)s`` 형식 지정자 (:ref:`logrecord-attributes` 참조)를 사용하여 정수 수준과 형식화 된 로그 출력에 표시된 수준 이름간에 변환하는 데 사용됩니다."

#: ../Doc/library/logging.rst:1093
#, fuzzy
msgid ""
"In Python versions earlier than 3.4, this function could also be passed a"
" text level, and would return the corresponding numeric value of the "
"level. This undocumented behaviour was considered a mistake, and was "
"removed in Python 3.4, but reinstated in 3.4.2 due to retain backward "
"compatibility."
msgstr "3.4 이전의 Python 버전에서이 함수는 텍스트 수준을 전달할 수 있으며 해당 수준의 숫자 값을 반환합니다. 이 문서화되지 않은 동작은 실수로 간주되어 Python 3.4에서 제거되었지만 이전 버전과의 호환성을 유지하기 위해 3.4.2에서 복원되었습니다."

#: ../Doc/library/logging.rst:1101
#, fuzzy
msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes "
"are defined by *attrdict*. This function is useful for taking a pickled "
":class:`LogRecord` attribute dictionary, sent over a socket, and "
"reconstituting it as a :class:`LogRecord` instance at the receiving end."
msgstr "속성이 *attrdict* 에 의해 정의 된 새로운 :class:`LogRecord` 인스턴스를 생성하고 리턴합니다. 이 함수는 pickled :class:`LogRecord` 속성 딕셔너리를 소켓에 보내어 수신 측 끝에 :class:`LogRecord` 인스턴스로 재구성 할 때 유용합니다."

#: ../Doc/library/logging.rst:1109
#, fuzzy
msgid ""
"Does basic configuration for the logging system by creating a "
":class:`StreamHandler` with a default :class:`Formatter` and adding it to"
" the root logger. The functions :func:`debug`, :func:`info`, "
":func:`warning`, :func:`error` and :func:`critical` will call "
":func:`basicConfig` automatically if no handlers are defined for the root"
" logger."
msgstr "Basic :class:`Formatter` 를 사용하여 :class:`StreamHandler` 를 생성하고 루트 로거에 추가하여 로깅 시스템의 기본 구성을 수행합니다. :func:`debug`, :func:`info`, :func:`warning`, :func:`error` 그리고 :func:`critical` 는 핸들러가 정의되어 있지 않으면 자동으로 :func:`basicConfig` 를 호출합니다. 루트 로거 용."

#: ../Doc/library/logging.rst:1115
#, fuzzy
msgid ""
"This function does nothing if the root logger already has handlers "
"configured for it."
msgstr "이 함수는 루트 로거에 이미 처리기가 구성되어있는 경우 아무 작업도 수행하지 않습니다."

#: ../Doc/library/logging.rst:1118
#, fuzzy
msgid ""
"This function should be called from the main thread before other threads "
"are started. In versions of Python prior to 2.7.1 and 3.2, if this "
"function is called from multiple threads, it is possible (in rare "
"circumstances) that a handler will be added to the root logger more than "
"once, leading to unexpected results such as messages being duplicated in "
"the log."
msgstr "이 함수는 다른 스레드가 시작되기 전에 주 스레드에서 호출되어야합니다. 2.7.1 및 3.2 이전의 Python 버전에서이 함수를 여러 스레드에서 호출하면 드문 경우지만 핸들러가 두 번 이상 루트 로거에 추가되어 메시지와 같은 예기치 않은 결과가 발생할 수 있습니다 로그에 중복됩니다."

#: ../Doc/library/logging.rst:1125
#, fuzzy
msgid "The following keyword arguments are supported."
msgstr "다음 키워드 인수가 지원됩니다."

#: ../Doc/library/logging.rst:1132
msgid "*filename*"
msgstr "*filename*"

#: ../Doc/library/logging.rst:1132
#, fuzzy
msgid ""
"Specifies that a FileHandler be created, using the specified filename, "
"rather than a StreamHandler."
msgstr "StreamHandler는 아니고, 지정된 파일명을 사용해 FileHandler를 작성하도록 (듯이) 지정합니다."

#: ../Doc/library/logging.rst:1136
msgid "*filemode*"
msgstr "*filemode*"

#: ../Doc/library/logging.rst:1136
#, fuzzy
msgid ""
"If *filename* is specified, open the file in this :ref:`mode "
"<filemodes>`. Defaults to ``'a'``."
msgstr "*filename* 을 지정하면 다음과 같이 파일을 엽니 다. :ref:`mode <filemodes>`. 기본값은 ``'a'`` 입니다."

#: ../Doc/library/logging.rst:1140
msgid "*format*"
msgstr "*format*"

#: ../Doc/library/logging.rst:1140
#, fuzzy
msgid "Use the specified format string for the handler."
msgstr "핸들러에 대해 지정된 형식. 자열을 사용하십시오."

#: ../Doc/library/logging.rst:1143
msgid "*datefmt*"
msgstr "*datefmt*"

#: ../Doc/library/logging.rst:1143
#, fuzzy
msgid "Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr ":func:`time.strftime` 에 허용 된대로 지정된 날짜 / 시간 형식을 사용하십시오."

#: ../Doc/library/logging.rst:1146
msgid "*style*"
msgstr "*style*"

#: ../Doc/library/logging.rst:1146
#, fuzzy
msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` or :class:`string.Template` "
"respectively. Defaults to ``'%'``."
msgstr "*format* 을 지정하면 형식 문자열에이 스타일을 사용하십시오. ``'%'``, ``'{'`` 또는 ``'$'`` for :ref:`printf-style <old-string-formatting>`, :meth:`str.format` 또는 :class:`string.Template` 을 각각 참조하십시오. 기본값은 ``'%'`` 입니다."

#: ../Doc/library/logging.rst:1154
msgid "*level*"
msgstr "*level*"

#: ../Doc/library/logging.rst:1154
#, fuzzy
msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr "루트 로거 레벨을 지정된 :ref:`수준 <levels>` 으로 설정하십시오."

#: ../Doc/library/logging.rst:1157
msgid "*stream*"
msgstr "*stream*"

#: ../Doc/library/logging.rst:1157
#, fuzzy
msgid ""
"Use the specified stream to initialize the StreamHandler. Note that this "
"argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr "StreamHandler의 초기화에는, 지정된 Stream을 사용합니다. 이 인수는 *filename* 과 호환되지 않습니다. 둘 다 있으면 ``ValueError`` 가 발생합니다."

#: ../Doc/library/logging.rst:1162
msgid "*handlers*"
msgstr "*handlers*"

#: ../Doc/library/logging.rst:1162
#, fuzzy
msgid ""
"If specified, this should be an iterable of already created handlers to "
"add to the root logger. Any handlers which don't already have a formatter"
" set will be assigned the default formatter created in this function. "
"Note that this argument is incompatible with *filename* or *stream* - if "
"both are present, a ``ValueError`` is raised."
msgstr "지정된 경우, 이것은 루트 로거에 추가 할 이미 작성된 핸들러의 반복 가능이어야합니다. 아직 포맷터 세트가없는 핸들러에는이 함수에서 작성된 기본 포맷터가 지정됩니다. 이 인수는 *filename* 또는 *stream* 과 호환되지 않습니다. 둘 다 있으면 ``ValueError`` 가 발생합니다."

#: ../Doc/library/logging.rst:1172
#, fuzzy
msgid "The *style* argument was added."
msgstr "*style* 인수가 추가되었습니다."

#: ../Doc/library/logging.rst:1175
#, fuzzy
msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with "
"*filename*)."
msgstr "*handlers* 인수가 추가되었습니다. 호환되지 않는 인수 (예 : *handlers* 와 함께 *stream* 또는 *filename* 또는 *stream* 와 *filename*)가있는 상황을 파악하기 위해 추가 검사가 추가되었습니다."

#: ../Doc/library/logging.rst:1183
#, fuzzy
msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and"
" closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr "로깅 시스템에 모든 처리기를 비우고 닫음으로써 정상 종료를 수행하도록 알립니다. 이것은 응용 프로그램 종료시 호출되어야하며이 호출 후에 로깅 시스템을 더 이상 사용하지 않아야합니다."

#: ../Doc/library/logging.rst:1190
#, fuzzy
msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`__init__` such that only a name "
"argument is required, and the :meth:`__init__` should call "
":meth:`Logger.__init__`. This function is typically called before any "
"loggers are instantiated by applications which need to use custom logger "
"behavior."
msgstr "로거를 인스턴스화 할 때 *klass* 클래스를 사용하도록 로깅 시스템에 지시합니다. 클래스는 name 인수 만 필요하도록 :meth:`__init__` 을 정의해야하며, :meth:`__init__` 는 :meth:`Logger.__init__` 을 호출해야합니다. 이 함수는 일반적으로 사용자 정의 로거 비헤이비어를 사용해야하는 응용 프로그램에 의해 로거가 인스턴스화되기 전에 호출됩니다."

#: ../Doc/library/logging.rst:1199
#, fuzzy
msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr ":class:`LogRecord` 를 생성하는데 사용되는 callable을 설정하십시오."

#: ../Doc/library/logging.rst:1201
#, fuzzy
msgid "The factory callable to be used to instantiate a log record."
msgstr "로그 레코드를 인스턴스화하기 위해서 사용하는 팩토리."

#: ../Doc/library/logging.rst:1203
#, fuzzy
msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, "
"to allow developers more control over how the :class:`LogRecord` "
"representing a logging event is constructed."
msgstr "이 함수는 :func:`getLogRecordFactory` 와 함께 제공되어, 개발자가 로깅 이벤트를 나타내는 :class:`LogRecord` 가 어떻게 구성되는지보다 잘 제어 할 수 있습니다."

#: ../Doc/library/logging.rst:1208
#, fuzzy
msgid "The factory has the following signature:"
msgstr "팩토리의 서명은 다음과 같습니다.:"

#: ../Doc/library/logging.rst:1210
msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, "
"sinfo=None, **kwargs)``"
msgstr "``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, **kwargs)``"

#: ../Doc/library/logging.rst:1212
#, fuzzy
msgid "The logger name."
msgstr "로거 이름."

#: ../Doc/library/logging.rst
msgid "level"
msgstr "level"

#: ../Doc/library/logging.rst:1213
#, fuzzy
msgid "The logging level (numeric)."
msgstr "로깅 수준 (숫자)입니다."

#: ../Doc/library/logging.rst
msgid "fn"
msgstr "fn"

#: ../Doc/library/logging.rst:1214
#, fuzzy
msgid "The full pathname of the file where the logging call was made."
msgstr "로깅 호출이 이루어진 파일의 전체 경로 이름입니다."

#: ../Doc/library/logging.rst
msgid "lno"
msgstr "lno"

#: ../Doc/library/logging.rst:1215
#, fuzzy
msgid "The line number in the file where the logging call was made."
msgstr "로깅 호출이 작성된 파일의 행 번호."

#: ../Doc/library/logging.rst:1216
#, fuzzy
msgid "The logging message."
msgstr "로깅 메시지"

#: ../Doc/library/logging.rst:1217
#, fuzzy
msgid "The arguments for the logging message."
msgstr "로깅 메시지에 대한 인수."

#: ../Doc/library/logging.rst:1218
#, fuzzy
msgid "An exception tuple, or ``None``."
msgstr "예외 튜플 또는 ``None``."

#: ../Doc/library/logging.rst
msgid "func"
msgstr "func"

#: ../Doc/library/logging.rst:1219
#, fuzzy
msgid "The name of the function or method which invoked the logging call."
msgstr "로깅 호출을 호출 한 함수 나 메소드의 이름."

#: ../Doc/library/logging.rst
msgid "sinfo"
msgstr "sinfo"

#: ../Doc/library/logging.rst:1221
#, fuzzy
msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr "다음과 같은 스택 추적은 :func:`traceback.print_stack` 에 의해 제공되며, 호출 계층 구조를 보여줍니다."

#: ../Doc/library/logging.rst
msgid "kwargs"
msgstr "kwargs"

#: ../Doc/library/logging.rst:1223
#, fuzzy
msgid "Additional keyword arguments."
msgstr "추가 키워드 인수."

#: ../Doc/library/logging.rst:1227
#, fuzzy
msgid "Module-Level Attributes"
msgstr "모듈 수준 특성"

#: ../Doc/library/logging.rst:1231
#, fuzzy
msgid ""
"A \"handler of last resort\" is available through this attribute. This is"
" a :class:`StreamHandler` writing to ``sys.stderr`` with a level of "
"``WARNING``, and is used to handle logging events in the absence of any "
"logging configuration. The end result is to just print the message to "
"``sys.stderr``. This replaces the earlier error message saying that \"no "
"handlers could be found for logger XYZ\". If you need the earlier "
"behaviour for some reason, ``lastResort`` can be set to ``None``."
msgstr "\"최후의 수단의 처리자\" 는 이 속성을 통해 사용할 수 있습니다. 이것은 :class:`StreamHandler` 가 ``WARNING`` 레벨로 ``sys.stderr`` 에 쓰고 로깅 설정이 없을 때 로깅 이벤트를 처리하는 데 사용됩니다. 결과는 단지 ``sys.stderr`` 에 메시지를 출력하는 것입니다. 이렇게하면 \"no handlers could be found for logger XYZ\" 라는 이전 오류 메시지가 대체됩니다. 어떤 이유로 이전 동작이 필요하면 ``lastResort`` 를 ``None`` 으로 설정할 수 있습니다."

#: ../Doc/library/logging.rst:1242
#, fuzzy
msgid "Integration with the warnings module"
msgstr "경고 모듈과의 통합"

#: ../Doc/library/logging.rst:1244
#, fuzzy
msgid ""
"The :func:`captureWarnings` function can be used to integrate "
":mod:`logging` with the :mod:`warnings` module."
msgstr ":func:`captureWarnings` 함수는 :mod:`logging` 을 :mod:`warnings` 모듈과 통합하는데 사용될 수 있습니다."

#: ../Doc/library/logging.rst:1249
#, fuzzy
msgid ""
"This function is used to turn the capture of warnings by logging on and "
"off."
msgstr "이 함수는 로그온 및 로그 오프하여 경고 캡처를 설정하는 데 사용됩니다."

#: ../Doc/library/logging.rst:1252
#, fuzzy
msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module "
"will be redirected to the logging system. Specifically, a warning will be"
" formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of "
":const:`WARNING`."
msgstr "*capture* 가 ``True`` 인 경우, :mod:`warnings` 모듈에 의해 발행 된 경고는 로깅 시스템으로 리디렉션됩니다. 특히, 경고는 :func:`warnings.formatwarning` 을 사용하여 포맷되고 결과 문자열은 ``'py.warnings'`` 라는 이름의 로거에 기록됩니다 : 심각도는 :const:`WARNING` 입니다."

#: ../Doc/library/logging.rst:1257
#, fuzzy
msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging "
"system will stop, and warnings will be redirected to their original "
"destinations (i.e. those in effect before ``captureWarnings(True)`` was "
"called)."
msgstr "*capture* 가 ``False`` 이면, 로깅 시스템으로의 경고의 리다이렉션은 멈추고 경고는 원래 목적지 (즉, ``captureWarnings(True)`` 가 호출되기 전에 유효합니다)로 리다이렉션됩니다."

#: ../Doc/library/logging.rst:1265
msgid "Module :mod:`logging.config`"
msgstr "모듈 :mod:`logging.config`"

#: ../Doc/library/logging.rst:1265
msgid "Configuration API for the logging module."
msgstr "logging 모듈용 구성 API."

#: ../Doc/library/logging.rst:1268
msgid "Module :mod:`logging.handlers`"
msgstr "모듈 :mod:`logging.handlers`"

#: ../Doc/library/logging.rst:1268
msgid "Useful handlers included with the logging module."
msgstr "logging 모듈에 포함된 유용한 처리기."

#: ../Doc/library/logging.rst:1272
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - 로깅 시스템"

#: ../Doc/library/logging.rst:1271
#, fuzzy
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr "Python 표준 라이브러리에 포함시키기 위해이 기능을 설명한 제안서."

#: ../Doc/library/logging.rst:1277
#, fuzzy
msgid ""
"`Original Python logging package <https://www.red-"
"dove.com/python_logging.html>`_"
msgstr "`원본 파이썬 로깅 패키지 <https://www.red-dove.com/python_logging.html>`_"

#: ../Doc/library/logging.rst:1275
#, fuzzy
msgid ""
"This is the original source for the :mod:`logging` package.  The version "
"of the package available from this site is suitable for use with Python "
"1.5.2, 2.1.x and 2.2.x, which do not include the :mod:`logging` package "
"in the standard library."
msgstr "이것은 :mod:`logging` 패키지의 원래 소스입니다. 이 사이트에서 사용 가능한 패키지 버전은 표준 라이브러리에 :mod:`logging` 패키지를 포함하지 않는 Python 1.5.2, 2.1.x 및 2.2.x에서 사용하기에 적합합니다."
