# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-30 09:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/asyncio-eventloops.rst:4
msgid "Event loops"
msgstr "이벤트 루프"

#: ../Doc/library/asyncio-eventloops.rst:6
msgid "**Source code:** :source:`Lib/asyncio/events.py`"
msgstr "**소스 코드:** :source:`Lib/asyncio/events.py`"

#: ../Doc/library/asyncio-eventloops.rst:9
msgid "Event loop functions"
msgstr "이벤트 루프 함수"

#: ../Doc/library/asyncio-eventloops.rst:11
msgid ""
"The following functions are convenient shortcuts to accessing the methods"
" of the global policy. Note that this provides access to the default "
"policy, unless an alternative policy was set by calling "
":func:`set_event_loop_policy` earlier in the execution of the process."
msgstr ""
"다음 함수는 전역 정책의 메서드에 액세스하는 손쉬운 방법입니다. 프로세스의 실행 초기에 "
":func:`set_event_loop_policy`\\를 호출함으로써 대체 정책이 설정되지 않는 한, 이것은 기본 정책에 대한 액세스를"
" 제공합니다."

#: ../Doc/library/asyncio-eventloops.rst:18
msgid "Equivalent to calling ``get_event_loop_policy().get_event_loop()``."
msgstr "``get_event_loop_policy().get_event_loop()`` 를 호출하는 것과 동등합니다."

#: ../Doc/library/asyncio-eventloops.rst:22
msgid "Equivalent to calling ``get_event_loop_policy().set_event_loop(loop)``."
msgstr "``get_event_loop_policy().set_event_loop(loop)`` 를 호출하는 것과 동등합니다."

#: ../Doc/library/asyncio-eventloops.rst:26
msgid "Equivalent to calling ``get_event_loop_policy().new_event_loop()``."
msgstr "``get_event_loop_policy().new_event_loop()`` 를 호출하는 것과 동등합니다."

#: ../Doc/library/asyncio-eventloops.rst:30
msgid ""
"Return the running event loop in the current OS thread.  If there is no "
"running event loop a :exc:`RuntimeError` is raised."
msgstr ""
"현재 OS 스레드에서 실행 중인 이벤트 루프를 반환합니다. 실행 중인 이벤트 루프가 없으면 :exc:`RuntimeError` 가 "
"발생합니다."

#: ../Doc/library/asyncio-eventloops.rst:39
msgid "Available event loops"
msgstr "사용 가능한 이벤트 루프"

#: ../Doc/library/asyncio-eventloops.rst:41
msgid ""
"asyncio currently provides two implementations of event loops: "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio는 현재 이벤트 루프의 두 가지 구현을 제공합니다: :class:`SelectorEventLoop`\\와 "
":class:`ProactorEventLoop`"

#: ../Doc/library/asyncio-eventloops.rst:46
msgid ""
"Event loop based on the :mod:`selectors` module. Subclass of "
":class:`AbstractEventLoop`."
msgstr ""
":mod:`selectors` 모듈을 기반으로 하는 이벤트 루프. :class:`AbstractEventLoop` 의 서브 클래스입니다."

#: ../Doc/library/asyncio-eventloops.rst:49
msgid "Use the most efficient selector available on the platform."
msgstr "플랫폼에서 사용할 수 있는 가장 효율적인 셀렉터를 사용합니다."

#: ../Doc/library/asyncio-eventloops.rst:51
msgid ""
"On Windows, only sockets are supported (ex: pipes are not supported): see"
" the `MSDN documentation of select <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms740141%28v=vs.85%29.aspx>`_."
msgstr ""
"윈도우에서는, 소켓만 지원됩니다 (예: 파이프는 지원되지 않습니다): `select의 MSDN 설명서 "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/ms740141%28v=vs.85%29.aspx>`_ 를 참조하세요."

#: ../Doc/library/asyncio-eventloops.rst:57
msgid ""
"Proactor event loop for Windows using \"I/O Completion Ports\" aka IOCP. "
"Subclass of :class:`AbstractEventLoop`."
msgstr ""
"IOCP라고 하는 \"I/O 완료 포트\"를 사용하는 윈도우용 프로액터 이벤트 루프. :class:`AbstractEventLoop` 의"
" 서브 클래스입니다."

#: ../Doc/library/asyncio-eventloops.rst:60
msgid "Availability: Windows."
msgstr "가용성: 윈도우."

#: ../Doc/library/asyncio-eventloops.rst:64
msgid ""
"`MSDN documentation on I/O Completion Ports <https://msdn.microsoft.com"
"/en-us/library/windows/desktop/aa365198%28v=vs.85%29.aspx>`_."
msgstr ""
"`I/O 완료 포트에 관한 MSDN 설명서 <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa365198%28v=vs.85%29.aspx>`_."

#: ../Doc/library/asyncio-eventloops.rst:67
msgid "Example to use a :class:`ProactorEventLoop` on Windows::"
msgstr "윈도우에서 :class:`ProactorEventLoop`\\를 사용하는 예::"

#: ../Doc/library/asyncio-eventloops.rst:78
msgid "Platform support"
msgstr "플랫폼 지원"

#: ../Doc/library/asyncio-eventloops.rst:80
msgid ""
"The :mod:`asyncio` module has been designed to be portable, but each "
"platform still has subtle differences and may not support all "
":mod:`asyncio` features."
msgstr ""
":mod:`asyncio` 모듈은 이식성을 갖도록 설계되었지만, 각 플랫폼은 여전히 미묘한 차이가 있으며 모든 "
":mod:`asyncio` 기능을 지원하지 않을 수도 있습니다."

#: ../Doc/library/asyncio-eventloops.rst:84
msgid "Windows"
msgstr "윈도우"

#: ../Doc/library/asyncio-eventloops.rst:86
msgid "Common limits of Windows event loops:"
msgstr "윈도우 이벤트 루프의 일반적인 한계:"

#: ../Doc/library/asyncio-eventloops.rst:88
msgid ""
":meth:`~AbstractEventLoop.create_unix_connection` and "
":meth:`~AbstractEventLoop.create_unix_server` are not supported: the "
"socket family :data:`socket.AF_UNIX` is specific to UNIX"
msgstr ""
":meth:`~AbstractEventLoop.create_unix_connection`\\과 "
":meth:`~AbstractEventLoop.create_unix_server` 는 지원되지 않습니다: 소켓 패밀리 "
":data:`socket.AF_UNIX` 는 유닉스에서만 사용됩니다"

#: ../Doc/library/asyncio-eventloops.rst:91
msgid ""
":meth:`~AbstractEventLoop.add_signal_handler` and "
":meth:`~AbstractEventLoop.remove_signal_handler` are not supported"
msgstr ""
":meth:`~AbstractEventLoop.add_signal_handler`\\와 "
":meth:`~AbstractEventLoop.remove_signal_handler` 는 지원되지 않습니다."

#: ../Doc/library/asyncio-eventloops.rst:93
msgid ""
":meth:`EventLoopPolicy.set_child_watcher` is not supported. "
":class:`ProactorEventLoop` supports subprocesses. It has only one "
"implementation to watch child processes, there is no need to configure "
"it."
msgstr ""
":meth:`EventLoopPolicy.set_child_watcher` 는 지원되지 않습니다. "
":class:`ProactorEventLoop` 은 자식 프로세스를 지원합니다. 자식 프로세스를 감시하는 구현은 하나뿐이고, 구성할 "
"필요가 없습니다."

#: ../Doc/library/asyncio-eventloops.rst:97
msgid ":class:`SelectorEventLoop` specific limits:"
msgstr ":class:`SelectorEventLoop` 특정 제한:"

#: ../Doc/library/asyncio-eventloops.rst:99
msgid ""
":class:`~selectors.SelectSelector` is used which only supports sockets "
"and is limited to 512 sockets."
msgstr ":class:`~selectors.SelectSelector` 는 소켓만을 지원하며 512개의 소켓으로 제한됩니다."

#: ../Doc/library/asyncio-eventloops.rst:101
msgid ""
":meth:`~AbstractEventLoop.add_reader` and "
":meth:`~AbstractEventLoop.add_writer` only accept file descriptors of "
"sockets"
msgstr ""
":meth:`~AbstractEventLoop.add_reader`\\와 "
":meth:`~AbstractEventLoop.add_writer` 는 소켓의 파일 디스크립터만을 받아들입니다."

#: ../Doc/library/asyncio-eventloops.rst:103
msgid ""
"Pipes are not supported (ex: "
":meth:`~AbstractEventLoop.connect_read_pipe`, "
":meth:`~AbstractEventLoop.connect_write_pipe`)"
msgstr ""
"파이프는 지원되지 않습니다 (예: :meth:`~AbstractEventLoop.connect_read_pipe`, "
":meth:`~AbstractEventLoop.connect_write_pipe`)."

#: ../Doc/library/asyncio-eventloops.rst:106
msgid ""
":ref:`Subprocesses <asyncio-subprocess>` are not supported (ex: "
":meth:`~AbstractEventLoop.subprocess_exec`, "
":meth:`~AbstractEventLoop.subprocess_shell`)"
msgstr ""
":ref:`자식 프로세스 <asyncio-subprocess>` 는 지원되지 않습니다 (예: "
":meth:`~AbstractEventLoop.subprocess_exec`, "
":meth:`~AbstractEventLoop.subprocess_shell`)."

#: ../Doc/library/asyncio-eventloops.rst:110
msgid ":class:`ProactorEventLoop` specific limits:"
msgstr ":class:`ProactorEventLoop` 특정 제한:"

#: ../Doc/library/asyncio-eventloops.rst:112
msgid ":meth:`~AbstractEventLoop.create_datagram_endpoint` (UDP) is not supported"
msgstr ""
":meth:`~AbstractEventLoop.create_datagram_endpoint` (UDP) 는 지원되지 않습니다."

#: ../Doc/library/asyncio-eventloops.rst:113
msgid ""
":meth:`~AbstractEventLoop.add_reader` and "
":meth:`~AbstractEventLoop.add_writer` are not supported"
msgstr ""
":meth:`~AbstractEventLoop.add_reader`\\와 "
":meth:`~AbstractEventLoop.add_writer` 는 지원되지 않습니다."

#: ../Doc/library/asyncio-eventloops.rst:116
msgid ""
"The resolution of the monotonic clock on Windows is usually around 15.6 "
"msec. The best resolution is 0.5 msec. The resolution depends on the "
"hardware (availability of `HPET "
"<https://en.wikipedia.org/wiki/High_Precision_Event_Timer>`_) and on the "
"Windows configuration. See :ref:`asyncio delayed calls <asyncio-delayed-"
"calls>`."
msgstr ""
"윈도우에서 단조 시계의 해상도는 대개 15.6 msec 입니다. 최상의 해상도는 0.5 msec 입니다. 해상도는 하드웨어(`HPET "
"<https://en.wikipedia.org/wiki/High_Precision_Event_Timer>`_ 이 제공되는지)와 윈도우 "
"구성에 따라 다릅니다. :ref:`asyncio 지연된 호출 <asyncio-delayed-calls>` 을 참조하세요."

#: ../Doc/library/asyncio-eventloops.rst:124
msgid ":class:`ProactorEventLoop` now supports SSL."
msgstr ":class:`ProactorEventLoop`\\는 이제 SSL을 지원합니다."

#: ../Doc/library/asyncio-eventloops.rst:128
msgid "Mac OS X"
msgstr "맥 OS X"

#: ../Doc/library/asyncio-eventloops.rst:130
msgid ""
"Character devices like PTY are only well supported since Mavericks (Mac "
"OS 10.9). They are not supported at all on Mac OS 10.5 and older."
msgstr ""
"PTY와 같은 문자 장치는 Mavericks (맥 OS 10.9) 이후로만 잘 지원됩니다. 맥 OS 10.5 이하에서는 지원되지 "
"않습니다."

#: ../Doc/library/asyncio-eventloops.rst:133
msgid ""
"On Mac OS 10.6, 10.7 and 10.8, the default event loop is "
":class:`SelectorEventLoop` which uses :class:`selectors.KqueueSelector`. "
":class:`selectors.KqueueSelector` does not support character devices on "
"these versions.  The :class:`SelectorEventLoop` can be used with "
":class:`~selectors.SelectSelector` or :class:`~selectors.PollSelector` to"
" support character devices on these versions of Mac OS X. Example::"
msgstr ""
"맥 OS 10.6, 10.7 및 10.8에서, 기본 이벤트 루프는 :class:`SelectorEventLoop` 이며 "
":class:`selectors.KqueueSelector` 를 사용합니다. :class:`selectors.KqueueSelector`"
" 는 이 버전에서 문자 장치를 지원하지 않습니다. :class:`SelectorEventLoop`\\는 "
":class:`~selectors.SelectSelector` 나 :class:`~selectors.PollSelector` 와 함께 "
"사용되어 이 버전의 맥 OS X에서 문자 장치를 지원할 수 있습니다. 예를 들어::"

#: ../Doc/library/asyncio-eventloops.rst:149
msgid "Event loop policies and the default policy"
msgstr "이벤트 루프 정책과 기본 정책"

#: ../Doc/library/asyncio-eventloops.rst:151
msgid ""
"Event loop management is abstracted with a *policy* pattern, to provide "
"maximal flexibility for custom platforms and frameworks. Throughout the "
"execution of a process, a single global policy object manages the event "
"loops available to the process based on the calling context. A policy is "
"an object implementing the :class:`AbstractEventLoopPolicy` interface."
msgstr ""
"이벤트 루프 관리는 *정책(policy)* 패턴으로 추상화되어, 사용자 정의 플랫폼 및 프레임워크에 최대한의 유연성을 제공합니다. "
"프로세스 실행되는 동안, 단일 전역 정책 객체는 호출하는 컨텍스트에 기반하여 프로세스에서 사용할 수 있는 이벤트 루프를 관리합니다. "
"정책은 :class:`AbstractEventLoopPolicy` 인터페이스를 구현하는 객체입니다."

#: ../Doc/library/asyncio-eventloops.rst:157
msgid ""
"For most users of :mod:`asyncio`, policies never have to be dealt with "
"explicitly, since the default global policy is sufficient (see below)."
msgstr ""
":mod:`asyncio` 의 대부분 사용자는, 기본 전역 정책으로 충분하므로, 정책을 명시적으로 처리할 필요가 없습니다 (아래를 "
"참조하세요)."

#: ../Doc/library/asyncio-eventloops.rst:160
msgid ""
"The module-level functions :func:`get_event_loop` and "
":func:`set_event_loop` provide convenient access to event loops managed "
"by the default policy."
msgstr ""
"모듈 수준 함수 :func:`get_event_loop`\\와 :func:`set_event_loop`\\는 기본 정책에 의해 관리되는 "
"이벤트 루프에 편리한 접근을 제공합니다."

#: ../Doc/library/asyncio-eventloops.rst:166
msgid "Event loop policy interface"
msgstr "이벤트 루프 정책 인터페이스"

#: ../Doc/library/asyncio-eventloops.rst:168
msgid "An event loop policy must implement the following interface:"
msgstr "이벤트 루프 정책은 다음 인터페이스를 구현해야 합니다:"

#: ../Doc/library/asyncio-eventloops.rst:172
msgid "Event loop policy."
msgstr "이벤트 루프 정책."

#: ../Doc/library/asyncio-eventloops.rst:176
msgid "Get the event loop for the current context."
msgstr "현재 컨텍스트의 이벤트 루프를 가져옵니다."

#: ../Doc/library/asyncio-eventloops.rst:178
msgid ""
"Returns an event loop object implementing the :class:`AbstractEventLoop` "
"interface. In case called from coroutine, it returns the currently "
"running event loop."
msgstr ""
":class:`AbstractEventLoop` 인터페이스를 구현하는 이벤트 루프 객체를 반환합니다. 코루틴에서 호출되면, 현재 실행 "
"중인 이벤트 루프를 반환합니다."

#: ../Doc/library/asyncio-eventloops.rst:182
msgid ""
"Raises an exception in case no event loop has been set for the current "
"context and the current policy does not specify to create one. It must "
"never return ``None``."
msgstr ""
"현재의 컨텍스트에 이벤트 루프가 설정되어 있지 않고 현재의 정책이 이벤트 루프를 만들도록 지정하지 않으면 예외를 발생시킵니다. 절대 "
"``None`` 을 반환해서는 안 됩니다."

#: ../Doc/library/asyncio-eventloops.rst:190
msgid "Set the event loop for the current context to *loop*."
msgstr "현재 컨텍스트의 이벤트 루프를 *loop* 로 설정합니다."

#: ../Doc/library/asyncio-eventloops.rst:194
msgid ""
"Create and return a new event loop object according to this policy's "
"rules."
msgstr "이 정책의 규칙에 따라 새 이벤트 루프 객체를 만들어 반환합니다."

#: ../Doc/library/asyncio-eventloops.rst:197
msgid ""
"If there's need to set this loop as the event loop for the current "
"context, :meth:`set_event_loop` must be called explicitly."
msgstr ""
"이 루프를 현재 컨텍스트의 이벤트 루프로 설정해야 하면 :meth:`set_event_loop`\\를 명시적으로 호출해야 합니다."

#: ../Doc/library/asyncio-eventloops.rst:201
msgid ""
"The default policy defines context as the current thread, and manages an "
"event loop per thread that interacts with :mod:`asyncio`. An exception to"
" this rule happens when :meth:`~AbstractEventLoopPolicy.get_event_loop` "
"is called from a running future/coroutine, in which case it will return "
"the current loop running that future/coroutine."
msgstr ""
"기본 정책은 컨텍스트를 현재 스레드로 정의하고, :mod:`asyncio`\\와 상호 작용하는 스레드 당 하나의 이벤트 루프를 "
"관리합니다. 이 규칙에 대한 예외는 :meth:`~AbstractEventLoopPolicy.get_event_loop` 가 실행 중인 "
"퓨처/코루틴에서 호출될 때 발생합니다. 이때 그 퓨처/코루틴을 실행하고 있는 현재 루프를 반환합니다."

#: ../Doc/library/asyncio-eventloops.rst:207
msgid ""
"If the current thread doesn't already have an event loop associated with "
"it, the default policy's :meth:`~AbstractEventLoopPolicy.get_event_loop` "
"method creates one when called from the main thread, but raises "
":exc:`RuntimeError` otherwise."
msgstr ""
"만약 현재 스레드가 이미 연결된 이벤트 루프를 가지고 있지 않다면, 기본 정책의 "
":meth:`~AbstractEventLoopPolicy.get_event_loop` 메서드는 메인 스레드에서 호출될 때 하나를 "
"만들지만, 그렇지 않으면 :exc:`RuntimeError` 를 발생시킵니다."

#: ../Doc/library/asyncio-eventloops.rst:214
msgid "Access to the global loop policy"
msgstr "전역 루프 정책 액세스"

#: ../Doc/library/asyncio-eventloops.rst:218
msgid "Get the current event loop policy."
msgstr "현재 이벤트 루프 정책을 가져옵니다."

#: ../Doc/library/asyncio-eventloops.rst:222
msgid ""
"Set the current event loop policy. If *policy* is ``None``, the default "
"policy is restored."
msgstr "현재 이벤트 루프 정책을 설정합니다. *policy* 가 ``None`` 이면, 기본 정책이 복원됩니다."

#: ../Doc/library/asyncio-eventloops.rst:227
msgid "Customizing the event loop policy"
msgstr "이벤트 루프 정책 사용자 정의"

#: ../Doc/library/asyncio-eventloops.rst:229
msgid ""
"To implement a new event loop policy, it is recommended you subclass the "
"concrete default event loop policy :class:`DefaultEventLoopPolicy` and "
"override the methods for which you want to change behavior, for example::"
msgstr ""
"새로운 이벤트 루프 정책을 구현하려면, 구상 기본 이벤트 루프 정책 :class:`DefaultEventLoopPolicy`\\를 서브 "
"클래스하고, 동작을 변경할 메서드를 재정의하는 것이 좋습니다, 예를 들어::"
