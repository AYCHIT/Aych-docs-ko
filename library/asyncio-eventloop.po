# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/asyncio-eventloop.rst:6
#, fuzzy
msgid "Event Loop"
msgstr "이벤트 루프 실행"

#: ../Doc/library/asyncio-eventloop.rst:10
msgid "Preface"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:11
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:15
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to "
"reference the loop object or call its methods.  This section is intended "
"mostly for authors of lower-level code, libraries, and frameworks, who "
"need finer control over the event loop behavior."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:22
#, fuzzy
msgid "Obtaining the Event Loop"
msgstr "이벤트 루프 실행을 중지합니다."

#: ../Doc/library/asyncio-eventloop.rst:23
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:28
msgid "Return the running event loop in the current OS thread."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:30
msgid ""
"If there is no running event loop a :exc:`RuntimeError` is raised. This "
"function can only be called from a coroutine or a callback."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:37
msgid ""
"Get the current event loop.  If there is no current event loop set in the"
" current OS thread and :func:`set_event_loop` has not yet been called, "
"asyncio will create a new event loop and set it as the current one."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:42
msgid ""
"Because this function has rather complex behavior (especially when custom"
" event loop policies are in use), using the :func:`get_running_loop` "
"function is preferred to :func:`get_event_loop` in coroutines and "
"callbacks."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:47
msgid ""
"Consider also using the :func:`asyncio.run` function instead of using "
"lower level functions to manually create and close an event loop."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:52
msgid "Set *loop* as a current event loop for the current OS thread."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:56
msgid "Create a new event loop object."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:58
msgid ""
"Note that the behaviour of :func:`get_event_loop`, "
":func:`set_event_loop`, and :func:`new_event_loop` functions can be "
"altered by :ref:`setting a custom event loop policy <asyncio-policies>`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:64
msgid "Contents"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:65
msgid "This documentation page contains the following sections:"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:67
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:70
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and "
":class:`TimerHandle` instances which are returned from scheduling methods"
" such as :meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:74
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:77
msgid ""
"The `Event Loop Implementations`_ section documents the "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:80
msgid "The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:87
#, fuzzy
msgid "Event Loop Methods"
msgstr "이벤트 루프 예제"

#: ../Doc/library/asyncio-eventloop.rst:89
msgid "Event loops have **low-level** APIs for the following:"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:97
msgid "Running and stopping the loop"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:101
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:104
#, fuzzy
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly"
" scheduled to run as a :class:`asyncio.Task`."
msgstr "인자가 :ref:`코루틴 객체 <coroutine>` 면, :func:`ensure_future`\\로 쌉니다."

#: ../Doc/library/asyncio-eventloop.rst:107
#, fuzzy
msgid "Return the Future's result or raise its exception."
msgstr "퓨처의 결과를 반환하거나 퓨처의 예외를 일으킵니다."

#: ../Doc/library/asyncio-eventloop.rst:111
msgid "Run the event loop until :meth:`stop` is called."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:113
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the "
"loop will poll the I/O selector once with a timeout of zero, run all "
"callbacks scheduled in response to I/O events (and those that were "
"already scheduled), and then exit."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:118
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they"
" will run the next time :meth:`run_forever` or :meth:`run_until_complete`"
" is called."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:126
#, fuzzy
msgid "Stop the event loop."
msgstr "이벤트 루프 실행을 중지합니다."

#: ../Doc/library/asyncio-eventloop.rst:130
#, fuzzy
msgid "Return ``True`` if the event loop is currently running."
msgstr "이벤트 루프가 닫혔으면 ``True`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:134
#, fuzzy
msgid "Return ``True`` if the event loop was closed."
msgstr "이벤트 루프가 닫혔으면 ``True`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:138
#, fuzzy
msgid "Close the event loop."
msgstr "이벤트 루프 실행을 중지합니다."

#: ../Doc/library/asyncio-eventloop.rst:140
#, fuzzy
msgid ""
"The loop must be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr "이벤트 루프를 닫습니다. 루프가 실행 중이어서는 안 됩니다. 계류 중인 콜백이 손실됩니다."

#: ../Doc/library/asyncio-eventloop.rst:143
#, fuzzy
msgid ""
"This method clears all queues and shuts down the executor, but does not "
"wait for the executor to finish."
msgstr "이것은 큐를 비우고 실행기를 종료하지만, 실행기가 완료할 때까지 기다리지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:146
#, fuzzy
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr "이것은 멱등적(itempotent)이고 되돌릴 수 없습니다. 이것 이후에 다른 메서드를 호출해서는 안 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:151
#, fuzzy
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to "
"close with an :meth:`~agen.aclose()` call.  After calling this method, "
"the event loop will issue a warning if a new asynchronous generator is "
"iterated. This should be used to reliably finalize all scheduled "
"asynchronous generators."
msgstr ""
"현재 열려있는 :term:`비동기 제너레이터 <asynchronous generator>` 객체를 모두 "
":meth:`~agen.aclose()` 호출로 닫도록 스케줄 합니다. 이 메서드를 호출한 후에는, 새 비동기 생성기가 이터레이트 "
"될 때마다 이벤트 루프에서 경고를 보냅니다. 스케줄 된 모든 비동기 제너레이터를 신뢰성 있게 종료하는 데 사용해야 합니다. 예::"

#: ../Doc/library/asyncio-eventloop.rst:157
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run`"
" is used."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:160
#: ../Doc/library/asyncio-eventloop.rst:993
#: ../Doc/library/asyncio-eventloop.rst:1355
msgid "Example::"
msgstr "예::"

#: ../Doc/library/asyncio-eventloop.rst:172
msgid "Scheduling callbacks"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:176
msgid ""
"Schedule a *callback* to be called with *args* arguments at the next "
"iteration of the event loop."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:179
#, fuzzy
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"이것은 :abbr:`FIFO (first-in, first-out - 선입 선출)` 큐로 작동하며, 콜백은 등록된 순서대로 "
"호출됩니다. 각 콜백은 정확히 한 번 호출됩니다."

#: ../Doc/library/asyncio-eventloop.rst:182
#: ../Doc/library/asyncio-eventloop.rst:245
#, fuzzy
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"선택적인 키워드 전용 *context* 인자는 *callback* 을 실행할 사용자 정의 "
":class:`contextvars.Context` 를 지정할 수 있게 합니다. *context* 가 제공되지 않을 때는 현재 "
"컨텍스트가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:186
#, fuzzy
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used "
"later to cancel the callback."
msgstr ":class:`asyncio.Handle` 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:189
msgid "This method is not thread-safe."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:193
msgid ""
"A thread-safe variant of :meth:`call_soon`.  Must be used to schedule "
"callbacks *from another thread*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:196
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "설명서의 :ref:`동시성과 다중 스레딩 <asyncio-multithreading>` 절을 참고하십시오."

#: ../Doc/library/asyncio-eventloop.rst:199
#: ../Doc/library/asyncio-eventloop.rst:249
#: ../Doc/library/asyncio-eventloop.rst:269
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr "*context* 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 :pep:`567`\\을 보십시오."

#: ../Doc/library/asyncio-eventloop.rst:207
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:214
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:222
msgid "Scheduling delayed callbacks"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:224
msgid ""
"Event loop provides mechanisms to schedule callback functions to be "
"called at some point in the future.  Event loop uses monotonic clocks to "
"track time."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:231
#, fuzzy
msgid ""
"Schedule *callback* to be called after the given *delay* number of "
"seconds (can be either an int or a float)."
msgstr "지정된 *delay* 초 (int 또는 float) 뒤에 *callback* 이 호출되도록 배치합니다."

#: ../Doc/library/asyncio-eventloop.rst:234
#: ../Doc/library/asyncio-eventloop.rst:266
#, fuzzy
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used"
" to cancel the callback."
msgstr ":class:`asyncio.TimerHandle` 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:237
#, fuzzy
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled "
"for exactly the same time, the order in which they are called is "
"undefined."
msgstr ""
"*callback* 은 :meth:`call_later` 호출 당 정확히 한번 호출됩니다. 두 콜백이 정확히 같은 시간에 스케줄 "
"되면, 어떤 것이 먼저 호출되는지는 정의되지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:241
#, fuzzy
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use "
":func:`functools.partial`."
msgstr ""
"선택적 위치 *args* 는 호출 될 때 콜백에 전달됩니다. 콜백을 이름있는 인자로 호출하고 싶으면 클로저나 "
":func:`functools.partial` 를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:253
msgid ""
"In Python 3.7.0 and earlier with the default event loop implementation, "
"the *delay* could not exceed one day. This has been fixed in Python "
"3.7.1."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:260
#, fuzzy
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* "
"(an int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"지정된 절대 타임스탬프 *when*\\(int 또는 float)에 *callback* 이 호출되도록 배치합니다. "
":meth:`AbstractEventLoop.time` 와 같은 시간 참조를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:264
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "이 메서드의 동작은 :meth:`call_later`\\와 같습니다."

#: ../Doc/library/asyncio-eventloop.rst:273
msgid ""
"In Python 3.7.0 and earlier with the default event loop implementation, "
"the difference between *when* and the current time could not exceed one "
"day.  This has been fixed in Python 3.7.1."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:280
#, fuzzy
msgid ""
"Return the current time, as a :class:`float` value, according to the "
"event loop's internal monotonic clock."
msgstr "이벤트 루프의 내부 시계에 따라, :class:`float` 값으로 현재 시각을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:285
msgid "Timeouts (relative *delay* or absolute *when*) should not exceed one day."
msgstr "제한 시간(상대적인 *delay* 나 절대적인 *when*)은 1일을 초과하지 않아야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:290
msgid "The :func:`asyncio.sleep` function."
msgstr ":func:`asyncio.sleep` 함수."

#: ../Doc/library/asyncio-eventloop.rst:294
msgid "Creating Futures and Tasks"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:298
#, fuzzy
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "루프에 연결된 :class:`asyncio.Future` 객체를 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:300
#, fuzzy
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future "
"object (with better performance or instrumentation)."
msgstr ""
"이벤트 루프 구현이 Future 클래스의 다른 구현(더 나은 성능이나 인스트루멘테이션)을 제공 할 수 있으므로, asyncio에서 "
"퓨처를 만드는 데 선호되는 방법입니다."

#: ../Doc/library/asyncio-eventloop.rst:308
#, fuzzy
msgid ""
"Schedule the execution of a :ref:`coroutine`. Return a :class:`Task` "
"object."
msgstr ":ref:`코루틴 객체 <coroutine>` 의 실행을 스케줄 합니다: 퓨처로 쌉니다. :class:`Task` 객체를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:311
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of "
":class:`Task`."
msgstr ""
"제삼자 이벤트 루프는 상호 운용성을 위해 자신만의 :class:`Task` 의 서브 클래스를 사용할 수 있습니다. 이 경우, 결과 "
"형은 :class:`Task` 의 서브 클래스입니다."

#: ../Doc/library/asyncio-eventloop.rst:317
#, fuzzy
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ":meth:`AbstractEventLoop.create_task` 에 의해 사용되는 태스크 팩토리를 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:320
#, fuzzy
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise,"
" *factory* must be a *callable* with the signature matching ``(loop, "
"coro)``, where *loop* is a reference to the active event loop, and *coro*"
" is a coroutine object.  The callable must return a "
":class:`asyncio.Future`-compatible object."
msgstr ""
"*factory* 가 *콜러블* 이면, ``(loop, coro)`` 과 일치하는 서명을 가져야 합니다. 여기서 *loop* 는 "
"활성 이벤트 루프에 대한 참조가 되고, *coro* 는 코루틴 객체가 됩니다. 콜러블은 :class:`asyncio.Future` "
"호환 객체를 반환해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:328
#, fuzzy
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr "태스크 팩토리를 반환하거나, 기본값이 사용 중이면 ``None`` 을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:332
#, fuzzy
msgid "Opening network connections"
msgstr "연결 만들기"

#: ../Doc/library/asyncio-eventloop.rst:340
msgid ""
"Open a streaming transport connection to a given address specified by "
"*host* and *port*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:343
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET` or "
":py:data:`~socket.AF_INET6` depending on *host* (or the *family* "
"argument, if provided)."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:347
msgid "The socket type will be :py:data:`~socket.SOCK_STREAM`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:349
#: ../Doc/library/asyncio-eventloop.rst:917
#: ../Doc/library/asyncio-eventloop.rst:933
#, fuzzy
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol"
" <asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* 가 인자 없이 호출되고, :ref:`프로토콜(protocol) <asyncio-protocol>`"
" 인스턴스를 반환해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:352
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr "이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, ``(transport, protocol)`` 쌍을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:355
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "하부 연산의 시간순 개요는 다음과 같습니다:"

#: ../Doc/library/asyncio-eventloop.rst:357
#, fuzzy
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` "
"is created for it."
msgstr "연결이 맺어지고, 이를 표현하기 위한 :ref:`트랜스포트(transport) <asyncio-transport>` 가 만들어집니다."

#: ../Doc/library/asyncio-eventloop.rst:360
#, fuzzy
msgid ""
"*protocol_factory* is called without arguments and is expected to return "
"a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* 가 인자 없이 호출되고, :ref:`프로토콜(protocol) <asyncio-protocol>`"
" 인스턴스를 반환해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:363
#, fuzzy
msgid ""
"The protocol instance is coupled with the transport by calling its "
":meth:`~BaseProtocol.connection_made` method."
msgstr "프로토콜 인스턴스는 트랜스포트에 묶여있고, :meth:`connection_made` 메서드가 호출됩니다."

#: ../Doc/library/asyncio-eventloop.rst:366
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:368
msgid "The created transport is an implementation-dependent bidirectional stream."
msgstr "만들어진 트랜스포트는 구현 의존적인 양방향 스트림입니다."

#: ../Doc/library/asyncio-eventloop.rst:371
#: ../Doc/library/asyncio-eventloop.rst:445
msgid "Other arguments:"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:373
#, fuzzy
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default"
" a plain TCP transport is created).  If *ssl* is a "
":class:`ssl.SSLContext` object, this context is used to create the "
"transport; if *ssl* is :const:`True`, a default context returned from "
":func:`ssl.create_default_context` is used."
msgstr ""
"*ssl*: 주어지고 거짓이 아니면, SSL/TLS 트랜스포트가 만들어집니다 (기본적으로는 평범한 TCP 트랜스포트가 "
"만들어집니다). *ssl* 이 :class:`ssl.SSLContext` 객체면, 트랜스포트를 만들 때 이 컨텍스트가 사용됩니다; "
"*ssl* 이 :const:`True` 면, 지정되지 않은 기본 설정의 컨텍스트가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:379
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS 보안 고려 사항 <ssl-security>`"

#: ../Doc/library/asyncio-eventloop.rst:381
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's"
" certificate will be matched against.  Should only be passed if *ssl* is "
"not ``None``.  By default the value of the *host* argument is used.  If "
"*host* is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:389
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* 는 *host* 결정을 위해 getaddrinfo() 에 전달할 선택적 주소 "
"패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 :mod:`socket` 모듈 상수에 대응하는 정수여야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:394
msgid ""
"*sock*, if given, should be an existing, already connected "
":class:`socket.socket` object to be used by the transport. If *sock* is "
"given, none of *host*, *port*, *family*, *proto*, *flags* and "
"*local_addr* should be specified."
msgstr ""
"*sock* 이 주어지면, 트랜스포트가 사용할, 기존의 이미 연결된 :class:`socket.socket` 객체여야 합니다. "
"*sock* 이 주어지면, *host*, *port*, *family*, *proto*, *flags*, *local_addr* 를"
" 지정해서는 안 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:399
#, fuzzy
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to "
"bind the socket to locally.  The *local_host* and *local_port* are looked"
" up using ``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr* 이 주어지면, 소켓을 로컬에 바인드하는데 사용되는 ``(local_host, local_port)`` "
"튜플이어야 합니다. *local_host* 와 *local_port* 는 *host* 및 *port* 와 유사하게 "
"getaddrinfo() 를 사용하여 조회됩니다."

#: ../Doc/library/asyncio-eventloop.rst:403
#: ../Doc/library/asyncio-eventloop.rst:726
#, fuzzy
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 "
"대기하는 시간(초)입니다. ``None`` (기본값) 이면 ``60.0`` 초가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:409
#: ../Doc/library/asyncio-eventloop.rst:511
#: ../Doc/library/asyncio-eventloop.rst:664
msgid "The *ssl_handshake_timeout* parameter."
msgstr "*ssl_handshake_timeout* 매개 변수."

#: ../Doc/library/asyncio-eventloop.rst:413
#: ../Doc/library/asyncio-eventloop.rst:594
msgid ""
"The socket option :py:data:`~socket.TCP_NODELAY` is set by default for "
"all TCP connections."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:418
#: ../Doc/library/asyncio-eventloop.rst:599
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:422
#, fuzzy
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It"
" returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that "
"can be used directly in async/await code."
msgstr ""
":func:`open_connection` 함수는 프로토콜 대신 (:class:`StreamReader`, "
":class:`StreamWriter`) 쌍을 얻는 데 사용할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:432
#, fuzzy
msgid "Create a datagram connection."
msgstr "연결 만들기"

#: ../Doc/library/asyncio-eventloop.rst:434
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET`, "
":py:data:`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`, depending on "
"*host* (or the *family* argument, if provided)."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:438
msgid "The socket type will be :py:data:`~socket.SOCK_DGRAM`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:440
#: ../Doc/library/asyncio-eventloop.rst:536
#: ../Doc/library/asyncio-eventloop.rst:647
#, fuzzy
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* 가 인자 없이 호출되고, :ref:`프로토콜(protocol) <asyncio-protocol>`"
" 인스턴스를 반환해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:443
#: ../Doc/library/asyncio-eventloop.rst:497
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:447
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to "
"bind the socket to locally.  The *local_host* and *local_port* are looked"
" up using :meth:`getaddrinfo`."
msgstr ""
"*local_addr* 이 주어지면, 소켓을 로컬에 바인드하는 데 사용되는 ``(local_host, local_port)`` "
"튜플입니다. *local_host* 와 *local_port* 는 :meth:`getaddrinfo`\\를 사용하여 조회됩니다."

#: ../Doc/library/asyncio-eventloop.rst:451
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used "
"to connect the socket to a remote address.  The *remote_host* and "
"*remote_port* are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr* 이 주어지면, 소켓을 원격 주소에 연결하는 데 사용되는 ``(remote_host, "
"remote_port)`` 튜플입니다. *remote_host* 와 *remote_port* 는 "
":meth:`getaddrinfo`\\를 사용하여 조회됩니다."

#: ../Doc/library/asyncio-eventloop.rst:455
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. "
"If given, these should all be integers from the corresponding "
":mod:`socket` module constants."
msgstr ""
"*family*, *proto*, *flags* 는 *host* 결정을 위해 :meth:`getaddrinfo` 에 전달할 선택적 "
"주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 :mod:`socket` 모듈 상수에 대응하는 정수여야 "
"합니다."

#: ../Doc/library/asyncio-eventloop.rst:460
#: ../Doc/library/asyncio-eventloop.rst:568
#, fuzzy
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT``"
" state, without waiting for its natural timeout to expire. If not "
"specified will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* 는, 일반적인 시간제한이 만료될 때까지 기다리지 않고, TIME_WAIT 상태의 로컬 소켓을 "
"재사용하도록 커널에 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 ``True`` 로 설정됩니다."

#: ../Doc/library/asyncio-eventloop.rst:465
#, fuzzy
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the "
"same port as other existing endpoints are bound to, so long as they all "
"set this flag when being created. This option is not supported on Windows"
" and some Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not "
"defined then this capability is unsupported."
msgstr ""
"*reuse_port* 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드"
" 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우나 일부 유닉스에서는 지원되지 않습니다. "
":py:data:`~socket.SO_REUSEPORT` 상수가 정의되어 있지 않으면, 이 기능은 지원되지 않는 것입니다."

#: ../Doc/library/asyncio-eventloop.rst:471
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send "
"messages to the broadcast address."
msgstr "*allow_broadcast* 는 이 말단이 브로드 캐스트 주소로 메시지를 보낼 수 있도록 커널에 알립니다."

#: ../Doc/library/asyncio-eventloop.rst:474
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already"
" connected, :class:`socket.socket` object to be used by the transport. If"
" specified, *local_addr* and *remote_addr* should be omitted (must be "
":const:`None`)."
msgstr ""
"*sock* 은 트랜스포트가 사용할 소켓 객체로, 기존의 이미 연결된 :class:`socket.socket` 객체를 사용하기 위해"
" 선택적으로 지정할 수 있습니다. 지정되면 *local_addr* 과 *remote_addr* 를 생략해야 합니다 (반드시 "
":const:`None` 이어야 합니다)."

#: ../Doc/library/asyncio-eventloop.rst:479
#, fuzzy
msgid "On Windows, with :class:`ProactorEventLoop`, this method is not supported."
msgstr "윈도우에서 :class:`ProactorEventLoop`\\를 사용할 때, 이 메서드는 지원되지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:481
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` "
"and :ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` "
"examples."
msgstr ""
":ref:`UDP 에코 클라이언트 프로토콜 <asyncio-udp-echo-client-protocol>` 과 :ref:`UDP "
"에코 서버 프로토콜 <asyncio-udp-echo-server-protocol>` 예제를 참고하세요."

#: ../Doc/library/asyncio-eventloop.rst:484
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"*family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, *sock* 매개 변수가 추가되었습니다."

#: ../Doc/library/asyncio-eventloop.rst:492
#, fuzzy
msgid "Create a Unix connection."
msgstr "연결 만들기"

#: ../Doc/library/asyncio-eventloop.rst:494
msgid ""
"The socket family will be :py:data:`~socket.AF_UNIX`; socket type will be"
" :py:data:`~socket.SOCK_STREAM`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:499
#, fuzzy
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a "
"*sock* parameter is specified.  Abstract Unix sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* 는 유닉스 도메인 소켓의 이름이며, *sock* 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, "
":class:`str`, :class:`bytes`, :class:`~pathlib.Path` 경로가 지원됩니다."

#: ../Doc/library/asyncio-eventloop.rst:504
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:508
#: ../Doc/library/asyncio-eventloop.rst:628
#: ../Doc/library/asyncio-eventloop.rst:976
#, fuzzy
msgid "Availability: Unix."
msgstr "가용성: 유닉스."

#: ../Doc/library/asyncio-eventloop.rst:515
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr "*path* 매개 변수는 이제 :term:`경로류 객체 <path-like object>` 가 될 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:519
msgid "Creating network servers"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:529
#, fuzzy
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening "
"on *port* of the *host* address."
msgstr "*host* 와 *port* 에 바인드 된 TCP 서버(소켓 유형 :data:`~socket.SOCK_STREAM`)를 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:532
#, fuzzy
msgid "Returns a :class:`Server` object."
msgstr "이 메서드는 :class:`asyncio.Future` 객체를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:534
#, fuzzy
msgid "Arguments:"
msgstr "매개 변수:"

#: ../Doc/library/asyncio-eventloop.rst:539
msgid ""
"The *host* parameter can be set to several types which determine where "
"the server would be listening:"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:542
msgid ""
"If *host* is a string, the TCP server is bound to a single network "
"interface specified by *host*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:545
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all "
"network interfaces specified by the sequence."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:548
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and "
"a list of multiple sockets will be returned (most likely one for IPv4 and"
" another one for IPv6)."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:552
#, fuzzy
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or "
":data:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6. If not "
"set, the *family* will be determined from host name (defaults to "
":data:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* 는 :data:`socket.AF_INET` 또는 :data:`~socket.AF_INET6` 중 하나로 설정되어,"
" 소켓이 IPv4 또는 IPv6을 사용하게 할 수 있습니다. 설정되지 않으면 host에 의해 결정됩니다(기본값 "
":data:`socket.AF_UNSPEC`)."

#: ../Doc/library/asyncio-eventloop.rst:557
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* 은 :meth:`getaddrinfo`\\를 위한 비트 마스크입니다."

#: ../Doc/library/asyncio-eventloop.rst:559
#, fuzzy
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* 은 기존 소켓 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면, *host* 및 *port* 를 생략해야"
" 합니다 (반드시 :const:`None` 이어야 합니다)."

#: ../Doc/library/asyncio-eventloop.rst:562
msgid ""
"*backlog* is the maximum number of queued connections passed to "
":meth:`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* 는 :meth:`~socket.socket.listen` 으로 전달되는 최대 대기 연결 수 입니다 (기본값은 "
"100)."

#: ../Doc/library/asyncio-eventloop.rst:565
#, fuzzy
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS "
"over the accepted connections."
msgstr "*ssl* 을 :class:`~ssl.SSLContext` 로 설정하면, 들어오는 연결에 SSL을 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:573
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the "
"same port as other existing endpoints are bound to, so long as they all "
"set this flag when being created. This option is not supported on "
"Windows."
msgstr ""
"*reuse_port* 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드"
" 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우에서 지원되지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:578
#, fuzzy
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait"
" for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 은 (SSL 서버의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 "
"대기하는 시간(초)입니다. ``None`` (기본값) 이면 ``60.0`` 초가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:582
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server "
"to start accepting connections immediately.  When set to ``False``, the "
"user should await on :meth:`Server.start_serving` or "
":meth:`Server.serve_forever` to make the server to start accepting "
"connections."
msgstr ""
"*start_serving* 을 ``True`` (기본값) 로 설정하면, 생성된 서버가 즉시 연결을 받아들입니다. ``False``"
" 로 설정되면, 사용자는 서버가 연결을 받기 시작하도록 :meth:`Server.start_serving` 이나 "
":meth:`Server.serve_forever`\\를 await 해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:590
#, fuzzy
msgid "Added *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "*ssl_handshake_timeout* 과 *start_serving* 매개 변수."

#: ../Doc/library/asyncio-eventloop.rst:603
#, fuzzy
msgid "The *host* parameter can be a sequence of strings."
msgstr "*host* 매개 변수는 이제 문자열의 시퀀스가 될 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:607
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that "
"can be used in an async/await code."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:616
#, fuzzy
msgid ""
"Similar to :meth:`loop.create_server` but works with the "
":py:data:`~socket.AF_UNIX` socket family."
msgstr ""
":meth:`AbstractEventLoop.create_server`\\와 유사하지만, 소켓 패밀리 "
":py:data:`~socket.AF_UNIX` 전용입니다."

#: ../Doc/library/asyncio-eventloop.rst:619
#, fuzzy
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a "
"*sock* argument is provided.  Abstract Unix sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* 는 유닉스 도메인 소켓의 이름이며, *sock* 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, "
":class:`str`, :class:`bytes`, :class:`~pathlib.Path` 경로가 지원됩니다."

#: ../Doc/library/asyncio-eventloop.rst:624
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:631
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "*ssl_handshake_timeout* 과 *start_serving* 매개 변수."

#: ../Doc/library/asyncio-eventloop.rst:635
msgid "The *path* parameter can now be a :class:`~pathlib.Path` object."
msgstr "*path* 매개 변수는 이제 :class:`~pathlib.Path` 객체일 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:640
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:642
#, fuzzy
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr "이것은 asyncio 밖에서 연결을 받아들이지만, 그 연결을 처리하는데 asyncio 를 사용하는 서버에서 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:645
#: ../Doc/library/asyncio-eventloop.rst:712
msgid "Parameters:"
msgstr "매개 변수:"

#: ../Doc/library/asyncio-eventloop.rst:650
#, fuzzy
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr "*sock* 은 ``accept`` 이 반환한 기존 소켓 객체입니다."

#: ../Doc/library/asyncio-eventloop.rst:653
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr "*ssl* 을 :class:`~ssl.SSLContext` 로 설정하면, 들어오는 연결에 SSL을 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:656
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to"
" wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 "
"대기하는 시간(초)입니다. ``None`` (기본값) 이면 ``60.0`` 초가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:660
#, fuzzy
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "완료되면 ``(transport, protocol)`` 쌍을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:670
#, fuzzy
msgid "Transferring files"
msgstr "파일 전송"

#: ../Doc/library/asyncio-eventloop.rst:675
#, fuzzy
msgid "Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr "*file* 을 *transport* 로 보내고, 전송된 총 바이트 수를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:678
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr "이 메서드는 가능한 경우 고성능 :meth:`os.sendfile` 을 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:680
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* 는 바이너리 모드로 열린 일반 파일 객체여야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:682
#: ../Doc/library/asyncio-eventloop.rst:872
#, fuzzy
msgid ""
"*offset* tells from where to start reading the file. If specified, "
"*count* is the total number of bytes to transmit as opposed to sending "
"the file until EOF is reached. File position is always updated, even when"
" this method raises an error, and :meth:`file.tell() <io.IOBase.tell>` "
"can be used to obtain the actual number of bytes sent."
msgstr ""
"*offset* 은 파일 읽기 시작할 위치를 알려줍니다. *count* 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, "
"전송할 총 바이트 수를 지정합니다. 반환할 때나 오류가 발생했을 때 파일의 위치가 갱신됩니다. 이 경우 "
":meth:`file.tell() <io.IOBase.tell>` 는 전송된 바이트 수를 계산하는 데 사용될 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:689
#, fuzzy
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the "
"file when the platform does not support the sendfile system call (e.g. "
"Windows or SSL socket on Unix)."
msgstr ""
"*fallback* 을 ``True`` 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 "
"SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다."

#: ../Doc/library/asyncio-eventloop.rst:693
#, fuzzy
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the"
" *sendfile* syscall and *fallback* is ``False``."
msgstr ""
"시스템이 *sendfile* 시스템 호출을 지원하지 않고 *fallback* 이 ``False`` 면 "
":exc:`SendfileNotAvailableError` 를 발생시킵니다."

#: ../Doc/library/asyncio-eventloop.rst:700
msgid "TLS Upgrade"
msgstr "TLS 업그레이드"

#: ../Doc/library/asyncio-eventloop.rst:706
#, fuzzy
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "기존 연결을 TLS로 업그레이드합니다."

#: ../Doc/library/asyncio-eventloop.rst:708
#, fuzzy
msgid ""
"Return a new transport instance, that the *protocol* must start using "
"immediately after the *await*.  The *transport* instance passed to the "
"*start_tls* method should never be used again."
msgstr ""
"*protocol* 이 *await* 의 직후에 사용해야 하는 새로운 트랜스포트 인스턴스를 반환합니다. *start_tls* "
"메서드에 전달된 *transport* 인스턴스는 절대로 다시 사용해서는 안 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:714
#, fuzzy
msgid ""
"*transport* and *protocol* instances that methods like "
":meth:`~loop.create_server` and :meth:`~loop.create_connection` return."
msgstr ""
":meth:`~AbstractEventLoop.create_server`\\와 "
":meth:`~AbstractEventLoop.create_connection` 같은 메서드가 반환하는 *transport* 와 "
"*protocol* 인스턴스."

#: ../Doc/library/asyncio-eventloop.rst:718
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: 구성된 :class:`~ssl.SSLContext` 의 인스턴스."

#: ../Doc/library/asyncio-eventloop.rst:720
#, fuzzy
msgid ""
"*server_side* pass ``True`` when a server-side connection is being "
"upgraded (like the one created by :meth:`~loop.create_server`)."
msgstr ""
"(:meth:`~AbstractEventLoop.create_server` 에 의해 생성된 것과 같은) 서버 측 연결이 업그레이드될"
" 때 *server_side* 에 ``True`` 를 전달합니다."

#: ../Doc/library/asyncio-eventloop.rst:723
msgid ""
"*server_hostname*: sets or overrides the host name that the target "
"server's certificate will be matched against."
msgstr "*server_hostname*: 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다."

#: ../Doc/library/asyncio-eventloop.rst:734
#, fuzzy
msgid "Watching file descriptors"
msgstr "파일 기술자 관찰하기"

#: ../Doc/library/asyncio-eventloop.rst:738
#, fuzzy
msgid ""
"Start monitoring the *fd* file descriptor for read availability and "
"invoke *callback* with the specified arguments once *fd* is available for"
" reading."
msgstr "파일 기술자가 읽기 가능한지 관찰하기 시작하고, 그런 다음 지정한 인자로 *callback* 을 호출합니다."

#: ../Doc/library/asyncio-eventloop.rst:744
#, fuzzy
msgid "Stop monitoring the *fd* file descriptor for read availability."
msgstr "파일 기술자가 읽기 가능한지 관찰하는 것을 중단합니다."

#: ../Doc/library/asyncio-eventloop.rst:748
#, fuzzy
msgid ""
"Start monitoring the *fd* file descriptor for write availability and "
"invoke *callback* with the specified arguments once *fd* is available for"
" writing."
msgstr "파일 기술자가 쓰기 가능한지 관찰하기 시작하고, 그런 다음 지정한 인자로 *callback* 을 호출합니다."

#: ../Doc/library/asyncio-eventloop.rst:752
#: ../Doc/library/asyncio-eventloop.rst:966
#: ../Doc/library/asyncio-eventloop.rst:1036
#, fuzzy
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-"
"pass-keywords>` to *func*."
msgstr ""
":ref:`functools.partial을 사용하여 키워드를 *func* 에 전달하십시오 <asyncio-pass-"
"keywords>`."

#: ../Doc/library/asyncio-eventloop.rst:757
#, fuzzy
msgid "Stop monitoring the *fd* file descriptor for write availability."
msgstr "파일 기술자가 쓰기 가능한지 관찰하는 것을 중단합니다."

#: ../Doc/library/asyncio-eventloop.rst:759
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for "
"some limitations of these methods."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:764
msgid "Working with socket objects directly"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:766
msgid ""
"In general, protocol implementations that use transport-based APIs such "
"as :meth:`loop.create_connection` and :meth:`loop.create_server` are "
"faster than implementations that work with sockets directly. However, "
"there are some use cases when performance is not critical, and working "
"with :class:`~socket.socket` objects directly is more convenient."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:775
#, fuzzy
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of "
":meth:`socket.recv() <socket.socket.recv>`."
msgstr ":meth:`socket.socket.sendfile` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:778
msgid "Return the received data as a bytes object."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:780
#: ../Doc/library/asyncio-eventloop.rst:794
#: ../Doc/library/asyncio-eventloop.rst:809
#: ../Doc/library/asyncio-eventloop.rst:822
#: ../Doc/library/asyncio-eventloop.rst:848
#: ../Doc/library/asyncio-eventloop.rst:886
#, fuzzy
msgid "*sock* must be a non-blocking socket."
msgstr "소켓 *sock* 은 비 블로킹이어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:782
#, fuzzy
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 "
"this is an ``async def`` method."
msgstr ""
"이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 :class:`Future`\\를 반환했습니다. 파이썬 "
"3.7부터, 이것은 ``async def`` 메서드입니다."

#: ../Doc/library/asyncio-eventloop.rst:789
#, fuzzy
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the "
"blocking :meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr "소켓에서 데이터를 수신합니다. 블로킹 :meth:`socket.socket.recv_into` 메서드를 따라 만들어졌습니다."

#: ../Doc/library/asyncio-eventloop.rst:792
msgid "Return the number of bytes written to the buffer."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:800
#, fuzzy
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of "
":meth:`socket.sendall() <socket.socket.sendall>`."
msgstr ":meth:`socket.socket.sendfile` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:803
#, fuzzy
msgid ""
"This method continues to send to the socket until either all data in "
"*data* has been sent or an error occurs.  ``None`` is returned on "
"success.  On error, an exception is raised. Additionally, there is no way"
" to determine how much data, if any, was successfully processed by the "
"receiving end of the connection."
msgstr ""
"소켓은 원격 소켓에 연결되어 있어야만 합니다. 이 메서드는 모든 데이터가 송신되거나 오류가 발생할 때까지 *data* 에서 데이터를"
" 계속 송신합니다. 성공하면 ``None`` 이 반환됩니다. 오류가 발생하면 예외가 발생하고, 연결의 수신 단에서 성공적으로 처리한"
" (있기는 하다면) 데이터의 크기를 확인하는 방법은 없습니다."

#: ../Doc/library/asyncio-eventloop.rst:811
msgid ""
"Even though the method was always documented as a coroutine method, "
"before Python 3.7 it returned an :class:`Future`. Since Python 3.7, this "
"is an ``async def`` method."
msgstr ""
"이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 :class:`Future`\\를 반환했습니다. 파이썬 "
"3.7부터, 이것은 ``async def`` 메서드입니다."

#: ../Doc/library/asyncio-eventloop.rst:818
msgid "Connect *sock* to a remote socket at *address*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:820
#, fuzzy
msgid "Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr ":meth:`socket.socket.sendfile` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:824
#, fuzzy
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to"
" check if the *address* is already resolved by calling "
":func:`socket.inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used "
"to resolve the *address*."
msgstr ""
"``address`` 는 더는 결정될 필요가 없습니다. ``sock_connect`` 는 "
":func:`socket.inet_pton`\\을 호출하여 *address* 가 이미 결정되었는지를 검사합니다. 그렇지 않으면, "
":meth:`AbstractEventLoop.getaddrinfo` 가 *address* 를 결정하는 데 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:833
#, fuzzy
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`AbstractEventLoop.create_connection`\\과 "
":func:`asyncio.open_connection() <open_connection>`."

#: ../Doc/library/asyncio-eventloop.rst:839
#, fuzzy
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr "연결을 받아들입니다. 블로킹 :meth:`socket.socket.accept` 를 따라 만들어졌습니다."

#: ../Doc/library/asyncio-eventloop.rst:842
msgid ""
"The socket must be bound to an address and listening for connections. The"
" return value is a pair ``(conn, address)`` where *conn* is a *new* "
"socket object usable to send and receive data on the connection, and "
"*address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"소켓은 주소에 바인드 되어 연결을 리스닝해야 합니다. 반환 값은 ``(conn, address)`` 쌍인데, *conn* 은 연결로"
" 데이터를 주고받을 수 있는 *새* 소켓 객체이고, *address* 는 연결의 반대편 끝의 소켓에 바인드 된 주소입니다."

#: ../Doc/library/asyncio-eventloop.rst:850
msgid ""
"Even though the method was always documented as a coroutine method, "
"before Python 3.7 it returned a :class:`Future`. Since Python 3.7, this "
"is an ``async def`` method."
msgstr ""
"이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 :class:`Future`\\를 반환했습니다. 파이썬 "
"3.7부터, 이것은 ``async def`` 메서드입니다."

#: ../Doc/library/asyncio-eventloop.rst:857
#, fuzzy
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`AbstractEventLoop.create_server`\\와 :func:`start_server`."

#: ../Doc/library/asyncio-eventloop.rst:862
#, fuzzy
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return"
" the total number of bytes sent."
msgstr "가능하면 고성능 :mod:`os.sendfile` 을 사용하여 파일을 보내고, 전송된 총 바이트 수를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:865
#, fuzzy
msgid ""
"Asynchronous version of :meth:`socket.sendfile() "
"<socket.socket.sendfile>`."
msgstr ":meth:`socket.socket.sendfile` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:867
#, fuzzy
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` "
":class:`~socket.socket`."
msgstr ""
"*sock* 은 반드시 :const:`socket.SOCK_STREAM` 유형의 비 블로킹 "
":class:`~socket.socket` 이어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:870
#, fuzzy
msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* 는 바이너리 모드로 열린 일반 파일 객체여야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:879
#, fuzzy
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send "
"the file when the platform does not support the sendfile syscall (e.g. "
"Windows or SSL socket on Unix)."
msgstr ""
"*fallback* 을 ``True`` 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 "
"SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다."

#: ../Doc/library/asyncio-eventloop.rst:883
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"시스템이 *sendfile* 시스템 호출을 지원하지 않고 *fallback* 이 ``False`` 면 "
":exc:`SendfileNotAvailableError` 를 발생시킵니다."

#: ../Doc/library/asyncio-eventloop.rst:892
msgid "DNS"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:897
#, fuzzy
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr ":meth:`socket.socket.sendfile` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:901
#, fuzzy
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr ":meth:`socket.socket.sendfile` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:903
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning"
" :class:`asyncio.Future` objects.  Starting with Python 3.7 both methods "
"are coroutines."
msgstr ""
"*getaddrinfo* 와 *getnameinfo* 메서드는 모두 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에 실제로는"
" :class:`asyncio.Future` 객체를 반환했습니다. Python 3.7부터 두 가지 메서드 모두 코루틴입니다."

#: ../Doc/library/asyncio-eventloop.rst:911
msgid "Working with pipes"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:915
#, fuzzy
msgid "Register the read end of *pipe* in the event loop."
msgstr "이벤트 루프에 읽기 파이프를 등록합니다."

#: ../Doc/library/asyncio-eventloop.rst:920
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:922
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the "
":class:`ReadTransport` interface and *protocol* is an object instantiated"
" by the *protocol_factory*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:926
#: ../Doc/library/asyncio-eventloop.rst:942
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ":class:`SelectorEventLoop` 이벤트 루프를 사용하면, *pipe* 는 비 블로킹 모드로 설정됩니다."

#: ../Doc/library/asyncio-eventloop.rst:931
#, fuzzy
msgid "Register the write end of *pipe* in the event loop."
msgstr "이벤트 루프에 쓰기 파이프를 등록합니다."

#: ../Doc/library/asyncio-eventloop.rst:936
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:938
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports "
":class:`WriteTransport` interface and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:947
#, fuzzy
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows."
"  Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
"윈도우에서 :class:`SelectorEventLoop`\\를 사용할 때, 이 메서드는 지원되지 않습니다. 윈도우에서 파이프를 "
"지원하려면 :class:`ProactorEventLoop`\\를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:952
#, fuzzy
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
":meth:`AbstractEventLoop.subprocess_exec` 와 "
":meth:`AbstractEventLoop.subprocess_shell` 메서드."

#: ../Doc/library/asyncio-eventloop.rst:957
#, fuzzy
msgid "Unix signals"
msgstr "유닉스 시그널"

#: ../Doc/library/asyncio-eventloop.rst:961
msgid "Set *callback* as the handler for the *signum* signal."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:963
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"시그널 번호가 유효하지 않거나 잡을 수 없으면 :exc:`ValueError` 를 발생시킵니다. 처리기를 설정하는 데 문제가 있는 "
"경우 :exc:`RuntimeError` 를 발생시킵니다."

#: ../Doc/library/asyncio-eventloop.rst:971
#, fuzzy
msgid "Remove the handler for the *sig* signal."
msgstr "시그널 처리기를 제거합니다."

#: ../Doc/library/asyncio-eventloop.rst:973
#, fuzzy
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr "시그널 처리기가 제거되면 ``True`` 를, 그렇지 않으면 ``False`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:980
msgid "The :mod:`signal` module."
msgstr ":mod:`signal` 모듈."

#: ../Doc/library/asyncio-eventloop.rst:984
msgid "Executing code in thread or process pools"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:988
#, fuzzy
msgid "Arrange for *func* to be called in the specified executor."
msgstr "지정된 실행기에서 *func* 가 호출되도록 배치합니다."

#: ../Doc/library/asyncio-eventloop.rst:990
#, fuzzy
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor`"
" instance. The default executor is used if *executor* is ``None``."
msgstr ""
"*executor* 인자는 :class:`~concurrent.futures.Executor` 인스턴스여야 합니다. "
"*executor* 가 ``None`` 이면 기본 실행기가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1034
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "이 메서드는 :class:`asyncio.Future` 객체를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1039
#, fuzzy
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of "
"the thread pool executor it creates, instead leaving it up to the thread "
"pool executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set "
"the default."
msgstr ""
":meth:`BaseEventLoop.run_in_executor` 는 더는 자신이 만드는 스레드 풀 실행기의 "
"``max_workers`` 를 설정하지 않습니다. 대신 스레드 풀 "
"실행기(:class:`~concurrent.futures.ThreadPoolExecutor`)가 스스로 기본값을 설정하도록 합니다."

#: ../Doc/library/asyncio-eventloop.rst:1048
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* should be an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1052
msgid ""
"Using an executor that is not an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor` is deprecated and will "
"trigger an error in Python 3.9."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1057
msgid ""
"*executor* must be an instance of "
":class:`concurrent.futures.ThreadPoolExecutor`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1062
msgid "Error Handling API"
msgstr "에러 처리 API"

#: ../Doc/library/asyncio-eventloop.rst:1064
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "이벤트 루프에서 예외를 처리하는 방법을 사용자 정의 할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1068
msgid "Set *handler* as the new event loop exception handler."
msgstr "*handler* 를 새 이벤트 루프 예외 처리기로 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:1070
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching "
"``(loop, context)``, where ``loop`` is a reference to the active event "
"loop, and ``context`` is a ``dict`` object containing the details of the "
"exception (see :meth:`call_exception_handler` documentation for details "
"about context)."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1080
#, fuzzy
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr "예외 처리기를 반환하거나, 기본값이 사용 중이면 ``None`` 을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1087
msgid "Default exception handler."
msgstr "기본 예외 처리기."

#: ../Doc/library/asyncio-eventloop.rst:1089
#, fuzzy
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to "
"the default handler behavior."
msgstr ""
"예외가 발생하고 예외 처리기가 설정되지 않았을 때 호출됩니다. 기본 동작으로 위임하려는 사용자 정의 예외 처리기가 호출할 수 "
"있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1093
msgid ""
"*context* parameter has the same meaning as in "
":meth:`call_exception_handler`."
msgstr "*context* 매개 변수는 :meth:`call_exception_handler` 에서와 같은 의미입니다."

#: ../Doc/library/asyncio-eventloop.rst:1098
msgid "Call the current event loop exception handler."
msgstr "현재 이벤트 루프 예외 처리기를 호출합니다."

#: ../Doc/library/asyncio-eventloop.rst:1100
#, fuzzy
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys "
"may be introduced in future Python versions):"
msgstr "*context* 는 다음 키를 포함하는 ``dict`` 객체입니다 (새 키가 나중에 추가될 수 있습니다):"

#: ../Doc/library/asyncio-eventloop.rst:1103
msgid "'message': Error message;"
msgstr "'message': 에러 메시지;"

#: ../Doc/library/asyncio-eventloop.rst:1104
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (선택적): 예외 객체;"

#: ../Doc/library/asyncio-eventloop.rst:1105
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (선택적): :class:`asyncio.Future` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1106
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (선택적): :class:`asyncio.Handle` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1107
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "'protocol' (선택적): :ref:`프로토콜 <asyncio-protocol>` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1108
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr "'transport' (선택적): :ref:`트랜스포트 <asyncio-transport>` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1109
msgid "'socket' (optional): :class:`socket.socket` instance."
msgstr "'socket' (선택적): :class:`socket.socket` 인스턴스."

#: ../Doc/library/asyncio-eventloop.rst:1113
#, fuzzy
msgid ""
"This method should not be overloaded in subclassed event loops.  For "
"custom exception handling, use the :meth:`set_exception_handler()` "
"method."
msgstr ""
"이 메서드는 서브 클래스 된 이벤트 루프에서 재정의되지 않아야 합니다. 사용자 정의 예외 처리를 위해서는 "
":meth:`set_exception_handler()` 메서드를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1118
#, fuzzy
msgid "Enabling debug mode"
msgstr "디버그 모드"

#: ../Doc/library/asyncio-eventloop.rst:1122
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "이벤트 루프의 디버그 모드(:class:`bool`)를 가져옵니다."

#: ../Doc/library/asyncio-eventloop.rst:1124
msgid ""
"The default value is ``True`` if the environment variable "
":envvar:`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` "
"otherwise."
msgstr ""
"기본값은 환경 변수 :envvar:`PYTHONASYNCIODEBUG` 가 비어 있지 않은 문자열로 설정되면 ``True`` 이고,"
" 그렇지 않으면 ``False`` 입니다."

#: ../Doc/library/asyncio-eventloop.rst:1130
msgid "Set the debug mode of the event loop."
msgstr "이벤트 루프의 디버그 모드를 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:1134
msgid ""
"The new ``-X dev`` command line option can now also be used to enable the"
" debug mode."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1139
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`asyncio의 디버그 모드 <asyncio-debug-mode>`."

#: ../Doc/library/asyncio-eventloop.rst:1143
msgid "Running Subprocesses"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1145
msgid ""
"Methods described in this subsections are low-level.  In regular "
"async/await code consider using the high-level "
":func:`asyncio.create_subprocess_shell` and "
":func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1152
msgid ""
"The default asyncio event loop on **Windows** does not support "
"subprocesses. See :ref:`Subprocess Support on Windows <asyncio-windows-"
"subprocess>` for details."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1160
msgid "Create a subprocess from one or more string arguments specified by *args*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1163
msgid "*args* must be a list of strings represented by:"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1165
msgid ":class:`str`;"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1166
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1169
msgid ""
"The first string specifies the program executable, and the remaining "
"strings specify the arguments.  Together, string arguments form the "
"``argv`` of the program."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1173
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single "
"argument which is list of strings, *subprocess_exec* takes multiple "
"string arguments."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1179
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`asyncio.SubprocessProtocol` class."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1182
#, fuzzy
msgid "Other parameters:"
msgstr "매개 변수:"

#: ../Doc/library/asyncio-eventloop.rst:1184
msgid ""
"*stdin*: either a file-like object representing a pipe to be connected to"
" the subprocess's standard input stream using "
":meth:`~loop.connect_write_pipe`, or the :const:`subprocess.PIPE`  "
"constant (default). By default a new pipe will be created and connected."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1190
msgid ""
"*stdout*: either a file-like object representing the pipe to be connected"
" to the subprocess's standard output stream using "
":meth:`~loop.connect_read_pipe`, or the :const:`subprocess.PIPE` constant"
" (default). By default a new pipe will be created and connected."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1196
msgid ""
"*stderr*: either a file-like object representing the pipe to be connected"
" to the subprocess's standard error stream using "
":meth:`~loop.connect_read_pipe`, or one of :const:`subprocess.PIPE` "
"(default) or :const:`subprocess.STDOUT` constants."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1202
msgid ""
"By default a new pipe will be created and connected. When "
":const:`subprocess.STDOUT` is specified, the subprocess' standard error "
"stream will be connected to the same pipe as the standard output stream."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1207
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` "
"without interpretation, except for *bufsize*, *universal_newlines* and "
"*shell*, which should not be specified at all."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1211
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for "
"documentation on other arguments."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1214
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms "
"to the :class:`asyncio.SubprocessTransport` base class and *protocol* is "
"an object instantiated by the *protocol_factory*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1222
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a "
":class:`bytes` string encoded to the :ref:`filesystem encoding "
"<filesystem-encoding>`, using the platform's \"shell\" syntax."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1227
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1230
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`SubprocessProtocol` class."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1233
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1236
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms "
"to the :class:`SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1241
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly"
" escape whitespace and special characters in strings that are going to be"
" used to construct shell commands."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1250
msgid "Callback Handles"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1254
#, fuzzy
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, "
":meth:`loop.call_soon_threadsafe`."
msgstr ""
":func:`AbstractEventLoop.call_soon`, "
":func:`AbstractEventLoop.call_soon_threadsafe` 에 의해 반환되는 콜백 래퍼 객체."

#: ../Doc/library/asyncio-eventloop.rst:1259
#, fuzzy
msgid ""
"Cancel the callback.  If the callback has already been canceled or "
"executed, this method has no effect."
msgstr "호출을 취소합니다. 콜백이 이미 취소되었거나 실행되었다면 이 메서드는 아무 효과가 없습니다."

#: ../Doc/library/asyncio-eventloop.rst:1264
#, fuzzy
msgid "Return ``True`` if the callback was cancelled."
msgstr "호출이 취소되었으면 ``True`` 을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1270
#, fuzzy
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and "
":meth:`loop.call_at`."
msgstr ""
":func:`AbstractEventLoop.call_later` 및 :func:`AbstractEventLoop.call_at` "
"에 의해 반환되는 콜백 래퍼 객체."

#: ../Doc/library/asyncio-eventloop.rst:1273
#, fuzzy
msgid "This class is a subclass of :class:`Handle`."
msgstr "이 클래스는 :class:`Handle`\\을 상속합니다."

#: ../Doc/library/asyncio-eventloop.rst:1277
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr "스케줄 된 콜백 시간을 :class:`float` 초로 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1279
#, fuzzy
msgid ""
"The time is an absolute timestamp, using the same time reference as "
":meth:`loop.time`."
msgstr "시간은 절대 타임스탬프입니다. :meth:`AbstractEventLoop.time` 과 같은 시간 참조를 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:1286
msgid "Server Objects"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1288
#, fuzzy
msgid ""
"Server objects are created by :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :func:`start_server`, and "
":func:`start_unix_server` functions."
msgstr ""
":meth:`AbstractEventLoop.create_server`, "
":meth:`AbstractEventLoop.create_unix_server`, :func:`start_server`, "
":func:`start_unix_server` 함수가 만드는 객체. 클래스의 인스턴스를 직접 만들지 마십시오."

#: ../Doc/library/asyncio-eventloop.rst:1292
msgid "Do not instantiate the class directly."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1296
msgid ""
"*Server* objects are asynchronous context managers.  When used in an "
"``async with`` statement, it's guaranteed that the Server object is "
"closed and not accepting new connections when the ``async with`` "
"statement is completed::"
msgstr ""
"*Server* 객체는 비동기 컨텍스트 관리자입니다. ``async with`` 문에서 사용될 때, ``async with`` 문이"
" 완료되면 서버 객체가 닫혀 있고 새 연결을 받아들이지 않는다는 것이 보장됩니다::"

#: ../Doc/library/asyncio-eventloop.rst:1309
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr "Server 객체는 파이썬 3.7부터 비동기 컨텍스트 관리자입니다."

#: ../Doc/library/asyncio-eventloop.rst:1314
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` "
"attribute to ``None``."
msgstr "서버를 중지합니다: 리스닝 소켓을 닫고 :attr:`sockets` 어트리뷰트를 ``None`` 으로 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:1317
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr "이미 받아들여진 클라이언트 연결을 나타내는 소켓은 열린 채로 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1320
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` "
"coroutine to wait until the server is closed."
msgstr "서버는 비동기적으로 닫힙니다. 서버가 닫힐 때까지 대기하려면 :meth:`wait_closed` 코루틴을 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1325
#, fuzzy
msgid "Return the event loop associated with the server object."
msgstr "서버 객체와 연관된 이벤트 루프를 제공합니다."

#: ../Doc/library/asyncio-eventloop.rst:1331
msgid "Start accepting connections."
msgstr "연결을 받아들이기 시작합니다."

#: ../Doc/library/asyncio-eventloop.rst:1333
msgid ""
"This method is idempotent, so it can be called when the server is already"
" being serving."
msgstr "이 메서드는 멱등적이라서, 서버가 이미 시작되었을 때도 호출 할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1336
#, fuzzy
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is "
"not accepting connections initially.  In this case "
"``Server.start_serving()``, or :meth:`Server.serve_forever` can be used "
"to make the Server start accepting connections."
msgstr ""
":meth:`AbstractEventLoop.create_server`\\와 :meth:`asyncio.start_server` 의"
" 새로운 *start_serving* 키워드 전용 매개 변수는 즉시 연결을 받아들이지 않는 서버 객체를 만들 수 있도록 합니다. 이"
" 경우, 이 메서드나 :meth:`Server.serve_forever`\\를 사용하여 Server 객체가 연결을 받아들이기 "
"시작하도록 할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1347
msgid ""
"Start accepting connections until the coroutine is cancelled. "
"Cancellation of ``serve_forever`` task causes the server to be closed."
msgstr "코루틴이 취소될 때까지 연결을 받아들이기 시작합니다. ``serve_forever`` 태스크를 취소하면 서버가 닫힙니다."

#: ../Doc/library/asyncio-eventloop.rst:1351
msgid ""
"This method can be called if the server is already accepting connections."
"  Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"이 메서드는 서버가 이미 연결을 받아들이고 있어도 호출 할 수 있습니다. 하나의 *Server* 객체 당 하나의 "
"``serve_forever`` 태스크만 존재할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1373
msgid "Return ``True`` if the server is accepting new connections."
msgstr "서버가 새 연결을 받아들이고 있으면 ``True`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1379
msgid "Wait until the :meth:`close` method completes."
msgstr ":meth:`close` 메서드가 완료될 때까지 기다립니다."

#: ../Doc/library/asyncio-eventloop.rst:1383
#, fuzzy
msgid ""
"List of :class:`socket.socket` objects the server is listening on, or "
"``None`` if the server is closed."
msgstr "서버가 리스닝하고 있는 :class:`socket.socket` 객체의 리스트, 또는 서버가 닫혀 있다면 ``None``."

#: ../Doc/library/asyncio-eventloop.rst:1386
#, fuzzy
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of"
" server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"Python 3.7 이전에는 ``Server.sockets`` 가 서버 소켓의 내부 리스트를 직접 반환했습니다. 3.7에서는 그 "
"리스트의 복사본이 반환됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1395
#, fuzzy
msgid "Event Loop Implementations"
msgstr "이벤트 루프 예제"

#: ../Doc/library/asyncio-eventloop.rst:1397
msgid ""
"asyncio ships with two different event loop implementations: "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1400
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on all"
" platforms."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1406
msgid "An event loop based on the :mod:`selectors` module."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1408
msgid ""
"Uses the most efficient *selector* available for the given platform.  It "
"is also possible to manually configure the exact selector implementation "
"to be used::"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1420
#, fuzzy
msgid "Availability: Unix, Windows."
msgstr "가용성: 유닉스 전용."

#: ../Doc/library/asyncio-eventloop.rst:1425
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1428
#, fuzzy
msgid "Availability: Windows."
msgstr "가용성: 유닉스."

#: ../Doc/library/asyncio-eventloop.rst:1429
msgid "An example how to use :class:`ProactorEventLoop` on Windows::"
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1440
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com"
"/en-ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1446
#, fuzzy
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "이벤트 루프의 추상 베이스 클래스입니다."

#: ../Doc/library/asyncio-eventloop.rst:1448
msgid ""
"The :ref:`Event Loop Methods <asyncio-event-loop>` section lists all "
"methods that an alternative implementation of ``AbstractEventLoop`` "
"should have defined."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1454
#, fuzzy
msgid "Examples"
msgstr "예::"

#: ../Doc/library/asyncio-eventloop.rst:1456
msgid ""
"Note that all examples in this section **purposefully** show how to use "
"the low-level event loop APIs, such as :meth:`loop.run_forever` and "
":meth:`loop.call_soon`.  Modern asyncio applications rarely need to be "
"written this way; consider using the high-level functions like "
":func:`asyncio.run`."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1466
msgid "Hello World with call_soon()"
msgstr "call_soon()을 사용하는 Hello World"

#: ../Doc/library/asyncio-eventloop.rst:1468
#, fuzzy
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a "
"callback. The callback displays ``\"Hello World\"`` and then stops the "
"event loop::"
msgstr ""
"콜백을 스케줄 하기 위해 :meth:`AbstractEventLoop.call_soon` 메서드를 사용하는 예제. 콜백은 "
"``\"Hello World\"`` 를 표시한 다음 이벤트 루프를 중지합니다::"

#: ../Doc/library/asyncio-eventloop.rst:1492
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine"
" and the :func:`run` function."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1499
msgid "Display the current date with call_later()"
msgstr "call_later()로 현재 날짜를 표시합니다."

#: ../Doc/library/asyncio-eventloop.rst:1501
#, fuzzy
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself "
"after 5 seconds, and then stops the event loop::"
msgstr ""
"초마다 현재 날짜를 표시하는 콜백의 예입니다. 콜백은 :meth:`AbstractEventLoop.call_later` 메서드를 "
"사용하여 5초 동안 자신을 다시 스케줄 한 다음 이벤트 루프를 중지합니다::"

#: ../Doc/library/asyncio-eventloop.rst:1529
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created "
"with a coroutine and the :func:`run` function."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1536
msgid "Watch a file descriptor for read events"
msgstr "파일 기술자에서 읽기 이벤트를 관찰하기"

#: ../Doc/library/asyncio-eventloop.rst:1538
#, fuzzy
msgid ""
"Wait until a file descriptor received some data using the "
":meth:`loop.add_reader` method and then close the event loop::"
msgstr ""
":meth:`AbstractEventLoop.add_reader` 메서드를 사용하여 파일 기술자가 데이터를 수신할 때까지 기다렸다가"
" 이벤트 루프를 닫습니다::"

#: ../Doc/library/asyncio-eventloop.rst:1576
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1580
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-"
"streams>` using the high-level :func:`asyncio.open_connection` function "
"and streams."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:1588
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "SIGINT 및 SIGTERM에 대한 시그널 처리기 설정"

#: ../Doc/library/asyncio-eventloop.rst:1590
#, fuzzy
msgid "(This ``signals`` example only works on Unix.)"
msgstr "이 예제는 유닉스에서만 작동합니다."

#: ../Doc/library/asyncio-eventloop.rst:1592
#, fuzzy
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` "
"using the :meth:`loop.add_signal_handler` method::"
msgstr ""
":meth:`AbstractEventLoop.add_signal_handler` 메서드를 사용하여 "
":py:data:`SIGINT`\\와 :py:data:`SIGTERM` 시그널을 위한 처리기를 등록합니다::"

#~ msgid "Base Event Loop"
#~ msgstr "베이스 이벤트 루프"

#~ msgid "**Source code:** :source:`Lib/asyncio/events.py`"
#~ msgstr "**소스 코드:** :source:`Lib/asyncio/events.py`"

#~ msgid ""
#~ "The event loop is the central "
#~ "execution device provided by :mod:`asyncio`."
#~ " It provides multiple facilities, "
#~ "including:"
#~ msgstr "이벤트 루프는 :mod:`asyncio` 가 제공하는 중앙 실행 장치입니다. 다음과 같은 여러 시설을 제공합니다:"

#~ msgid "Registering, executing and cancelling delayed calls (timeouts)."
#~ msgstr "지연된 호출(시간제한)을 등록, 실행, 취소하기."

#~ msgid ""
#~ "Creating client and server :ref:`transports"
#~ " <asyncio-transport>` for various kinds "
#~ "of communication."
#~ msgstr "다양한 종류의 통신을 위한 클라이언트와 서버 :ref:`트랜스포트 <asyncio-transport>` 만들기."

#~ msgid ""
#~ "Launching subprocesses and the associated "
#~ ":ref:`transports <asyncio-transport>` for "
#~ "communication with an external program."
#~ msgstr "외부 프로그램과의 통신을 위해 서브 프로세스와 관련 :ref:`트랜스포트 <asyncio-transport>` 시작하기."

#~ msgid "Delegating costly function calls to a pool of threads."
#~ msgstr "비싼 함수 호출을 스레드 풀에 위임하기."

#~ msgid ""
#~ "This class is an implementation detail."
#~ "  It is a subclass of "
#~ ":class:`AbstractEventLoop` and may be a "
#~ "base class of concrete event loop "
#~ "implementations found in :mod:`asyncio`.  It"
#~ " should not be used directly; use "
#~ ":class:`AbstractEventLoop` instead. ``BaseEventLoop`` "
#~ "should not be subclassed by third-"
#~ "party code; the internal interface is"
#~ " not stable."
#~ msgstr ""
#~ "이 클래스는 구현 세부 사항입니다. "
#~ ":class:`AbstractEventLoop` 의 서브 클래스이며, "
#~ ":mod:`asyncio` 에서 발견되는 구상 이벤트 루프 "
#~ "구현의 베이스 클래스가 될 수 있습니다. 직접 "
#~ "사용해서는 안 됩니다; 대신 :class:`AbstractEventLoop`\\를"
#~ " 사용하십시오. ``BaseEventLoop`` 는 제삼자 코드에 "
#~ "의해 서브 클래싱 되어서는 안 됩니다; 내부 "
#~ "인터페이스는 안정적이지 않습니다."

#~ msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
#~ msgstr "이 클래스는 :ref:`스레드 안전하지 않습니다 <asyncio-multithreading>`."

#~ msgid ""
#~ "Run until :meth:`stop` is called.  If"
#~ " :meth:`stop` is called before "
#~ ":meth:`run_forever()` is called, this polls"
#~ " the I/O selector once with a "
#~ "timeout of zero, runs all callbacks "
#~ "scheduled in response to I/O events "
#~ "(and those that were already scheduled),"
#~ " and then exits. If :meth:`stop` is"
#~ " called while :meth:`run_forever` is "
#~ "running, this will run the current "
#~ "batch of callbacks and then exit.  "
#~ "Note that callbacks scheduled by "
#~ "callbacks will not run in that "
#~ "case; they will run the next time"
#~ " :meth:`run_forever` is called."
#~ msgstr ""
#~ ":meth:`stop` 이 호출 될 때까지 실행합니다. "
#~ ":meth:`run_forever()` 가 호출되기 전에 :meth:`stop`"
#~ " 이 호출되었으면, 이것은 시간제한 0으로 I/O "
#~ "셀렉터를 한 번 폴링하고, I/O 이벤트에 따라 "
#~ "스케줄 된 모든 콜백(과 이미 스케줄 된 것들)을"
#~ " 실행한 다음 종료합니다. 만약 :meth:`stop` 이 "
#~ ":meth:`run_forever` 가 실행 중일 때 호출되면, "
#~ "현재 걸려있는 콜백들을 실행한 다음 종료합니다. 콜백에 "
#~ "의해 스케줄 되는 콜백은 이 경우 실행되지 "
#~ "않습니다; 그것들은 다음에 :meth:`run_forever` 가 호출될"
#~ " 때 실행됩니다."

#~ msgid "Run until the :class:`Future` is done."
#~ msgstr ":class:`Future` 가 완료될 때까지 실행합니다."

#~ msgid "Returns running status of event loop."
#~ msgstr "이벤트 루프의 실행 상태를 반환합니다."

#~ msgid ""
#~ "This causes :meth:`run_forever` to exit "
#~ "at the next suitable opportunity (see"
#~ " there for more details)."
#~ msgstr ":meth:`run_forever` 가 다음 적절한 기회에 종료하도록 합니다 (자세한 내용은 그 메서드를 보세요)."

#~ msgid "Calls"
#~ msgstr "호출"

#~ msgid ""
#~ "Most :mod:`asyncio` functions don't accept "
#~ "keywords. If you want to pass "
#~ "keywords to your callback, use "
#~ ":func:`functools.partial`. For example, "
#~ "``loop.call_soon(functools.partial(print, \"Hello\", "
#~ "flush=True))`` will call ``print(\"Hello\", "
#~ "flush=True)``."
#~ msgstr ""
#~ "대부분 :mod:`asyncio` 함수는 키워드를 받아들이지 않습니다."
#~ " 여러분의 콜백에 키워드를 전달하려면, "
#~ ":func:`functools.partial` 을 사용하십시오. 예를 들어, "
#~ "``loop.call_soon(functools.partial(print, \"Hello\", "
#~ "flush=True))`` 는 ``print(\"Hello\", flush=True)``"
#~ " 를 호출합니다."

#~ msgid ""
#~ ":func:`functools.partial` is better than "
#~ "``lambda`` functions, because :mod:`asyncio` "
#~ "can inspect :func:`functools.partial` object "
#~ "to display parameters in debug mode, "
#~ "whereas ``lambda`` functions have a poor"
#~ " representation."
#~ msgstr ""
#~ ":func:`functools.partial` 은 ``lambda`` 함수보다 "
#~ "낫습니다. :mod:`asyncio` 는 디버그 모드에서 매개 "
#~ "변수를 표시하기 위해 :func:`functools.partial` 객체를 "
#~ "검사할 수 있지만, ``lambda`` 함수는 표현이 부족하기"
#~ " 때문입니다."

#~ msgid ""
#~ "Arrange for a callback to be "
#~ "called as soon as possible.  The "
#~ "callback is called after :meth:`call_soon` "
#~ "returns, when control returns to the "
#~ "event loop."
#~ msgstr ""
#~ "콜백을 가능한 한 빨리 호출 할 수 있도록 "
#~ "배치합니다. 콜백은 :meth:`call_soon` 이 반환되고, 제어가"
#~ " 이벤트 루프로 돌아오면 호출됩니다."

#~ msgid ""
#~ "Any positional arguments after the "
#~ "callback will be passed to the "
#~ "callback when it is called."
#~ msgstr "callback 이후의 모든 위치 인자는 호출될 때 콜백에 전달됩니다."

#~ msgid ""
#~ ":ref:`Use functools.partial to pass keywords"
#~ " to the callback <asyncio-pass-"
#~ "keywords>`."
#~ msgstr ":ref:`functools.partial을 사용하여 키워드를 콜백에 전달하십시오 <asyncio-pass-keywords>`."

#~ msgid "Like :meth:`call_soon`, but thread safe."
#~ msgstr ":meth:`call_soon`\\과 같지만, 스레드 안전합니다."

#~ msgid "Delayed calls"
#~ msgstr "지연된 호출"

#~ msgid ""
#~ "The event loop has its own "
#~ "internal clock for computing timeouts. "
#~ "Which clock is used depends on the"
#~ " (platform-specific) event loop "
#~ "implementation; ideally it is a "
#~ "monotonic clock.  This will generally be"
#~ " a different clock than :func:`time.time`."
#~ msgstr ""
#~ "이벤트 루프에는 시간제한 계산을 위한 자체 내부 "
#~ "시계가 있습니다. 사용되는 시계는 (플랫폼 특정) 이벤트"
#~ " 루프 구현에 따라 다릅니다; 이상적으로는 단조증가 하는"
#~ " 시계입니다. 이것은 일반적으로 :func:`time.time` 과 "
#~ "다른 시계입니다."

#~ msgid "Futures"
#~ msgstr "퓨처"

#~ msgid "Tasks"
#~ msgstr "태스크"

#~ msgid "If *factory* is ``None`` the default task factory will be set."
#~ msgstr "*factory* 가 ``None`` 이면 기본 태스크 팩토리가 설정됩니다."

#~ msgid ""
#~ "Create a streaming transport connection "
#~ "to a given Internet *host* and "
#~ "*port*: socket family :py:data:`~socket.AF_INET` "
#~ "or :py:data:`~socket.AF_INET6` depending on "
#~ "*host* (or *family* if specified), "
#~ "socket type :py:data:`~socket.SOCK_STREAM`.  "
#~ "*protocol_factory* must be a callable "
#~ "returning a :ref:`protocol <asyncio-protocol>`"
#~ " instance."
#~ msgstr ""
#~ "주어진 *host* 와 *port* 로의 스트리밍 트랜스포트"
#~ " 연결을 만듭니다: *host* 에 따라 소켓 패밀리"
#~ " :py:data:`~socket.AF_INET` 또는 "
#~ ":py:data:`~socket.AF_INET6` (또는 지정된 경우 "
#~ "*family*), 소켓 유형 :py:data:`~socket.SOCK_STREAM`. "
#~ "*protocol_factory* 는 :ref:`프로토콜 <asyncio-"
#~ "protocol>` 인스턴스를 반환하는 콜러블이어야 합니다."

#~ msgid ""
#~ "The coroutine returns successfully with "
#~ "the ``(transport, protocol)`` pair."
#~ msgstr "코루틴은 성공적으로 ``(transport, protocol)`` 쌍을 반환합니다."

#~ msgid ""
#~ "*protocol_factory* can be any kind of"
#~ " callable, not necessarily a class.  "
#~ "For example, if you want to use"
#~ " a pre-created protocol instance, you"
#~ " can pass ``lambda: my_protocol``."
#~ msgstr ""
#~ "*protocol_factory* 는 모든 종류의 콜러블일 수 "
#~ "있고, 꼭 클래스 일 필요는 없습니다. 예를 들어,"
#~ " 미리 만들어진 프로토콜 인스턴스를 사용하려면, ``lambda:"
#~ " my_protocol`` 을 전달하면 됩니다."

#~ msgid "Options that change how the connection is created:"
#~ msgstr "연결 생성 방법을 변경하는 옵션:"

#~ msgid ""
#~ "*server_hostname*, is only for use "
#~ "together with *ssl*, and sets or "
#~ "overrides the hostname that the target"
#~ " server's certificate will be matched "
#~ "against.  By default the value of "
#~ "the *host* argument is used.  If "
#~ "*host* is empty, there is no "
#~ "default and you must pass a value"
#~ " for *server_hostname*.  If *server_hostname* "
#~ "is an empty string, hostname matching"
#~ " is disabled (which is a serious "
#~ "security risk, allowing for man-in-"
#~ "the-middle-attacks)."
#~ msgstr ""
#~ "*server_hostname* 은 *ssl* 과 함께 사용하기 "
#~ "위한 것이며 대상 서버의 인증서가 일치될 호스트 "
#~ "이름을 설정하거나 바꿉니다. 기본적으로 *host* 인자의 "
#~ "값이 사용됩니다. *host* 가 비어 있으면, 기본값이"
#~ " 없고 *server_hostname* 값을 전달해야 합니다. "
#~ "*server_hostname* 이 빈 문자열이면, 호스트 이름 "
#~ "일치가 비활성화됩니다 (이것은 심각한 보안 위험으로, 중간자"
#~ " 공격을 허용하게 됩니다)."

#~ msgid "On Windows with :class:`ProactorEventLoop`, SSL/TLS is now supported."
#~ msgstr "윈도우에서 :class:`ProactorEventLoop`\\를 사용할 때, 이제 SSL/TLS가 지원됩니다."

#~ msgid ""
#~ "Create datagram connection: socket family "
#~ ":py:data:`~socket.AF_INET`, :py:data:`~socket.AF_INET6` or"
#~ " :py:data:`~socket.AF_UNIX` depending on *host*"
#~ " (or *family* if specified), socket "
#~ "type :py:data:`~socket.SOCK_DGRAM`. *protocol_factory* "
#~ "must be a callable returning a "
#~ ":ref:`protocol <asyncio-protocol>` instance."
#~ msgstr ""
#~ "데이터 그램 연결을 만듭니다: *host*\\(또는 주어지면 "
#~ "*family*)에 따라 소켓 패밀리 "
#~ ":py:data:`~socket.AF_INET`, :py:data:`~socket.AF_INET6` 또는"
#~ " :py:data:`~socket.AF_UNIX`, 소켓 유형 "
#~ ":py:data:`~socket.SOCK_DGRAM`. *protocol_factory* 는 "
#~ ":ref:`프로토콜 <asyncio-protocol>` 인스턴스를 반환하는 "
#~ "콜러블이어야 합니다."

#~ msgid "Options changing how the connection is created:"
#~ msgstr "연결 생성 방법을 변경하는 옵션:"

#~ msgid ""
#~ "Create UNIX connection: socket family "
#~ ":py:data:`~socket.AF_UNIX`, socket type "
#~ ":py:data:`~socket.SOCK_STREAM`. The "
#~ ":py:data:`~socket.AF_UNIX` socket family is "
#~ "used to communicate between processes on"
#~ " the same machine efficiently."
#~ msgstr ""
#~ "유닉스 연결을 만듭니다: 소켓 패밀리 "
#~ ":py:data:`~socket.AF_UNIX`, 소켓 유형 "
#~ ":py:data:`~socket.SOCK_STREAM`. 같은 기계의 프로세스 간에"
#~ " 효율적으로 통신하기 위해 :py:data:`~socket.AF_UNIX` "
#~ "소켓 패밀리가 사용됩니다."

#~ msgid ""
#~ "See the :meth:`AbstractEventLoop.create_connection` "
#~ "method for parameters."
#~ msgstr "매개 변수는 :meth:`AbstractEventLoop.create_connection` 메서드를 참조하십시오."

#~ msgid "Creating listening connections"
#~ msgstr "리스닝 연결 만들기"

#~ msgid ""
#~ "Return a :class:`Server` object, its "
#~ ":attr:`~Server.sockets` attribute contains created"
#~ " sockets. Use the :meth:`Server.close` "
#~ "method to stop the server: close "
#~ "listening sockets."
#~ msgstr ""
#~ ":class:`Server` 객체를 반환합니다. :attr:`~Server.sockets`"
#~ " 어트리뷰트에 생성된 소켓이 저장됩니다. 서버를 종료하려면 "
#~ ":meth:`Server.close` 메서드를 사용하십시오: 리스닝 소켓을 "
#~ "닫습니다."

#~ msgid ""
#~ "The *host* parameter can be a "
#~ "string, in that case the TCP "
#~ "server is bound to *host* and "
#~ "*port*. The *host* parameter can also"
#~ " be a sequence of strings and "
#~ "in that case the TCP server is "
#~ "bound to all hosts of the "
#~ "sequence. If *host* is an empty "
#~ "string or ``None``, all interfaces are"
#~ " assumed and a list of multiple "
#~ "sockets will be returned (most likely"
#~ " one for IPv4 and another one "
#~ "for IPv6)."
#~ msgstr ""
#~ "*host* 매개 변수는 문자열일 수 있습니다. 이 "
#~ "경우 TCP 서버는 *host* 와 *port* 에 "
#~ "바인드 됩니다. *host* 매개 변수는 문자열의 시퀀스일"
#~ " 수도 있으며, 이 경우 TCP 서버는 시퀀스의 "
#~ "모든 호스트에 바인드 됩니다. *host* 가 빈 "
#~ "문자열이거나 ``None`` 이면, 모든 인터페이스가 사용되는 "
#~ "것으로 가정하고, 여러 소켓의 리스트가 반환됩니다 (대체로"
#~ " IPv4 하나와 IPv6 하나)."

#~ msgid "*ssl_handshake_timeout* and *start_serving* parameters."
#~ msgstr "*ssl_handshake_timeout* 과 *start_serving* 매개 변수."

#~ msgid ""
#~ "The function :func:`start_server` creates a"
#~ " (:class:`StreamReader`, :class:`StreamWriter`) pair"
#~ " and calls back a function with "
#~ "this pair."
#~ msgstr ""
#~ "함수 :func:`start_server` 는 (:class:`StreamReader`,"
#~ " :class:`StreamWriter`) 쌍을 만들고, 이 쌍으로 "
#~ "콜백 함수를 호출합니다."

#~ msgid "Handle an accepted connection."
#~ msgstr "받아들인 연결을 처리합니다."

#~ msgid ""
#~ "On Windows with :class:`SelectorEventLoop`, "
#~ "only socket handles are supported (ex:"
#~ " pipe file descriptors are not "
#~ "supported)."
#~ msgstr ""
#~ "윈도우에서 :class:`SelectorEventLoop`\\를 사용할 때, 소켓"
#~ " 핸들만 지원됩니다 (예를 들어, 파이프 파일 기술자는"
#~ " 지원되지 않습니다)."

#~ msgid ""
#~ "On Windows with :class:`ProactorEventLoop`, "
#~ "these methods are not supported."
#~ msgstr "윈도우에서 :class:`ProactorEventLoop`\\를 사용할 때, 이 메서드는 지원되지 않습니다."

#~ msgid ""
#~ "The :ref:`watch a file descriptor for"
#~ " read events <asyncio-watch-read-"
#~ "event>` example uses the low-level "
#~ ":meth:`AbstractEventLoop.add_reader` method to "
#~ "register the file descriptor of a "
#~ "socket."
#~ msgstr ""
#~ ":ref:`파일 기술자에서 읽기 이벤트를 관찰하기 <asyncio-"
#~ "watch-read-event>` 예제는 저수준의 "
#~ ":meth:`AbstractEventLoop.add_reader` 메서드를 사용하여 소켓의"
#~ " 파일 기술자를 등록합니다."

#~ msgid "Low-level socket operations"
#~ msgstr "저수준 소켓 연산"

#~ msgid ""
#~ "Receive data from the socket.  Modeled"
#~ " after blocking :meth:`socket.socket.recv` "
#~ "method."
#~ msgstr "소켓에서 데이터를 수신합니다. 블로킹 :meth:`socket.socket.recv` 메서드를 따라 만들어졌습니다."

#~ msgid ""
#~ "The return value is a bytes object"
#~ " representing the data received.  The "
#~ "maximum amount of data to be "
#~ "received at once is specified by "
#~ "*nbytes*."
#~ msgstr ""
#~ "반환 값은 수신된 데이터를 나타내는 바이트열 객체입니다."
#~ " 한 번에 수신 할 수 있는 최대 데이터"
#~ " 크기는 *nbytes* 로 지정됩니다."

#~ msgid ""
#~ "With :class:`SelectorEventLoop` event loop, "
#~ "the socket *sock* must be non-"
#~ "blocking."
#~ msgstr ""
#~ ":class:`SelectorEventLoop` 이벤트 루프를 사용할 때, "
#~ "소켓 *sock* 은 비 블로킹(non-blocking)이어야합니다."

#~ msgid ""
#~ "The received data is written into "
#~ "*buf* (a writable buffer). The return"
#~ " value is the number of bytes "
#~ "written."
#~ msgstr "수신된 데이터는 *buf* (쓰기 가능한 버퍼)에 기록됩니다. 반환 값은 기록된 바이트 수입니다."

#~ msgid ""
#~ "Send data to the socket.  Modeled "
#~ "after blocking :meth:`socket.socket.sendall` method."
#~ msgstr "소켓으로 데이터를 보냅니다. 블로킹 :meth:`socket.socket.sendall` 메서드를 따라 만들어졌습니다."

#~ msgid ""
#~ "Connect to a remote socket at "
#~ "*address*.  Modeled after blocking "
#~ ":meth:`socket.socket.connect` method."
#~ msgstr ""
#~ "*address* 에 있는 원격 소켓에 연결합니다. 블로킹"
#~ " :meth:`socket.socket.connect` 메서드를 따라 만들어졌습니다."

#~ msgid "Resolve host name"
#~ msgstr "호스트 이름 결정"

#~ msgid ""
#~ "This method is a :ref:`coroutine "
#~ "<coroutine>`, similar to :meth:`socket.getaddrinfo`"
#~ " function but non-blocking."
#~ msgstr ""
#~ "이 메서드는 :ref:`코루틴 <coroutine>` 입니다. "
#~ ":meth:`socket.getaddrinfo` 함수와 비슷하지만, 비 "
#~ "블로킹입니다."

#~ msgid ""
#~ "This method is a :ref:`coroutine "
#~ "<coroutine>`, similar to :meth:`socket.getnameinfo`"
#~ " function but non-blocking."
#~ msgstr ""
#~ "이 메서드는 :ref:`코루틴 <coroutine>` 입니다. "
#~ ":meth:`socket.getnameinfo` 함수와 비슷하지만, 비 "
#~ "블로킹입니다."

#~ msgid "Connect pipes"
#~ msgstr "파이프 연결"

#~ msgid ""
#~ "*protocol_factory* should instantiate object "
#~ "with :class:`Protocol` interface.  *pipe* is"
#~ " a :term:`file-like object <file "
#~ "object>`. Return pair ``(transport, "
#~ "protocol)``, where *transport* supports the"
#~ " :class:`ReadTransport` interface."
#~ msgstr ""
#~ "*protocol_factory* 는 :class:`Protocol` 인터페이스를 "
#~ "갖는 객체의 인스턴스를 만들어야 합니다. *pipe* 는"
#~ " :term:`파일류 객체 <file object>` 입니다. "
#~ "``(transport, protocol)`` 쌍을 반환하는데, "
#~ "*transport* 는 :class:`ReadTransport` 인터페이스를 "
#~ "지원합니다."

#~ msgid ""
#~ "*protocol_factory* should instantiate object "
#~ "with :class:`BaseProtocol` interface. *pipe* "
#~ "is :term:`file-like object <file "
#~ "object>`. Return pair ``(transport, "
#~ "protocol)``, where *transport* supports "
#~ ":class:`WriteTransport` interface."
#~ msgstr ""
#~ "*protocol_factory* 는 :class:`BaseProtocol` 인터페이스를"
#~ " 갖는 객체의 인스턴스를 만들어야 합니다. *pipe* "
#~ "는 :term:`파일류 객체 <file object>` 입니다. "
#~ "``(transport, protocol)`` 쌍을 반환하는데, "
#~ "*transport* 는 :class:`WriteTransport` 인터페이스를 "
#~ "지원합니다."

#~ msgid "Add a handler for a signal."
#~ msgstr "시그널 처리기를 추가합니다."

#~ msgid "Executor"
#~ msgstr "실행기"

#~ msgid ""
#~ "Call a function in an "
#~ ":class:`~concurrent.futures.Executor` (pool of "
#~ "threads or pool of processes). By "
#~ "default, an event loop uses a "
#~ "thread pool executor "
#~ "(:class:`~concurrent.futures.ThreadPoolExecutor`)."
#~ msgstr ""
#~ ":class:`~concurrent.futures.Executor`\\(스레드 풀 또는 "
#~ "프로세스 풀)에서 함수를 호출합니다. 기본적으로, 이벤트 "
#~ "루프는 스레드 풀 "
#~ "실행기(:class:`~concurrent.futures.ThreadPoolExecutor`)를 사용합니다."

#~ msgid "Set the default executor used by :meth:`run_in_executor`."
#~ msgstr ":meth:`run_in_executor` 가 사용하는 기본 실행기를 설정합니다."

#~ msgid "If *handler* is ``None``, the default exception handler will be set."
#~ msgstr "*handler* 가 ``None`` 이면 기본 예외 처리기가 설정됩니다."

#~ msgid ""
#~ "If *handler* is a callable object, "
#~ "it should have a matching signature "
#~ "to ``(loop, context)``, where ``loop`` "
#~ "will be a reference to the active"
#~ " event loop, ``context`` will be a"
#~ " ``dict`` object (see "
#~ ":meth:`call_exception_handler` documentation for "
#~ "details about context)."
#~ msgstr ""
#~ "*handler* 가 콜러블 객체면, ``(loop, context)``"
#~ " 와 일치하는 서명을 가져야 합니다. 여기서 "
#~ "``loop`` 는 활성 이벤트 루프에 대한 참조가 "
#~ "될 것이고, ``context`` 는 ``dict`` 객체가 "
#~ "됩니다 (context에 대한 자세한 내용은 "
#~ ":meth:`call_exception_handler` 문서를 참조하십시오)."

#~ msgid "Server"
#~ msgstr "Server"

#~ msgid "Server listening on sockets."
#~ msgstr "소켓을 리스닝하는 서버."

#~ msgid "Handle"
#~ msgstr "Handle"

#~ msgid "SendfileNotAvailableError"
#~ msgstr "SendfileNotAvailableError"

#~ msgid "Sendfile syscall is not available, subclass of :exc:`RuntimeError`."
#~ msgstr "Sendfile 시스템 호출을 사용할 수 없습니다. :exc:`RuntimeError` 의 서브 클래스."

#~ msgid ""
#~ "Raised if the OS does not support"
#~ " sendfile syscall for given socket or"
#~ " file type."
#~ msgstr "OS가 주어진 소켓 또는 파일 유형에 대해 sendfile 시스템 호출을 지원하지 않는 경우 발생합니다."

#~ msgid ""
#~ "The :ref:`Hello World coroutine <asyncio-"
#~ "hello-world-coroutine>` example uses a"
#~ " :ref:`coroutine <coroutine>`."
#~ msgstr ""
#~ ":ref:`Hello World 코루틴 <asyncio-hello-"
#~ "world-coroutine>` 예제는 :ref:`코루틴 <coroutine>` "
#~ "을 사용합니다."

#~ msgid ""
#~ "The :ref:`coroutine displaying the current "
#~ "date <asyncio-date-coroutine>` example "
#~ "uses a :ref:`coroutine <coroutine>`."
#~ msgstr ""
#~ ":ref:`현재 날짜를 표시하는 코루틴 <asyncio-date-"
#~ "coroutine>` 예제는 :ref:`코루틴 <coroutine>` 을 "
#~ "사용합니다."

#~ msgid ""
#~ "The :ref:`register an open socket to "
#~ "wait for data using a protocol "
#~ "<asyncio-register-socket>` example uses a"
#~ " low-level protocol created by the"
#~ " :meth:`AbstractEventLoop.create_connection` method."
#~ msgstr ""
#~ ":ref:`프로토콜을 사용하여 데이터를 기다리는 열린 소켓 "
#~ "등록 <asyncio-register-socket>` 예제는 "
#~ ":meth:`AbstractEventLoop.create_connection` 메서드에 의해 "
#~ "생성된 저수준 프로토콜을 사용합니다."

#~ msgid ""
#~ "The :ref:`register an open socket to "
#~ "wait for data using streams <asyncio-"
#~ "register-socket-streams>` example uses "
#~ "high-level streams created by the "
#~ ":func:`open_connection` function in a "
#~ "coroutine."
#~ msgstr ""
#~ ":ref:`스트림을 사용하여 데이터를 기다리는 열린 소켓 등록"
#~ " <asyncio-register-socket-streams>` 예제는 "
#~ "코루틴에서 :func:`open_connection` 함수에 의해 생성된 "
#~ "고수준 스트림을 사용합니다."

